(self["webpackChunkmotion_kit"] = self["webpackChunkmotion_kit"] || []).push([["vendors-node_modules_a"],{

/***/ "./node_modules/@mdx-js/react/index.js":
/*!*********************************************!*\
  !*** ./node_modules/@mdx-js/react/index.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   MDXProvider: () => (/* reexport safe */ _lib_index_js__WEBPACK_IMPORTED_MODULE_0__.MDXProvider),
/* harmony export */   useMDXComponents: () => (/* reexport safe */ _lib_index_js__WEBPACK_IMPORTED_MODULE_0__.useMDXComponents)
/* harmony export */ });
/* harmony import */ var _lib_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lib/index.js */ "./node_modules/@mdx-js/react/lib/index.js");



/***/ }),

/***/ "./node_modules/@mdx-js/react/lib/index.js":
/*!*************************************************!*\
  !*** ./node_modules/@mdx-js/react/lib/index.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   MDXProvider: () => (/* binding */ MDXProvider),
/* harmony export */   useMDXComponents: () => (/* binding */ useMDXComponents)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/**
 * @import {MDXComponents} from 'mdx/types.js'
 * @import {Component, ReactElement, ReactNode} from 'react'
 */

/**
 * @callback MergeComponents
 *   Custom merge function.
 * @param {Readonly<MDXComponents>} currentComponents
 *   Current components from the context.
 * @returns {MDXComponents}
 *   Additional components.
 *
 * @typedef Props
 *   Configuration for `MDXProvider`.
 * @property {ReactNode | null | undefined} [children]
 *   Children (optional).
 * @property {Readonly<MDXComponents> | MergeComponents | null | undefined} [components]
 *   Additional components to use or a function that creates them (optional).
 * @property {boolean | null | undefined} [disableParentContext=false]
 *   Turn off outer component context (default: `false`).
 */



/** @type {Readonly<MDXComponents>} */
const emptyComponents = {}

const MDXContext = react__WEBPACK_IMPORTED_MODULE_0___default().createContext(emptyComponents)

/**
 * Get current components from the MDX Context.
 *
 * @param {Readonly<MDXComponents> | MergeComponents | null | undefined} [components]
 *   Additional components to use or a function that creates them (optional).
 * @returns {MDXComponents}
 *   Current components.
 */
function useMDXComponents(components) {
  const contextComponents = react__WEBPACK_IMPORTED_MODULE_0___default().useContext(MDXContext)

  // Memoize to avoid unnecessary top-level context changes
  return react__WEBPACK_IMPORTED_MODULE_0___default().useMemo(
    function () {
      // Custom merge via a function prop
      if (typeof components === 'function') {
        return components(contextComponents)
      }

      return {...contextComponents, ...components}
    },
    [contextComponents, components]
  )
}

/**
 * Provider for MDX context.
 *
 * @param {Readonly<Props>} properties
 *   Properties.
 * @returns {ReactElement}
 *   Element.
 * @satisfies {Component}
 */
function MDXProvider(properties) {
  /** @type {Readonly<MDXComponents>} */
  let allComponents

  if (properties.disableParentContext) {
    allComponents =
      typeof properties.components === 'function'
        ? properties.components(emptyComponents)
        : properties.components || emptyComponents
  } else {
    allComponents = useMDXComponents(properties.components)
  }

  return react__WEBPACK_IMPORTED_MODULE_0___default().createElement(
    MDXContext.Provider,
    {value: allComponents},
    properties.children
  )
}


/***/ }),

/***/ "./node_modules/ansi-html-community/index.js":
/*!***************************************************!*\
  !*** ./node_modules/ansi-html-community/index.js ***!
  \***************************************************/
/***/ ((module) => {

"use strict";


module.exports = ansiHTML

// Reference to https://github.com/sindresorhus/ansi-regex
var _regANSI = /(?:(?:\u001b\[)|\u009b)(?:(?:[0-9]{1,3})?(?:(?:;[0-9]{0,3})*)?[A-M|f-m])|\u001b[A-M]/

var _defColors = {
  reset: ['fff', '000'], // [FOREGROUD_COLOR, BACKGROUND_COLOR]
  black: '000',
  red: 'ff0000',
  green: '209805',
  yellow: 'e8bf03',
  blue: '0000ff',
  magenta: 'ff00ff',
  cyan: '00ffee',
  lightgrey: 'f0f0f0',
  darkgrey: '888'
}
var _styles = {
  30: 'black',
  31: 'red',
  32: 'green',
  33: 'yellow',
  34: 'blue',
  35: 'magenta',
  36: 'cyan',
  37: 'lightgrey'
}
var _openTags = {
  '1': 'font-weight:bold', // bold
  '2': 'opacity:0.5', // dim
  '3': '<i>', // italic
  '4': '<u>', // underscore
  '8': 'display:none', // hidden
  '9': '<del>' // delete
}
var _closeTags = {
  '23': '</i>', // reset italic
  '24': '</u>', // reset underscore
  '29': '</del>' // reset delete
}

;[0, 21, 22, 27, 28, 39, 49].forEach(function (n) {
  _closeTags[n] = '</span>'
})

/**
 * Converts text with ANSI color codes to HTML markup.
 * @param {String} text
 * @returns {*}
 */
function ansiHTML (text) {
  // Returns the text if the string has no ANSI escape code.
  if (!_regANSI.test(text)) {
    return text
  }

  // Cache opened sequence.
  var ansiCodes = []
  // Replace with markup.
  var ret = text.replace(/\033\[(\d+)m/g, function (match, seq) {
    var ot = _openTags[seq]
    if (ot) {
      // If current sequence has been opened, close it.
      if (!!~ansiCodes.indexOf(seq)) { // eslint-disable-line no-extra-boolean-cast
        ansiCodes.pop()
        return '</span>'
      }
      // Open tag.
      ansiCodes.push(seq)
      return ot[0] === '<' ? ot : '<span style="' + ot + ';">'
    }

    var ct = _closeTags[seq]
    if (ct) {
      // Pop sequence
      ansiCodes.pop()
      return ct
    }
    return ''
  })

  // Make sure tags are closed.
  var l = ansiCodes.length
  ;(l > 0) && (ret += Array(l + 1).join('</span>'))

  return ret
}

/**
 * Customize colors.
 * @param {Object} colors reference to _defColors
 */
ansiHTML.setColors = function (colors) {
  if (typeof colors !== 'object') {
    throw new Error('`colors` parameter must be an Object.')
  }

  var _finalColors = {}
  for (var key in _defColors) {
    var hex = colors.hasOwnProperty(key) ? colors[key] : null
    if (!hex) {
      _finalColors[key] = _defColors[key]
      continue
    }
    if ('reset' === key) {
      if (typeof hex === 'string') {
        hex = [hex]
      }
      if (!Array.isArray(hex) || hex.length === 0 || hex.some(function (h) {
        return typeof h !== 'string'
      })) {
        throw new Error('The value of `' + key + '` property must be an Array and each item could only be a hex string, e.g.: FF0000')
      }
      var defHexColor = _defColors[key]
      if (!hex[0]) {
        hex[0] = defHexColor[0]
      }
      if (hex.length === 1 || !hex[1]) {
        hex = [hex[0]]
        hex.push(defHexColor[1])
      }

      hex = hex.slice(0, 2)
    } else if (typeof hex !== 'string') {
      throw new Error('The value of `' + key + '` property must be a hex string, e.g.: FF0000')
    }
    _finalColors[key] = hex
  }
  _setTags(_finalColors)
}

/**
 * Reset colors.
 */
ansiHTML.reset = function () {
  _setTags(_defColors)
}

/**
 * Expose tags, including open and close.
 * @type {Object}
 */
ansiHTML.tags = {}

if (Object.defineProperty) {
  Object.defineProperty(ansiHTML.tags, 'open', {
    get: function () { return _openTags }
  })
  Object.defineProperty(ansiHTML.tags, 'close', {
    get: function () { return _closeTags }
  })
} else {
  ansiHTML.tags.open = _openTags
  ansiHTML.tags.close = _closeTags
}

function _setTags (colors) {
  // reset all
  _openTags['0'] = 'font-weight:normal;opacity:1;color:#' + colors.reset[0] + ';background:#' + colors.reset[1]
  // inverse
  _openTags['7'] = 'color:#' + colors.reset[1] + ';background:#' + colors.reset[0]
  // dark grey
  _openTags['90'] = 'color:#' + colors.darkgrey

  for (var code in _styles) {
    var color = _styles[code]
    var oriColor = colors[color] || '000'
    _openTags[code] = 'color:#' + oriColor
    code = parseInt(code)
    _openTags[(code + 10).toString()] = 'background:#' + oriColor
  }
}

ansiHTML.reset()


/***/ }),

/***/ "./node_modules/ansi-regex/index.js":
/*!******************************************!*\
  !*** ./node_modules/ansi-regex/index.js ***!
  \******************************************/
/***/ ((module) => {

"use strict";


module.exports = ({onlyFirst = false} = {}) => {
	const pattern = [
		'[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)',
		'(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))'
	].join('|');

	return new RegExp(pattern, onlyFirst ? undefined : 'g');
};


/***/ }),

/***/ "./node_modules/html-entities/dist/commonjs/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/html-entities/dist/commonjs/index.js ***!
  \***********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.encode = encode;
exports.decodeEntity = decodeEntity;
exports.decode = decode;
var named_references_js_1 = __webpack_require__(/*! ./named-references.js */ "./node_modules/html-entities/dist/commonjs/named-references.js");
var numeric_unicode_map_js_1 = __webpack_require__(/*! ./numeric-unicode-map.js */ "./node_modules/html-entities/dist/commonjs/numeric-unicode-map.js");
var surrogate_pairs_js_1 = __webpack_require__(/*! ./surrogate-pairs.js */ "./node_modules/html-entities/dist/commonjs/surrogate-pairs.js");
var allNamedReferences = __assign(__assign({}, named_references_js_1.namedReferences), { all: named_references_js_1.namedReferences.html5 });
var encodeRegExps = {
    specialChars: /[<>'"&]/g,
    nonAscii: /[<>'"&\u0080-\uD7FF\uE000-\uFFFF\uDC00-\uDFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]?/g,
    nonAsciiPrintable: /[<>'"&\x01-\x08\x11-\x15\x17-\x1F\x7f-\uD7FF\uE000-\uFFFF\uDC00-\uDFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]?/g,
    nonAsciiPrintableOnly: /[\x01-\x08\x11-\x15\x17-\x1F\x7f-\uD7FF\uE000-\uFFFF\uDC00-\uDFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]?/g,
    extensive: /[\x01-\x0c\x0e-\x1f\x21-\x2c\x2e-\x2f\x3a-\x40\x5b-\x60\x7b-\x7d\x7f-\uD7FF\uE000-\uFFFF\uDC00-\uDFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]?/g
};
var defaultEncodeOptions = {
    mode: 'specialChars',
    level: 'all',
    numeric: 'decimal'
};
/** Encodes all the necessary (specified by `level`) characters in the text */
function encode(text, _a) {
    var _b = _a === void 0 ? defaultEncodeOptions : _a, _c = _b.mode, mode = _c === void 0 ? 'specialChars' : _c, _d = _b.numeric, numeric = _d === void 0 ? 'decimal' : _d, _e = _b.level, level = _e === void 0 ? 'all' : _e;
    if (!text) {
        return '';
    }
    var encodeRegExp = encodeRegExps[mode];
    var references = allNamedReferences[level].characters;
    var isHex = numeric === 'hexadecimal';
    return String.prototype.replace.call(text, encodeRegExp, function (input) {
        var result = references[input];
        if (!result) {
            var code = input.length > 1 ? (0, surrogate_pairs_js_1.getCodePoint)(input, 0) : input.charCodeAt(0);
            result = (isHex ? '&#x' + code.toString(16) : '&#' + code) + ';';
        }
        return result;
    });
}
var defaultDecodeOptions = {
    scope: 'body',
    level: 'all'
};
var strict = /&(?:#\d+|#[xX][\da-fA-F]+|[0-9a-zA-Z]+);/g;
var attribute = /&(?:#\d+|#[xX][\da-fA-F]+|[0-9a-zA-Z]+)[;=]?/g;
var baseDecodeRegExps = {
    xml: {
        strict: strict,
        attribute: attribute,
        body: named_references_js_1.bodyRegExps.xml
    },
    html4: {
        strict: strict,
        attribute: attribute,
        body: named_references_js_1.bodyRegExps.html4
    },
    html5: {
        strict: strict,
        attribute: attribute,
        body: named_references_js_1.bodyRegExps.html5
    }
};
var decodeRegExps = __assign(__assign({}, baseDecodeRegExps), { all: baseDecodeRegExps.html5 });
var fromCharCode = String.fromCharCode;
var outOfBoundsChar = fromCharCode(65533);
var defaultDecodeEntityOptions = {
    level: 'all'
};
function getDecodedEntity(entity, references, isAttribute, isStrict) {
    var decodeResult = entity;
    var decodeEntityLastChar = entity[entity.length - 1];
    if (isAttribute && decodeEntityLastChar === '=') {
        decodeResult = entity;
    }
    else if (isStrict && decodeEntityLastChar !== ';') {
        decodeResult = entity;
    }
    else {
        var decodeResultByReference = references[entity];
        if (decodeResultByReference) {
            decodeResult = decodeResultByReference;
        }
        else if (entity[0] === '&' && entity[1] === '#') {
            var decodeSecondChar = entity[2];
            var decodeCode = decodeSecondChar == 'x' || decodeSecondChar == 'X'
                ? parseInt(entity.substr(3), 16)
                : parseInt(entity.substr(2));
            decodeResult =
                decodeCode >= 0x10ffff
                    ? outOfBoundsChar
                    : decodeCode > 65535
                        ? (0, surrogate_pairs_js_1.fromCodePoint)(decodeCode)
                        : fromCharCode(numeric_unicode_map_js_1.numericUnicodeMap[decodeCode] || decodeCode);
        }
    }
    return decodeResult;
}
/** Decodes a single entity */
function decodeEntity(entity, _a) {
    var _b = _a === void 0 ? defaultDecodeEntityOptions : _a, _c = _b.level, level = _c === void 0 ? 'all' : _c;
    if (!entity) {
        return '';
    }
    return getDecodedEntity(entity, allNamedReferences[level].entities, false, false);
}
/** Decodes all entities in the text */
function decode(text, _a) {
    var _b = _a === void 0 ? defaultDecodeOptions : _a, _c = _b.level, level = _c === void 0 ? 'all' : _c, _d = _b.scope, scope = _d === void 0 ? level === 'xml' ? 'strict' : 'body' : _d;
    if (!text) {
        return '';
    }
    var decodeRegExp = decodeRegExps[level][scope];
    var references = allNamedReferences[level].entities;
    var isAttribute = scope === 'attribute';
    var isStrict = scope === 'strict';
    return text.replace(decodeRegExp, function (entity) { return getDecodedEntity(entity, references, isAttribute, isStrict); });
}
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/html-entities/dist/commonjs/named-references.js":
/*!**********************************************************************!*\
  !*** ./node_modules/html-entities/dist/commonjs/named-references.js ***!
  \**********************************************************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";

var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.namedReferences = exports.bodyRegExps = void 0;
// This file is autogenerated by tools/process-named-references.ts
var pairDivider = "~";
var blockDivider = "~~";
function generateNamedReferences(input, prev) {
    var entities = {};
    var characters = {};
    var blocks = input.split(blockDivider);
    var isOptionalBlock = false;
    for (var i = 0; blocks.length > i; i++) {
        var entries = blocks[i].split(pairDivider);
        for (var j = 0; j < entries.length; j += 2) {
            var entity = entries[j];
            var character = entries[j + 1];
            var fullEntity = '&' + entity + ';';
            entities[fullEntity] = character;
            if (isOptionalBlock) {
                entities['&' + entity] = character;
            }
            characters[character] = fullEntity;
        }
        isOptionalBlock = true;
    }
    return prev ?
        { entities: __assign(__assign({}, entities), prev.entities), characters: __assign(__assign({}, characters), prev.characters) } :
        { entities: entities, characters: characters };
}
exports.bodyRegExps = {
    xml: /&(?:#\d+|#[xX][\da-fA-F]+|[0-9a-zA-Z]+);?/g,
    html4: /&notin;|&(?:nbsp|iexcl|cent|pound|curren|yen|brvbar|sect|uml|copy|ordf|laquo|not|shy|reg|macr|deg|plusmn|sup2|sup3|acute|micro|para|middot|cedil|sup1|ordm|raquo|frac14|frac12|frac34|iquest|Agrave|Aacute|Acirc|Atilde|Auml|Aring|AElig|Ccedil|Egrave|Eacute|Ecirc|Euml|Igrave|Iacute|Icirc|Iuml|ETH|Ntilde|Ograve|Oacute|Ocirc|Otilde|Ouml|times|Oslash|Ugrave|Uacute|Ucirc|Uuml|Yacute|THORN|szlig|agrave|aacute|acirc|atilde|auml|aring|aelig|ccedil|egrave|eacute|ecirc|euml|igrave|iacute|icirc|iuml|eth|ntilde|ograve|oacute|ocirc|otilde|ouml|divide|oslash|ugrave|uacute|ucirc|uuml|yacute|thorn|yuml|quot|amp|lt|gt|#\d+|#[xX][\da-fA-F]+|[0-9a-zA-Z]+);?/g,
    html5: /&centerdot;|&copysr;|&divideontimes;|&gtcc;|&gtcir;|&gtdot;|&gtlPar;|&gtquest;|&gtrapprox;|&gtrarr;|&gtrdot;|&gtreqless;|&gtreqqless;|&gtrless;|&gtrsim;|&ltcc;|&ltcir;|&ltdot;|&lthree;|&ltimes;|&ltlarr;|&ltquest;|&ltrPar;|&ltri;|&ltrie;|&ltrif;|&notin;|&notinE;|&notindot;|&notinva;|&notinvb;|&notinvc;|&notni;|&notniva;|&notnivb;|&notnivc;|&parallel;|&timesb;|&timesbar;|&timesd;|&(?:AElig|AMP|Aacute|Acirc|Agrave|Aring|Atilde|Auml|COPY|Ccedil|ETH|Eacute|Ecirc|Egrave|Euml|GT|Iacute|Icirc|Igrave|Iuml|LT|Ntilde|Oacute|Ocirc|Ograve|Oslash|Otilde|Ouml|QUOT|REG|THORN|Uacute|Ucirc|Ugrave|Uuml|Yacute|aacute|acirc|acute|aelig|agrave|amp|aring|atilde|auml|brvbar|ccedil|cedil|cent|copy|curren|deg|divide|eacute|ecirc|egrave|eth|euml|frac12|frac14|frac34|gt|iacute|icirc|iexcl|igrave|iquest|iuml|laquo|lt|macr|micro|middot|nbsp|not|ntilde|oacute|ocirc|ograve|ordf|ordm|oslash|otilde|ouml|para|plusmn|pound|quot|raquo|reg|sect|shy|sup1|sup2|sup3|szlig|thorn|times|uacute|ucirc|ugrave|uml|uuml|yacute|yen|yuml|#\d+|#[xX][\da-fA-F]+|[0-9a-zA-Z]+);?/g
};
exports.namedReferences = {};
exports.namedReferences.xml = generateNamedReferences("lt~<~gt~>~quot~\"~apos~'~amp~&");
exports.namedReferences.html4 = generateNamedReferences("apos~'~OElig~Å’~oelig~Å“~Scaron~Å ~scaron~Å¡~Yuml~Å¸~circ~Ë†~tilde~Ëœ~ensp~â€‚~emsp~â€ƒ~thinsp~â€‰~zwnj~â€Œ~zwj~â€~lrm~â€~rlm~â€~ndash~â€“~mdash~â€”~lsquo~â€˜~rsquo~â€™~sbquo~â€š~ldquo~â€œ~rdquo~â€~bdquo~â€~dagger~â€ ~Dagger~â€¡~permil~â€°~lsaquo~â€¹~rsaquo~â€º~euro~â‚¬~fnof~Æ’~Alpha~Î‘~Beta~Î’~Gamma~Î“~Delta~Î”~Epsilon~Î•~Zeta~Î–~Eta~Î—~Theta~Î˜~Iota~Î™~Kappa~Îš~Lambda~Î›~Mu~Îœ~Nu~Î~Xi~Î~Omicron~ÎŸ~Pi~Î ~Rho~Î¡~Sigma~Î£~Tau~Î¤~Upsilon~Î¥~Phi~Î¦~Chi~Î§~Psi~Î¨~Omega~Î©~alpha~Î±~beta~Î²~gamma~Î³~delta~Î´~epsilon~Îµ~zeta~Î¶~eta~Î·~theta~Î¸~iota~Î¹~kappa~Îº~lambda~Î»~mu~Î¼~nu~Î½~xi~Î¾~omicron~Î¿~pi~Ï€~rho~Ï~sigmaf~Ï‚~sigma~Ïƒ~tau~Ï„~upsilon~Ï…~phi~Ï†~chi~Ï‡~psi~Ïˆ~omega~Ï‰~thetasym~Ï‘~upsih~Ï’~piv~Ï–~bull~â€¢~hellip~â€¦~prime~â€²~Prime~â€³~oline~â€¾~frasl~â„~weierp~â„˜~image~â„‘~real~â„œ~trade~â„¢~alefsym~â„µ~larr~â†~uarr~â†‘~rarr~â†’~darr~â†“~harr~â†”~crarr~â†µ~lArr~â‡~uArr~â‡‘~rArr~â‡’~dArr~â‡“~hArr~â‡”~forall~âˆ€~part~âˆ‚~exist~âˆƒ~empty~âˆ…~nabla~âˆ‡~isin~âˆˆ~notin~âˆ‰~ni~âˆ‹~prod~âˆ~sum~âˆ‘~minus~âˆ’~lowast~âˆ—~radic~âˆš~prop~âˆ~infin~âˆ~ang~âˆ ~and~âˆ§~or~âˆ¨~cap~âˆ©~cup~âˆª~int~âˆ«~there4~âˆ´~sim~âˆ¼~cong~â‰…~asymp~â‰ˆ~ne~â‰ ~equiv~â‰¡~le~â‰¤~ge~â‰¥~sub~âŠ‚~sup~âŠƒ~nsub~âŠ„~sube~âŠ†~supe~âŠ‡~oplus~âŠ•~otimes~âŠ—~perp~âŠ¥~sdot~â‹…~lceil~âŒˆ~rceil~âŒ‰~lfloor~âŒŠ~rfloor~âŒ‹~lang~âŒ©~rang~âŒª~loz~â—Š~spades~â™ ~clubs~â™£~hearts~â™¥~diams~â™¦~~nbsp~Â ~iexcl~Â¡~cent~Â¢~pound~Â£~curren~Â¤~yen~Â¥~brvbar~Â¦~sect~Â§~uml~Â¨~copy~Â©~ordf~Âª~laquo~Â«~not~Â¬~shy~Â­~reg~Â®~macr~Â¯~deg~Â°~plusmn~Â±~sup2~Â²~sup3~Â³~acute~Â´~micro~Âµ~para~Â¶~middot~Â·~cedil~Â¸~sup1~Â¹~ordm~Âº~raquo~Â»~frac14~Â¼~frac12~Â½~frac34~Â¾~iquest~Â¿~Agrave~Ã€~Aacute~Ã~Acirc~Ã‚~Atilde~Ãƒ~Auml~Ã„~Aring~Ã…~AElig~Ã†~Ccedil~Ã‡~Egrave~Ãˆ~Eacute~Ã‰~Ecirc~ÃŠ~Euml~Ã‹~Igrave~ÃŒ~Iacute~Ã~Icirc~Ã~Iuml~Ã~ETH~Ã~Ntilde~Ã‘~Ograve~Ã’~Oacute~Ã“~Ocirc~Ã”~Otilde~Ã•~Ouml~Ã–~times~Ã—~Oslash~Ã˜~Ugrave~Ã™~Uacute~Ãš~Ucirc~Ã›~Uuml~Ãœ~Yacute~Ã~THORN~Ã~szlig~ÃŸ~agrave~Ã ~aacute~Ã¡~acirc~Ã¢~atilde~Ã£~auml~Ã¤~aring~Ã¥~aelig~Ã¦~ccedil~Ã§~egrave~Ã¨~eacute~Ã©~ecirc~Ãª~euml~Ã«~igrave~Ã¬~iacute~Ã­~icirc~Ã®~iuml~Ã¯~eth~Ã°~ntilde~Ã±~ograve~Ã²~oacute~Ã³~ocirc~Ã´~otilde~Ãµ~ouml~Ã¶~divide~Ã·~oslash~Ã¸~ugrave~Ã¹~uacute~Ãº~ucirc~Ã»~uuml~Ã¼~yacute~Ã½~thorn~Ã¾~yuml~Ã¿~quot~\"~amp~&~lt~<~gt~>");
exports.namedReferences.html5 = generateNamedReferences("Abreve~Ä‚~Acy~Ğ~Afr~ğ”„~Amacr~Ä€~And~â©“~Aogon~Ä„~Aopf~ğ”¸~ApplyFunction~â¡~Ascr~ğ’œ~Assign~â‰”~Backslash~âˆ–~Barv~â«§~Barwed~âŒ†~Bcy~Ğ‘~Because~âˆµ~Bernoullis~â„¬~Bfr~ğ”…~Bopf~ğ”¹~Breve~Ë˜~Bscr~â„¬~Bumpeq~â‰~CHcy~Ğ§~Cacute~Ä†~Cap~â‹’~CapitalDifferentialD~â……~Cayleys~â„­~Ccaron~ÄŒ~Ccirc~Äˆ~Cconint~âˆ°~Cdot~ÄŠ~Cedilla~Â¸~CenterDot~Â·~Cfr~â„­~CircleDot~âŠ™~CircleMinus~âŠ–~CirclePlus~âŠ•~CircleTimes~âŠ—~ClockwiseContourIntegral~âˆ²~CloseCurlyDoubleQuote~â€~CloseCurlyQuote~â€™~Colon~âˆ·~Colone~â©´~Congruent~â‰¡~Conint~âˆ¯~ContourIntegral~âˆ®~Copf~â„‚~Coproduct~âˆ~CounterClockwiseContourIntegral~âˆ³~Cross~â¨¯~Cscr~ğ’~Cup~â‹“~CupCap~â‰~DD~â……~DDotrahd~â¤‘~DJcy~Ğ‚~DScy~Ğ…~DZcy~Ğ~Darr~â†¡~Dashv~â«¤~Dcaron~Ä~Dcy~Ğ”~Del~âˆ‡~Dfr~ğ”‡~DiacriticalAcute~Â´~DiacriticalDot~Ë™~DiacriticalDoubleAcute~Ë~DiacriticalGrave~`~DiacriticalTilde~Ëœ~Diamond~â‹„~DifferentialD~â…†~Dopf~ğ”»~Dot~Â¨~DotDot~âƒœ~DotEqual~â‰~DoubleContourIntegral~âˆ¯~DoubleDot~Â¨~DoubleDownArrow~â‡“~DoubleLeftArrow~â‡~DoubleLeftRightArrow~â‡”~DoubleLeftTee~â«¤~DoubleLongLeftArrow~âŸ¸~DoubleLongLeftRightArrow~âŸº~DoubleLongRightArrow~âŸ¹~DoubleRightArrow~â‡’~DoubleRightTee~âŠ¨~DoubleUpArrow~â‡‘~DoubleUpDownArrow~â‡•~DoubleVerticalBar~âˆ¥~DownArrow~â†“~DownArrowBar~â¤“~DownArrowUpArrow~â‡µ~DownBreve~Ì‘~DownLeftRightVector~â¥~DownLeftTeeVector~â¥~DownLeftVector~â†½~DownLeftVectorBar~â¥–~DownRightTeeVector~â¥Ÿ~DownRightVector~â‡~DownRightVectorBar~â¥—~DownTee~âŠ¤~DownTeeArrow~â†§~Downarrow~â‡“~Dscr~ğ’Ÿ~Dstrok~Ä~ENG~ÅŠ~Ecaron~Äš~Ecy~Ğ­~Edot~Ä–~Efr~ğ”ˆ~Element~âˆˆ~Emacr~Ä’~EmptySmallSquare~â—»~EmptyVerySmallSquare~â–«~Eogon~Ä˜~Eopf~ğ”¼~Equal~â©µ~EqualTilde~â‰‚~Equilibrium~â‡Œ~Escr~â„°~Esim~â©³~Exists~âˆƒ~ExponentialE~â…‡~Fcy~Ğ¤~Ffr~ğ”‰~FilledSmallSquare~â—¼~FilledVerySmallSquare~â–ª~Fopf~ğ”½~ForAll~âˆ€~Fouriertrf~â„±~Fscr~â„±~GJcy~Ğƒ~Gammad~Ïœ~Gbreve~Ä~Gcedil~Ä¢~Gcirc~Äœ~Gcy~Ğ“~Gdot~Ä ~Gfr~ğ”Š~Gg~â‹™~Gopf~ğ”¾~GreaterEqual~â‰¥~GreaterEqualLess~â‹›~GreaterFullEqual~â‰§~GreaterGreater~âª¢~GreaterLess~â‰·~GreaterSlantEqual~â©¾~GreaterTilde~â‰³~Gscr~ğ’¢~Gt~â‰«~HARDcy~Ğª~Hacek~Ë‡~Hat~^~Hcirc~Ä¤~Hfr~â„Œ~HilbertSpace~â„‹~Hopf~â„~HorizontalLine~â”€~Hscr~â„‹~Hstrok~Ä¦~HumpDownHump~â‰~HumpEqual~â‰~IEcy~Ğ•~IJlig~Ä²~IOcy~Ğ~Icy~Ğ˜~Idot~Ä°~Ifr~â„‘~Im~â„‘~Imacr~Äª~ImaginaryI~â…ˆ~Implies~â‡’~Int~âˆ¬~Integral~âˆ«~Intersection~â‹‚~InvisibleComma~â£~InvisibleTimes~â¢~Iogon~Ä®~Iopf~ğ•€~Iscr~â„~Itilde~Ä¨~Iukcy~Ğ†~Jcirc~Ä´~Jcy~Ğ™~Jfr~ğ”~Jopf~ğ•~Jscr~ğ’¥~Jsercy~Ğˆ~Jukcy~Ğ„~KHcy~Ğ¥~KJcy~ĞŒ~Kcedil~Ä¶~Kcy~Ğš~Kfr~ğ”~Kopf~ğ•‚~Kscr~ğ’¦~LJcy~Ğ‰~Lacute~Ä¹~Lang~âŸª~Laplacetrf~â„’~Larr~â†~Lcaron~Ä½~Lcedil~Ä»~Lcy~Ğ›~LeftAngleBracket~âŸ¨~LeftArrow~â†~LeftArrowBar~â‡¤~LeftArrowRightArrow~â‡†~LeftCeiling~âŒˆ~LeftDoubleBracket~âŸ¦~LeftDownTeeVector~â¥¡~LeftDownVector~â‡ƒ~LeftDownVectorBar~â¥™~LeftFloor~âŒŠ~LeftRightArrow~â†”~LeftRightVector~â¥~LeftTee~âŠ£~LeftTeeArrow~â†¤~LeftTeeVector~â¥š~LeftTriangle~âŠ²~LeftTriangleBar~â§~LeftTriangleEqual~âŠ´~LeftUpDownVector~â¥‘~LeftUpTeeVector~â¥ ~LeftUpVector~â†¿~LeftUpVectorBar~â¥˜~LeftVector~â†¼~LeftVectorBar~â¥’~Leftarrow~â‡~Leftrightarrow~â‡”~LessEqualGreater~â‹š~LessFullEqual~â‰¦~LessGreater~â‰¶~LessLess~âª¡~LessSlantEqual~â©½~LessTilde~â‰²~Lfr~ğ”~Ll~â‹˜~Lleftarrow~â‡š~Lmidot~Ä¿~LongLeftArrow~âŸµ~LongLeftRightArrow~âŸ·~LongRightArrow~âŸ¶~Longleftarrow~âŸ¸~Longleftrightarrow~âŸº~Longrightarrow~âŸ¹~Lopf~ğ•ƒ~LowerLeftArrow~â†™~LowerRightArrow~â†˜~Lscr~â„’~Lsh~â†°~Lstrok~Å~Lt~â‰ª~Map~â¤…~Mcy~Ğœ~MediumSpace~âŸ~Mellintrf~â„³~Mfr~ğ”~MinusPlus~âˆ“~Mopf~ğ•„~Mscr~â„³~NJcy~ĞŠ~Nacute~Åƒ~Ncaron~Å‡~Ncedil~Å…~Ncy~Ğ~NegativeMediumSpace~â€‹~NegativeThickSpace~â€‹~NegativeThinSpace~â€‹~NegativeVeryThinSpace~â€‹~NestedGreaterGreater~â‰«~NestedLessLess~â‰ª~NewLine~\n~Nfr~ğ”‘~NoBreak~â ~NonBreakingSpace~Â ~Nopf~â„•~Not~â«¬~NotCongruent~â‰¢~NotCupCap~â‰­~NotDoubleVerticalBar~âˆ¦~NotElement~âˆ‰~NotEqual~â‰ ~NotEqualTilde~â‰‚Ì¸~NotExists~âˆ„~NotGreater~â‰¯~NotGreaterEqual~â‰±~NotGreaterFullEqual~â‰§Ì¸~NotGreaterGreater~â‰«Ì¸~NotGreaterLess~â‰¹~NotGreaterSlantEqual~â©¾Ì¸~NotGreaterTilde~â‰µ~NotHumpDownHump~â‰Ì¸~NotHumpEqual~â‰Ì¸~NotLeftTriangle~â‹ª~NotLeftTriangleBar~â§Ì¸~NotLeftTriangleEqual~â‹¬~NotLess~â‰®~NotLessEqual~â‰°~NotLessGreater~â‰¸~NotLessLess~â‰ªÌ¸~NotLessSlantEqual~â©½Ì¸~NotLessTilde~â‰´~NotNestedGreaterGreater~âª¢Ì¸~NotNestedLessLess~âª¡Ì¸~NotPrecedes~âŠ€~NotPrecedesEqual~âª¯Ì¸~NotPrecedesSlantEqual~â‹ ~NotReverseElement~âˆŒ~NotRightTriangle~â‹«~NotRightTriangleBar~â§Ì¸~NotRightTriangleEqual~â‹­~NotSquareSubset~âŠÌ¸~NotSquareSubsetEqual~â‹¢~NotSquareSuperset~âŠÌ¸~NotSquareSupersetEqual~â‹£~NotSubset~âŠ‚âƒ’~NotSubsetEqual~âŠˆ~NotSucceeds~âŠ~NotSucceedsEqual~âª°Ì¸~NotSucceedsSlantEqual~â‹¡~NotSucceedsTilde~â‰¿Ì¸~NotSuperset~âŠƒâƒ’~NotSupersetEqual~âŠ‰~NotTilde~â‰~NotTildeEqual~â‰„~NotTildeFullEqual~â‰‡~NotTildeTilde~â‰‰~NotVerticalBar~âˆ¤~Nscr~ğ’©~Ocy~Ğ~Odblac~Å~Ofr~ğ”’~Omacr~ÅŒ~Oopf~ğ•†~OpenCurlyDoubleQuote~â€œ~OpenCurlyQuote~â€˜~Or~â©”~Oscr~ğ’ª~Otimes~â¨·~OverBar~â€¾~OverBrace~â~OverBracket~â´~OverParenthesis~âœ~PartialD~âˆ‚~Pcy~ĞŸ~Pfr~ğ”“~PlusMinus~Â±~Poincareplane~â„Œ~Popf~â„™~Pr~âª»~Precedes~â‰º~PrecedesEqual~âª¯~PrecedesSlantEqual~â‰¼~PrecedesTilde~â‰¾~Product~âˆ~Proportion~âˆ·~Proportional~âˆ~Pscr~ğ’«~Qfr~ğ””~Qopf~â„š~Qscr~ğ’¬~RBarr~â¤~Racute~Å”~Rang~âŸ«~Rarr~â† ~Rarrtl~â¤–~Rcaron~Å˜~Rcedil~Å–~Rcy~Ğ ~Re~â„œ~ReverseElement~âˆ‹~ReverseEquilibrium~â‡‹~ReverseUpEquilibrium~â¥¯~Rfr~â„œ~RightAngleBracket~âŸ©~RightArrow~â†’~RightArrowBar~â‡¥~RightArrowLeftArrow~â‡„~RightCeiling~âŒ‰~RightDoubleBracket~âŸ§~RightDownTeeVector~â¥~RightDownVector~â‡‚~RightDownVectorBar~â¥•~RightFloor~âŒ‹~RightTee~âŠ¢~RightTeeArrow~â†¦~RightTeeVector~â¥›~RightTriangle~âŠ³~RightTriangleBar~â§~RightTriangleEqual~âŠµ~RightUpDownVector~â¥~RightUpTeeVector~â¥œ~RightUpVector~â†¾~RightUpVectorBar~â¥”~RightVector~â‡€~RightVectorBar~â¥“~Rightarrow~â‡’~Ropf~â„~RoundImplies~â¥°~Rrightarrow~â‡›~Rscr~â„›~Rsh~â†±~RuleDelayed~â§´~SHCHcy~Ğ©~SHcy~Ğ¨~SOFTcy~Ğ¬~Sacute~Åš~Sc~âª¼~Scedil~Å~Scirc~Åœ~Scy~Ğ¡~Sfr~ğ”–~ShortDownArrow~â†“~ShortLeftArrow~â†~ShortRightArrow~â†’~ShortUpArrow~â†‘~SmallCircle~âˆ˜~Sopf~ğ•Š~Sqrt~âˆš~Square~â–¡~SquareIntersection~âŠ“~SquareSubset~âŠ~SquareSubsetEqual~âŠ‘~SquareSuperset~âŠ~SquareSupersetEqual~âŠ’~SquareUnion~âŠ”~Sscr~ğ’®~Star~â‹†~Sub~â‹~Subset~â‹~SubsetEqual~âŠ†~Succeeds~â‰»~SucceedsEqual~âª°~SucceedsSlantEqual~â‰½~SucceedsTilde~â‰¿~SuchThat~âˆ‹~Sum~âˆ‘~Sup~â‹‘~Superset~âŠƒ~SupersetEqual~âŠ‡~Supset~â‹‘~TRADE~â„¢~TSHcy~Ğ‹~TScy~Ğ¦~Tab~\t~Tcaron~Å¤~Tcedil~Å¢~Tcy~Ğ¢~Tfr~ğ”—~Therefore~âˆ´~ThickSpace~âŸâ€Š~ThinSpace~â€‰~Tilde~âˆ¼~TildeEqual~â‰ƒ~TildeFullEqual~â‰…~TildeTilde~â‰ˆ~Topf~ğ•‹~TripleDot~âƒ›~Tscr~ğ’¯~Tstrok~Å¦~Uarr~â†Ÿ~Uarrocir~â¥‰~Ubrcy~Ğ~Ubreve~Å¬~Ucy~Ğ£~Udblac~Å°~Ufr~ğ”˜~Umacr~Åª~UnderBar~_~UnderBrace~âŸ~UnderBracket~âµ~UnderParenthesis~â~Union~â‹ƒ~UnionPlus~âŠ~Uogon~Å²~Uopf~ğ•Œ~UpArrow~â†‘~UpArrowBar~â¤’~UpArrowDownArrow~â‡…~UpDownArrow~â†•~UpEquilibrium~â¥®~UpTee~âŠ¥~UpTeeArrow~â†¥~Uparrow~â‡‘~Updownarrow~â‡•~UpperLeftArrow~â†–~UpperRightArrow~â†—~Upsi~Ï’~Uring~Å®~Uscr~ğ’°~Utilde~Å¨~VDash~âŠ«~Vbar~â««~Vcy~Ğ’~Vdash~âŠ©~Vdashl~â«¦~Vee~â‹~Verbar~â€–~Vert~â€–~VerticalBar~âˆ£~VerticalLine~|~VerticalSeparator~â˜~VerticalTilde~â‰€~VeryThinSpace~â€Š~Vfr~ğ”™~Vopf~ğ•~Vscr~ğ’±~Vvdash~âŠª~Wcirc~Å´~Wedge~â‹€~Wfr~ğ”š~Wopf~ğ•~Wscr~ğ’²~Xfr~ğ”›~Xopf~ğ•~Xscr~ğ’³~YAcy~Ğ¯~YIcy~Ğ‡~YUcy~Ğ®~Ycirc~Å¶~Ycy~Ğ«~Yfr~ğ”œ~Yopf~ğ•~Yscr~ğ’´~ZHcy~Ğ–~Zacute~Å¹~Zcaron~Å½~Zcy~Ğ—~Zdot~Å»~ZeroWidthSpace~â€‹~Zfr~â„¨~Zopf~â„¤~Zscr~ğ’µ~abreve~Äƒ~ac~âˆ¾~acE~âˆ¾Ì³~acd~âˆ¿~acy~Ğ°~af~â¡~afr~ğ”~aleph~â„µ~amacr~Ä~amalg~â¨¿~andand~â©•~andd~â©œ~andslope~â©˜~andv~â©š~ange~â¦¤~angle~âˆ ~angmsd~âˆ¡~angmsdaa~â¦¨~angmsdab~â¦©~angmsdac~â¦ª~angmsdad~â¦«~angmsdae~â¦¬~angmsdaf~â¦­~angmsdag~â¦®~angmsdah~â¦¯~angrt~âˆŸ~angrtvb~âŠ¾~angrtvbd~â¦~angsph~âˆ¢~angst~Ã…~angzarr~â¼~aogon~Ä…~aopf~ğ•’~ap~â‰ˆ~apE~â©°~apacir~â©¯~ape~â‰Š~apid~â‰‹~approx~â‰ˆ~approxeq~â‰Š~ascr~ğ’¶~ast~*~asympeq~â‰~awconint~âˆ³~awint~â¨‘~bNot~â«­~backcong~â‰Œ~backepsilon~Ï¶~backprime~â€µ~backsim~âˆ½~backsimeq~â‹~barvee~âŠ½~barwed~âŒ…~barwedge~âŒ…~bbrk~âµ~bbrktbrk~â¶~bcong~â‰Œ~bcy~Ğ±~becaus~âˆµ~because~âˆµ~bemptyv~â¦°~bepsi~Ï¶~bernou~â„¬~beth~â„¶~between~â‰¬~bfr~ğ”Ÿ~bigcap~â‹‚~bigcirc~â—¯~bigcup~â‹ƒ~bigodot~â¨€~bigoplus~â¨~bigotimes~â¨‚~bigsqcup~â¨†~bigstar~â˜…~bigtriangledown~â–½~bigtriangleup~â–³~biguplus~â¨„~bigvee~â‹~bigwedge~â‹€~bkarow~â¤~blacklozenge~â§«~blacksquare~â–ª~blacktriangle~â–´~blacktriangledown~â–¾~blacktriangleleft~â—‚~blacktriangleright~â–¸~blank~â£~blk12~â–’~blk14~â–‘~blk34~â–“~block~â–ˆ~bne~=âƒ¥~bnequiv~â‰¡âƒ¥~bnot~âŒ~bopf~ğ•“~bot~âŠ¥~bottom~âŠ¥~bowtie~â‹ˆ~boxDL~â•—~boxDR~â•”~boxDl~â•–~boxDr~â•“~boxH~â•~boxHD~â•¦~boxHU~â•©~boxHd~â•¤~boxHu~â•§~boxUL~â•~boxUR~â•š~boxUl~â•œ~boxUr~â•™~boxV~â•‘~boxVH~â•¬~boxVL~â•£~boxVR~â• ~boxVh~â•«~boxVl~â•¢~boxVr~â•Ÿ~boxbox~â§‰~boxdL~â••~boxdR~â•’~boxdl~â”~boxdr~â”Œ~boxh~â”€~boxhD~â•¥~boxhU~â•¨~boxhd~â”¬~boxhu~â”´~boxminus~âŠŸ~boxplus~âŠ~boxtimes~âŠ ~boxuL~â•›~boxuR~â•˜~boxul~â”˜~boxur~â””~boxv~â”‚~boxvH~â•ª~boxvL~â•¡~boxvR~â•~boxvh~â”¼~boxvl~â”¤~boxvr~â”œ~bprime~â€µ~breve~Ë˜~bscr~ğ’·~bsemi~â~bsim~âˆ½~bsime~â‹~bsol~\\~bsolb~â§…~bsolhsub~âŸˆ~bullet~â€¢~bump~â‰~bumpE~âª®~bumpe~â‰~bumpeq~â‰~cacute~Ä‡~capand~â©„~capbrcup~â©‰~capcap~â©‹~capcup~â©‡~capdot~â©€~caps~âˆ©ï¸€~caret~â~caron~Ë‡~ccaps~â©~ccaron~Ä~ccirc~Ä‰~ccups~â©Œ~ccupssm~â©~cdot~Ä‹~cemptyv~â¦²~centerdot~Â·~cfr~ğ” ~chcy~Ñ‡~check~âœ“~checkmark~âœ“~cir~â—‹~cirE~â§ƒ~circeq~â‰—~circlearrowleft~â†º~circlearrowright~â†»~circledR~Â®~circledS~â“ˆ~circledast~âŠ›~circledcirc~âŠš~circleddash~âŠ~cire~â‰—~cirfnint~â¨~cirmid~â«¯~cirscir~â§‚~clubsuit~â™£~colon~:~colone~â‰”~coloneq~â‰”~comma~,~commat~@~comp~âˆ~compfn~âˆ˜~complement~âˆ~complexes~â„‚~congdot~â©­~conint~âˆ®~copf~ğ•”~coprod~âˆ~copysr~â„—~cross~âœ—~cscr~ğ’¸~csub~â«~csube~â«‘~csup~â«~csupe~â«’~ctdot~â‹¯~cudarrl~â¤¸~cudarrr~â¤µ~cuepr~â‹~cuesc~â‹Ÿ~cularr~â†¶~cularrp~â¤½~cupbrcap~â©ˆ~cupcap~â©†~cupcup~â©Š~cupdot~âŠ~cupor~â©…~cups~âˆªï¸€~curarr~â†·~curarrm~â¤¼~curlyeqprec~â‹~curlyeqsucc~â‹Ÿ~curlyvee~â‹~curlywedge~â‹~curvearrowleft~â†¶~curvearrowright~â†·~cuvee~â‹~cuwed~â‹~cwconint~âˆ²~cwint~âˆ±~cylcty~âŒ­~dHar~â¥¥~daleth~â„¸~dash~â€~dashv~âŠ£~dbkarow~â¤~dblac~Ë~dcaron~Ä~dcy~Ğ´~dd~â…†~ddagger~â€¡~ddarr~â‡Š~ddotseq~â©·~demptyv~â¦±~dfisht~â¥¿~dfr~ğ”¡~dharl~â‡ƒ~dharr~â‡‚~diam~â‹„~diamond~â‹„~diamondsuit~â™¦~die~Â¨~digamma~Ï~disin~â‹²~div~Ã·~divideontimes~â‹‡~divonx~â‹‡~djcy~Ñ’~dlcorn~âŒ~dlcrop~âŒ~dollar~$~dopf~ğ••~dot~Ë™~doteq~â‰~doteqdot~â‰‘~dotminus~âˆ¸~dotplus~âˆ”~dotsquare~âŠ¡~doublebarwedge~âŒ†~downarrow~â†“~downdownarrows~â‡Š~downharpoonleft~â‡ƒ~downharpoonright~â‡‚~drbkarow~â¤~drcorn~âŒŸ~drcrop~âŒŒ~dscr~ğ’¹~dscy~Ñ•~dsol~â§¶~dstrok~Ä‘~dtdot~â‹±~dtri~â–¿~dtrif~â–¾~duarr~â‡µ~duhar~â¥¯~dwangle~â¦¦~dzcy~ÑŸ~dzigrarr~âŸ¿~eDDot~â©·~eDot~â‰‘~easter~â©®~ecaron~Ä›~ecir~â‰–~ecolon~â‰•~ecy~Ñ~edot~Ä—~ee~â…‡~efDot~â‰’~efr~ğ”¢~eg~âªš~egs~âª–~egsdot~âª˜~el~âª™~elinters~â§~ell~â„“~els~âª•~elsdot~âª—~emacr~Ä“~emptyset~âˆ…~emptyv~âˆ…~emsp13~â€„~emsp14~â€…~eng~Å‹~eogon~Ä™~eopf~ğ•–~epar~â‹•~eparsl~â§£~eplus~â©±~epsi~Îµ~epsiv~Ïµ~eqcirc~â‰–~eqcolon~â‰•~eqsim~â‰‚~eqslantgtr~âª–~eqslantless~âª•~equals~=~equest~â‰Ÿ~equivDD~â©¸~eqvparsl~â§¥~erDot~â‰“~erarr~â¥±~escr~â„¯~esdot~â‰~esim~â‰‚~excl~!~expectation~â„°~exponentiale~â…‡~fallingdotseq~â‰’~fcy~Ñ„~female~â™€~ffilig~ï¬ƒ~fflig~ï¬€~ffllig~ï¬„~ffr~ğ”£~filig~ï¬~fjlig~fj~flat~â™­~fllig~ï¬‚~fltns~â–±~fopf~ğ•—~fork~â‹”~forkv~â«™~fpartint~â¨~frac13~â…“~frac15~â…•~frac16~â…™~frac18~â…›~frac23~â…”~frac25~â…–~frac35~â…—~frac38~â…œ~frac45~â…˜~frac56~â…š~frac58~â…~frac78~â…~frown~âŒ¢~fscr~ğ’»~gE~â‰§~gEl~âªŒ~gacute~Çµ~gammad~Ï~gap~âª†~gbreve~ÄŸ~gcirc~Ä~gcy~Ğ³~gdot~Ä¡~gel~â‹›~geq~â‰¥~geqq~â‰§~geqslant~â©¾~ges~â©¾~gescc~âª©~gesdot~âª€~gesdoto~âª‚~gesdotol~âª„~gesl~â‹›ï¸€~gesles~âª”~gfr~ğ”¤~gg~â‰«~ggg~â‹™~gimel~â„·~gjcy~Ñ“~gl~â‰·~glE~âª’~gla~âª¥~glj~âª¤~gnE~â‰©~gnap~âªŠ~gnapprox~âªŠ~gne~âªˆ~gneq~âªˆ~gneqq~â‰©~gnsim~â‹§~gopf~ğ•˜~grave~`~gscr~â„Š~gsim~â‰³~gsime~âª~gsiml~âª~gtcc~âª§~gtcir~â©º~gtdot~â‹—~gtlPar~â¦•~gtquest~â©¼~gtrapprox~âª†~gtrarr~â¥¸~gtrdot~â‹—~gtreqless~â‹›~gtreqqless~âªŒ~gtrless~â‰·~gtrsim~â‰³~gvertneqq~â‰©ï¸€~gvnE~â‰©ï¸€~hairsp~â€Š~half~Â½~hamilt~â„‹~hardcy~ÑŠ~harrcir~â¥ˆ~harrw~â†­~hbar~â„~hcirc~Ä¥~heartsuit~â™¥~hercon~âŠ¹~hfr~ğ”¥~hksearow~â¤¥~hkswarow~â¤¦~hoarr~â‡¿~homtht~âˆ»~hookleftarrow~â†©~hookrightarrow~â†ª~hopf~ğ•™~horbar~â€•~hscr~ğ’½~hslash~â„~hstrok~Ä§~hybull~âƒ~hyphen~â€~ic~â£~icy~Ğ¸~iecy~Ğµ~iff~â‡”~ifr~ğ”¦~ii~â…ˆ~iiiint~â¨Œ~iiint~âˆ­~iinfin~â§œ~iiota~â„©~ijlig~Ä³~imacr~Ä«~imagline~â„~imagpart~â„‘~imath~Ä±~imof~âŠ·~imped~Æµ~in~âˆˆ~incare~â„…~infintie~â§~inodot~Ä±~intcal~âŠº~integers~â„¤~intercal~âŠº~intlarhk~â¨—~intprod~â¨¼~iocy~Ñ‘~iogon~Ä¯~iopf~ğ•š~iprod~â¨¼~iscr~ğ’¾~isinE~â‹¹~isindot~â‹µ~isins~â‹´~isinsv~â‹³~isinv~âˆˆ~it~â¢~itilde~Ä©~iukcy~Ñ–~jcirc~Äµ~jcy~Ğ¹~jfr~ğ”§~jmath~È·~jopf~ğ•›~jscr~ğ’¿~jsercy~Ñ˜~jukcy~Ñ”~kappav~Ï°~kcedil~Ä·~kcy~Ğº~kfr~ğ”¨~kgreen~Ä¸~khcy~Ñ…~kjcy~Ñœ~kopf~ğ•œ~kscr~ğ“€~lAarr~â‡š~lAtail~â¤›~lBarr~â¤~lE~â‰¦~lEg~âª‹~lHar~â¥¢~lacute~Äº~laemptyv~â¦´~lagran~â„’~langd~â¦‘~langle~âŸ¨~lap~âª…~larrb~â‡¤~larrbfs~â¤Ÿ~larrfs~â¤~larrhk~â†©~larrlp~â†«~larrpl~â¤¹~larrsim~â¥³~larrtl~â†¢~lat~âª«~latail~â¤™~late~âª­~lates~âª­ï¸€~lbarr~â¤Œ~lbbrk~â²~lbrace~{~lbrack~[~lbrke~â¦‹~lbrksld~â¦~lbrkslu~â¦~lcaron~Ä¾~lcedil~Ä¼~lcub~{~lcy~Ğ»~ldca~â¤¶~ldquor~â€~ldrdhar~â¥§~ldrushar~â¥‹~ldsh~â†²~leftarrow~â†~leftarrowtail~â†¢~leftharpoondown~â†½~leftharpoonup~â†¼~leftleftarrows~â‡‡~leftrightarrow~â†”~leftrightarrows~â‡†~leftrightharpoons~â‡‹~leftrightsquigarrow~â†­~leftthreetimes~â‹‹~leg~â‹š~leq~â‰¤~leqq~â‰¦~leqslant~â©½~les~â©½~lescc~âª¨~lesdot~â©¿~lesdoto~âª~lesdotor~âªƒ~lesg~â‹šï¸€~lesges~âª“~lessapprox~âª…~lessdot~â‹–~lesseqgtr~â‹š~lesseqqgtr~âª‹~lessgtr~â‰¶~lesssim~â‰²~lfisht~â¥¼~lfr~ğ”©~lg~â‰¶~lgE~âª‘~lhard~â†½~lharu~â†¼~lharul~â¥ª~lhblk~â–„~ljcy~Ñ™~ll~â‰ª~llarr~â‡‡~llcorner~âŒ~llhard~â¥«~lltri~â—º~lmidot~Å€~lmoust~â°~lmoustache~â°~lnE~â‰¨~lnap~âª‰~lnapprox~âª‰~lne~âª‡~lneq~âª‡~lneqq~â‰¨~lnsim~â‹¦~loang~âŸ¬~loarr~â‡½~lobrk~âŸ¦~longleftarrow~âŸµ~longleftrightarrow~âŸ·~longmapsto~âŸ¼~longrightarrow~âŸ¶~looparrowleft~â†«~looparrowright~â†¬~lopar~â¦…~lopf~ğ•~loplus~â¨­~lotimes~â¨´~lowbar~_~lozenge~â—Š~lozf~â§«~lpar~(~lparlt~â¦“~lrarr~â‡†~lrcorner~âŒŸ~lrhar~â‡‹~lrhard~â¥­~lrtri~âŠ¿~lscr~ğ“~lsh~â†°~lsim~â‰²~lsime~âª~lsimg~âª~lsqb~[~lsquor~â€š~lstrok~Å‚~ltcc~âª¦~ltcir~â©¹~ltdot~â‹–~lthree~â‹‹~ltimes~â‹‰~ltlarr~â¥¶~ltquest~â©»~ltrPar~â¦–~ltri~â—ƒ~ltrie~âŠ´~ltrif~â—‚~lurdshar~â¥Š~luruhar~â¥¦~lvertneqq~â‰¨ï¸€~lvnE~â‰¨ï¸€~mDDot~âˆº~male~â™‚~malt~âœ ~maltese~âœ ~map~â†¦~mapsto~â†¦~mapstodown~â†§~mapstoleft~â†¤~mapstoup~â†¥~marker~â–®~mcomma~â¨©~mcy~Ğ¼~measuredangle~âˆ¡~mfr~ğ”ª~mho~â„§~mid~âˆ£~midast~*~midcir~â«°~minusb~âŠŸ~minusd~âˆ¸~minusdu~â¨ª~mlcp~â«›~mldr~â€¦~mnplus~âˆ“~models~âŠ§~mopf~ğ•~mp~âˆ“~mscr~ğ“‚~mstpos~âˆ¾~multimap~âŠ¸~mumap~âŠ¸~nGg~â‹™Ì¸~nGt~â‰«âƒ’~nGtv~â‰«Ì¸~nLeftarrow~â‡~nLeftrightarrow~â‡~nLl~â‹˜Ì¸~nLt~â‰ªâƒ’~nLtv~â‰ªÌ¸~nRightarrow~â‡~nVDash~âŠ¯~nVdash~âŠ®~nacute~Å„~nang~âˆ âƒ’~nap~â‰‰~napE~â©°Ì¸~napid~â‰‹Ì¸~napos~Å‰~napprox~â‰‰~natur~â™®~natural~â™®~naturals~â„•~nbump~â‰Ì¸~nbumpe~â‰Ì¸~ncap~â©ƒ~ncaron~Åˆ~ncedil~Å†~ncong~â‰‡~ncongdot~â©­Ì¸~ncup~â©‚~ncy~Ğ½~neArr~â‡—~nearhk~â¤¤~nearr~â†—~nearrow~â†—~nedot~â‰Ì¸~nequiv~â‰¢~nesear~â¤¨~nesim~â‰‚Ì¸~nexist~âˆ„~nexists~âˆ„~nfr~ğ”«~ngE~â‰§Ì¸~nge~â‰±~ngeq~â‰±~ngeqq~â‰§Ì¸~ngeqslant~â©¾Ì¸~nges~â©¾Ì¸~ngsim~â‰µ~ngt~â‰¯~ngtr~â‰¯~nhArr~â‡~nharr~â†®~nhpar~â«²~nis~â‹¼~nisd~â‹º~niv~âˆ‹~njcy~Ñš~nlArr~â‡~nlE~â‰¦Ì¸~nlarr~â†š~nldr~â€¥~nle~â‰°~nleftarrow~â†š~nleftrightarrow~â†®~nleq~â‰°~nleqq~â‰¦Ì¸~nleqslant~â©½Ì¸~nles~â©½Ì¸~nless~â‰®~nlsim~â‰´~nlt~â‰®~nltri~â‹ª~nltrie~â‹¬~nmid~âˆ¤~nopf~ğ•Ÿ~notinE~â‹¹Ì¸~notindot~â‹µÌ¸~notinva~âˆ‰~notinvb~â‹·~notinvc~â‹¶~notni~âˆŒ~notniva~âˆŒ~notnivb~â‹¾~notnivc~â‹½~npar~âˆ¦~nparallel~âˆ¦~nparsl~â«½âƒ¥~npart~âˆ‚Ì¸~npolint~â¨”~npr~âŠ€~nprcue~â‹ ~npre~âª¯Ì¸~nprec~âŠ€~npreceq~âª¯Ì¸~nrArr~â‡~nrarr~â†›~nrarrc~â¤³Ì¸~nrarrw~â†Ì¸~nrightarrow~â†›~nrtri~â‹«~nrtrie~â‹­~nsc~âŠ~nsccue~â‹¡~nsce~âª°Ì¸~nscr~ğ“ƒ~nshortmid~âˆ¤~nshortparallel~âˆ¦~nsim~â‰~nsime~â‰„~nsimeq~â‰„~nsmid~âˆ¤~nspar~âˆ¦~nsqsube~â‹¢~nsqsupe~â‹£~nsubE~â«…Ì¸~nsube~âŠˆ~nsubset~âŠ‚âƒ’~nsubseteq~âŠˆ~nsubseteqq~â«…Ì¸~nsucc~âŠ~nsucceq~âª°Ì¸~nsup~âŠ…~nsupE~â«†Ì¸~nsupe~âŠ‰~nsupset~âŠƒâƒ’~nsupseteq~âŠ‰~nsupseteqq~â«†Ì¸~ntgl~â‰¹~ntlg~â‰¸~ntriangleleft~â‹ª~ntrianglelefteq~â‹¬~ntriangleright~â‹«~ntrianglerighteq~â‹­~num~#~numero~â„–~numsp~â€‡~nvDash~âŠ­~nvHarr~â¤„~nvap~â‰âƒ’~nvdash~âŠ¬~nvge~â‰¥âƒ’~nvgt~>âƒ’~nvinfin~â§~nvlArr~â¤‚~nvle~â‰¤âƒ’~nvlt~<âƒ’~nvltrie~âŠ´âƒ’~nvrArr~â¤ƒ~nvrtrie~âŠµâƒ’~nvsim~âˆ¼âƒ’~nwArr~â‡–~nwarhk~â¤£~nwarr~â†–~nwarrow~â†–~nwnear~â¤§~oS~â“ˆ~oast~âŠ›~ocir~âŠš~ocy~Ğ¾~odash~âŠ~odblac~Å‘~odiv~â¨¸~odot~âŠ™~odsold~â¦¼~ofcir~â¦¿~ofr~ğ”¬~ogon~Ë›~ogt~â§~ohbar~â¦µ~ohm~Î©~oint~âˆ®~olarr~â†º~olcir~â¦¾~olcross~â¦»~olt~â§€~omacr~Å~omid~â¦¶~ominus~âŠ–~oopf~ğ• ~opar~â¦·~operp~â¦¹~orarr~â†»~ord~â©~order~â„´~orderof~â„´~origof~âŠ¶~oror~â©–~orslope~â©—~orv~â©›~oscr~â„´~osol~âŠ˜~otimesas~â¨¶~ovbar~âŒ½~par~âˆ¥~parallel~âˆ¥~parsim~â«³~parsl~â«½~pcy~Ğ¿~percnt~%~period~.~pertenk~â€±~pfr~ğ”­~phiv~Ï•~phmmat~â„³~phone~â˜~pitchfork~â‹”~planck~â„~planckh~â„~plankv~â„~plus~+~plusacir~â¨£~plusb~âŠ~pluscir~â¨¢~plusdo~âˆ”~plusdu~â¨¥~pluse~â©²~plussim~â¨¦~plustwo~â¨§~pm~Â±~pointint~â¨•~popf~ğ•¡~pr~â‰º~prE~âª³~prap~âª·~prcue~â‰¼~pre~âª¯~prec~â‰º~precapprox~âª·~preccurlyeq~â‰¼~preceq~âª¯~precnapprox~âª¹~precneqq~âªµ~precnsim~â‹¨~precsim~â‰¾~primes~â„™~prnE~âªµ~prnap~âª¹~prnsim~â‹¨~profalar~âŒ®~profline~âŒ’~profsurf~âŒ“~propto~âˆ~prsim~â‰¾~prurel~âŠ°~pscr~ğ“…~puncsp~â€ˆ~qfr~ğ”®~qint~â¨Œ~qopf~ğ•¢~qprime~â—~qscr~ğ“†~quaternions~â„~quatint~â¨–~quest~?~questeq~â‰Ÿ~rAarr~â‡›~rAtail~â¤œ~rBarr~â¤~rHar~â¥¤~race~âˆ½Ì±~racute~Å•~raemptyv~â¦³~rangd~â¦’~range~â¦¥~rangle~âŸ©~rarrap~â¥µ~rarrb~â‡¥~rarrbfs~â¤ ~rarrc~â¤³~rarrfs~â¤~rarrhk~â†ª~rarrlp~â†¬~rarrpl~â¥…~rarrsim~â¥´~rarrtl~â†£~rarrw~â†~ratail~â¤š~ratio~âˆ¶~rationals~â„š~rbarr~â¤~rbbrk~â³~rbrace~}~rbrack~]~rbrke~â¦Œ~rbrksld~â¦~rbrkslu~â¦~rcaron~Å™~rcedil~Å—~rcub~}~rcy~Ñ€~rdca~â¤·~rdldhar~â¥©~rdquor~â€~rdsh~â†³~realine~â„›~realpart~â„œ~reals~â„~rect~â–­~rfisht~â¥½~rfr~ğ”¯~rhard~â‡~rharu~â‡€~rharul~â¥¬~rhov~Ï±~rightarrow~â†’~rightarrowtail~â†£~rightharpoondown~â‡~rightharpoonup~â‡€~rightleftarrows~â‡„~rightleftharpoons~â‡Œ~rightrightarrows~â‡‰~rightsquigarrow~â†~rightthreetimes~â‹Œ~ring~Ëš~risingdotseq~â‰“~rlarr~â‡„~rlhar~â‡Œ~rmoust~â±~rmoustache~â±~rnmid~â«®~roang~âŸ­~roarr~â‡¾~robrk~âŸ§~ropar~â¦†~ropf~ğ•£~roplus~â¨®~rotimes~â¨µ~rpar~)~rpargt~â¦”~rppolint~â¨’~rrarr~â‡‰~rscr~ğ“‡~rsh~â†±~rsqb~]~rsquor~â€™~rthree~â‹Œ~rtimes~â‹Š~rtri~â–¹~rtrie~âŠµ~rtrif~â–¸~rtriltri~â§~ruluhar~â¥¨~rx~â„~sacute~Å›~sc~â‰»~scE~âª´~scap~âª¸~sccue~â‰½~sce~âª°~scedil~ÅŸ~scirc~Å~scnE~âª¶~scnap~âªº~scnsim~â‹©~scpolint~â¨“~scsim~â‰¿~scy~Ñ~sdotb~âŠ¡~sdote~â©¦~seArr~â‡˜~searhk~â¤¥~searr~â†˜~searrow~â†˜~semi~;~seswar~â¤©~setminus~âˆ–~setmn~âˆ–~sext~âœ¶~sfr~ğ”°~sfrown~âŒ¢~sharp~â™¯~shchcy~Ñ‰~shcy~Ñˆ~shortmid~âˆ£~shortparallel~âˆ¥~sigmav~Ï‚~simdot~â©ª~sime~â‰ƒ~simeq~â‰ƒ~simg~âª~simgE~âª ~siml~âª~simlE~âªŸ~simne~â‰†~simplus~â¨¤~simrarr~â¥²~slarr~â†~smallsetminus~âˆ–~smashp~â¨³~smeparsl~â§¤~smid~âˆ£~smile~âŒ£~smt~âªª~smte~âª¬~smtes~âª¬ï¸€~softcy~ÑŒ~sol~/~solb~â§„~solbar~âŒ¿~sopf~ğ•¤~spadesuit~â™ ~spar~âˆ¥~sqcap~âŠ“~sqcaps~âŠ“ï¸€~sqcup~âŠ”~sqcups~âŠ”ï¸€~sqsub~âŠ~sqsube~âŠ‘~sqsubset~âŠ~sqsubseteq~âŠ‘~sqsup~âŠ~sqsupe~âŠ’~sqsupset~âŠ~sqsupseteq~âŠ’~squ~â–¡~square~â–¡~squarf~â–ª~squf~â–ª~srarr~â†’~sscr~ğ“ˆ~ssetmn~âˆ–~ssmile~âŒ£~sstarf~â‹†~star~â˜†~starf~â˜…~straightepsilon~Ïµ~straightphi~Ï•~strns~Â¯~subE~â«…~subdot~âª½~subedot~â«ƒ~submult~â«~subnE~â«‹~subne~âŠŠ~subplus~âª¿~subrarr~â¥¹~subset~âŠ‚~subseteq~âŠ†~subseteqq~â«…~subsetneq~âŠŠ~subsetneqq~â«‹~subsim~â«‡~subsub~â«•~subsup~â«“~succ~â‰»~succapprox~âª¸~succcurlyeq~â‰½~succeq~âª°~succnapprox~âªº~succneqq~âª¶~succnsim~â‹©~succsim~â‰¿~sung~â™ª~supE~â«†~supdot~âª¾~supdsub~â«˜~supedot~â«„~suphsol~âŸ‰~suphsub~â«—~suplarr~â¥»~supmult~â«‚~supnE~â«Œ~supne~âŠ‹~supplus~â«€~supset~âŠƒ~supseteq~âŠ‡~supseteqq~â«†~supsetneq~âŠ‹~supsetneqq~â«Œ~supsim~â«ˆ~supsub~â«”~supsup~â«–~swArr~â‡™~swarhk~â¤¦~swarr~â†™~swarrow~â†™~swnwar~â¤ª~target~âŒ–~tbrk~â´~tcaron~Å¥~tcedil~Å£~tcy~Ñ‚~tdot~âƒ›~telrec~âŒ•~tfr~ğ”±~therefore~âˆ´~thetav~Ï‘~thickapprox~â‰ˆ~thicksim~âˆ¼~thkap~â‰ˆ~thksim~âˆ¼~timesb~âŠ ~timesbar~â¨±~timesd~â¨°~tint~âˆ­~toea~â¤¨~top~âŠ¤~topbot~âŒ¶~topcir~â«±~topf~ğ•¥~topfork~â«š~tosa~â¤©~tprime~â€´~triangle~â–µ~triangledown~â–¿~triangleleft~â—ƒ~trianglelefteq~âŠ´~triangleq~â‰œ~triangleright~â–¹~trianglerighteq~âŠµ~tridot~â—¬~trie~â‰œ~triminus~â¨º~triplus~â¨¹~trisb~â§~tritime~â¨»~trpezium~â¢~tscr~ğ“‰~tscy~Ñ†~tshcy~Ñ›~tstrok~Å§~twixt~â‰¬~twoheadleftarrow~â†~twoheadrightarrow~â† ~uHar~â¥£~ubrcy~Ñ~ubreve~Å­~ucy~Ñƒ~udarr~â‡…~udblac~Å±~udhar~â¥®~ufisht~â¥¾~ufr~ğ”²~uharl~â†¿~uharr~â†¾~uhblk~â–€~ulcorn~âŒœ~ulcorner~âŒœ~ulcrop~âŒ~ultri~â—¸~umacr~Å«~uogon~Å³~uopf~ğ•¦~uparrow~â†‘~updownarrow~â†•~upharpoonleft~â†¿~upharpoonright~â†¾~uplus~âŠ~upsi~Ï…~upuparrows~â‡ˆ~urcorn~âŒ~urcorner~âŒ~urcrop~âŒ~uring~Å¯~urtri~â—¹~uscr~ğ“Š~utdot~â‹°~utilde~Å©~utri~â–µ~utrif~â–´~uuarr~â‡ˆ~uwangle~â¦§~vArr~â‡•~vBar~â«¨~vBarv~â«©~vDash~âŠ¨~vangrt~â¦œ~varepsilon~Ïµ~varkappa~Ï°~varnothing~âˆ…~varphi~Ï•~varpi~Ï–~varpropto~âˆ~varr~â†•~varrho~Ï±~varsigma~Ï‚~varsubsetneq~âŠŠï¸€~varsubsetneqq~â«‹ï¸€~varsupsetneq~âŠ‹ï¸€~varsupsetneqq~â«Œï¸€~vartheta~Ï‘~vartriangleleft~âŠ²~vartriangleright~âŠ³~vcy~Ğ²~vdash~âŠ¢~vee~âˆ¨~veebar~âŠ»~veeeq~â‰š~vellip~â‹®~verbar~|~vert~|~vfr~ğ”³~vltri~âŠ²~vnsub~âŠ‚âƒ’~vnsup~âŠƒâƒ’~vopf~ğ•§~vprop~âˆ~vrtri~âŠ³~vscr~ğ“‹~vsubnE~â«‹ï¸€~vsubne~âŠŠï¸€~vsupnE~â«Œï¸€~vsupne~âŠ‹ï¸€~vzigzag~â¦š~wcirc~Åµ~wedbar~â©Ÿ~wedge~âˆ§~wedgeq~â‰™~wfr~ğ”´~wopf~ğ•¨~wp~â„˜~wr~â‰€~wreath~â‰€~wscr~ğ“Œ~xcap~â‹‚~xcirc~â—¯~xcup~â‹ƒ~xdtri~â–½~xfr~ğ”µ~xhArr~âŸº~xharr~âŸ·~xlArr~âŸ¸~xlarr~âŸµ~xmap~âŸ¼~xnis~â‹»~xodot~â¨€~xopf~ğ•©~xoplus~â¨~xotime~â¨‚~xrArr~âŸ¹~xrarr~âŸ¶~xscr~ğ“~xsqcup~â¨†~xuplus~â¨„~xutri~â–³~xvee~â‹~xwedge~â‹€~yacy~Ñ~ycirc~Å·~ycy~Ñ‹~yfr~ğ”¶~yicy~Ñ—~yopf~ğ•ª~yscr~ğ“~yucy~Ñ~zacute~Åº~zcaron~Å¾~zcy~Ğ·~zdot~Å¼~zeetrf~â„¨~zfr~ğ”·~zhcy~Ğ¶~zigrarr~â‡~zopf~ğ•«~zscr~ğ“~~AMP~&~COPY~Â©~GT~>~LT~<~QUOT~\"~REG~Â®", exports.namedReferences['html4']);
//# sourceMappingURL=named-references.js.map

/***/ }),

/***/ "./node_modules/html-entities/dist/commonjs/numeric-unicode-map.js":
/*!*************************************************************************!*\
  !*** ./node_modules/html-entities/dist/commonjs/numeric-unicode-map.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.numericUnicodeMap = void 0;
exports.numericUnicodeMap = {
    0: 65533,
    128: 8364,
    130: 8218,
    131: 402,
    132: 8222,
    133: 8230,
    134: 8224,
    135: 8225,
    136: 710,
    137: 8240,
    138: 352,
    139: 8249,
    140: 338,
    142: 381,
    145: 8216,
    146: 8217,
    147: 8220,
    148: 8221,
    149: 8226,
    150: 8211,
    151: 8212,
    152: 732,
    153: 8482,
    154: 353,
    155: 8250,
    156: 339,
    158: 382,
    159: 376
};
//# sourceMappingURL=numeric-unicode-map.js.map

/***/ }),

/***/ "./node_modules/html-entities/dist/commonjs/surrogate-pairs.js":
/*!*********************************************************************!*\
  !*** ./node_modules/html-entities/dist/commonjs/surrogate-pairs.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.highSurrogateTo = exports.highSurrogateFrom = exports.getCodePoint = exports.fromCodePoint = void 0;
exports.fromCodePoint = String.fromCodePoint ||
    function (astralCodePoint) {
        return String.fromCharCode(Math.floor((astralCodePoint - 0x10000) / 0x400) + 0xd800, ((astralCodePoint - 0x10000) % 0x400) + 0xdc00);
    };
// @ts-expect-error - String.prototype.codePointAt might not exist in older node versions
exports.getCodePoint = String.prototype.codePointAt
    ? function (input, position) {
        return input.codePointAt(position);
    }
    : function (input, position) {
        return (input.charCodeAt(position) - 0xd800) * 0x400 + input.charCodeAt(position + 1) - 0xdc00 + 0x10000;
    };
exports.highSurrogateFrom = 0xd800;
exports.highSurrogateTo = 0xdbff;
//# sourceMappingURL=surrogate-pairs.js.map

/***/ }),

/***/ "./node_modules/jsdoc-type-pratt-parser/dist/index.js":
/*!************************************************************!*\
  !*** ./node_modules/jsdoc-type-pratt-parser/dist/index.js ***!
  \************************************************************/
/***/ (function(__unused_webpack_module, exports) {

(function (global, factory) {
     true ? factory(exports) :
    0;
})(this, (function (exports) { 'use strict';

    function tokenToString(token) {
        if (token.text !== undefined && token.text !== '') {
            return `'${token.type}' with value '${token.text}'`;
        }
        else {
            return `'${token.type}'`;
        }
    }
    class NoParsletFoundError extends Error {
        constructor(token) {
            super(`No parslet found for token: ${tokenToString(token)}`);
            this.token = token;
            Object.setPrototypeOf(this, NoParsletFoundError.prototype);
        }
        getToken() {
            return this.token;
        }
    }
    class EarlyEndOfParseError extends Error {
        constructor(token) {
            super(`The parsing ended early. The next token was: ${tokenToString(token)}`);
            this.token = token;
            Object.setPrototypeOf(this, EarlyEndOfParseError.prototype);
        }
        getToken() {
            return this.token;
        }
    }
    class UnexpectedTypeError extends Error {
        constructor(result, message) {
            let error = `Unexpected type: '${result.type}'.`;
            if (message !== undefined) {
                error += ` Message: ${message}`;
            }
            super(error);
            Object.setPrototypeOf(this, UnexpectedTypeError.prototype);
        }
    }
    // export class UnexpectedTokenError extends Error {
    //   private expected: Token
    //   private found: Token
    //
    //   constructor (expected: Token, found: Token) {
    //     super(`The parsing ended early. The next token was: ${tokenToString(token)}`)
    //
    //     this.token = token
    //
    //     Object.setPrototypeOf(this, EarlyEndOfParseError.prototype)
    //   }
    //
    //   getToken() {
    //     return this.token
    //   }
    // }

    function makePunctuationRule(type) {
        return text => {
            if (text.startsWith(type)) {
                return { type, text: type };
            }
            else {
                return null;
            }
        };
    }
    function getQuoted(text) {
        let position = 0;
        let char;
        const mark = text[0];
        let escaped = false;
        if (mark !== '\'' && mark !== '"') {
            return null;
        }
        while (position < text.length) {
            position++;
            char = text[position];
            if (!escaped && char === mark) {
                position++;
                break;
            }
            escaped = !escaped && char === '\\';
        }
        if (char !== mark) {
            throw new Error('Unterminated String');
        }
        return text.slice(0, position);
    }
    const identifierStartRegex = /[$_\p{ID_Start}]|\\u\p{Hex_Digit}{4}|\\u\{0*(?:\p{Hex_Digit}{1,5}|10\p{Hex_Digit}{4})\}/u;
    // A hyphen is not technically allowed, but to keep it liberal for now,
    //  adding it here
    const identifierContinueRegex = /[$\-\p{ID_Continue}\u200C\u200D]|\\u\p{Hex_Digit}{4}|\\u\{0*(?:\p{Hex_Digit}{1,5}|10\p{Hex_Digit}{4})\}/u;
    function getIdentifier(text) {
        let char = text[0];
        if (!identifierStartRegex.test(char)) {
            return null;
        }
        let position = 1;
        do {
            char = text[position];
            if (!identifierContinueRegex.test(char)) {
                break;
            }
            position++;
        } while (position < text.length);
        return text.slice(0, position);
    }
    // we are a bit more liberal than TypeScript here and allow `NaN`, `Infinity` and `-Infinity`
    const numberRegex = /^(NaN|-?((\d*\.\d+|\d+)([Ee][+-]?\d+)?|Infinity))/;
    function getNumber(text) {
        var _a, _b;
        return (_b = (_a = numberRegex.exec(text)) === null || _a === void 0 ? void 0 : _a[0]) !== null && _b !== void 0 ? _b : null;
    }
    const identifierRule = text => {
        const value = getIdentifier(text);
        if (value == null) {
            return null;
        }
        return {
            type: 'Identifier',
            text: value
        };
    };
    function makeKeyWordRule(type) {
        return text => {
            if (!text.startsWith(type)) {
                return null;
            }
            const prepends = text[type.length];
            if (prepends !== undefined && identifierContinueRegex.test(prepends)) {
                return null;
            }
            return {
                type,
                text: type
            };
        };
    }
    const stringValueRule = text => {
        const value = getQuoted(text);
        if (value == null) {
            return null;
        }
        return {
            type: 'StringValue',
            text: value
        };
    };
    const eofRule = text => {
        if (text.length > 0) {
            return null;
        }
        return {
            type: 'EOF',
            text: ''
        };
    };
    const numberRule = text => {
        const value = getNumber(text);
        if (value === null) {
            return null;
        }
        return {
            type: 'Number',
            text: value
        };
    };
    const rules = [
        eofRule,
        makePunctuationRule('=>'),
        makePunctuationRule('('),
        makePunctuationRule(')'),
        makePunctuationRule('{'),
        makePunctuationRule('}'),
        makePunctuationRule('['),
        makePunctuationRule(']'),
        makePunctuationRule('|'),
        makePunctuationRule('&'),
        makePunctuationRule('<'),
        makePunctuationRule('>'),
        makePunctuationRule(','),
        makePunctuationRule(';'),
        makePunctuationRule('*'),
        makePunctuationRule('?'),
        makePunctuationRule('!'),
        makePunctuationRule('='),
        makePunctuationRule(':'),
        makePunctuationRule('...'),
        makePunctuationRule('.'),
        makePunctuationRule('#'),
        makePunctuationRule('~'),
        makePunctuationRule('/'),
        makePunctuationRule('@'),
        makeKeyWordRule('undefined'),
        makeKeyWordRule('null'),
        makeKeyWordRule('function'),
        makeKeyWordRule('this'),
        makeKeyWordRule('new'),
        makeKeyWordRule('module'),
        makeKeyWordRule('event'),
        makeKeyWordRule('external'),
        makeKeyWordRule('typeof'),
        makeKeyWordRule('keyof'),
        makeKeyWordRule('readonly'),
        makeKeyWordRule('import'),
        makeKeyWordRule('is'),
        makeKeyWordRule('in'),
        makeKeyWordRule('asserts'),
        numberRule,
        identifierRule,
        stringValueRule
    ];
    const breakingWhitespaceRegex = /^\s*\n\s*/;
    class Lexer {
        static create(text) {
            const current = this.read(text);
            text = current.text;
            const next = this.read(text);
            text = next.text;
            return new Lexer(text, undefined, current.token, next.token);
        }
        constructor(text, previous, current, next) {
            this.text = '';
            this.text = text;
            this.previous = previous;
            this.current = current;
            this.next = next;
        }
        static read(text, startOfLine = false) {
            startOfLine = startOfLine || breakingWhitespaceRegex.test(text);
            text = text.trim();
            for (const rule of rules) {
                const partial = rule(text);
                if (partial !== null) {
                    const token = Object.assign(Object.assign({}, partial), { startOfLine });
                    text = text.slice(token.text.length);
                    return { text, token };
                }
            }
            throw new Error('Unexpected Token ' + text);
        }
        advance() {
            const next = Lexer.read(this.text);
            return new Lexer(next.text, this.current, this.next, next.token);
        }
    }

    /**
     * Throws an error if the provided result is not a {@link RootResult}
     */
    function assertRootResult(result) {
        if (result === undefined) {
            throw new Error('Unexpected undefined');
        }
        if (result.type === 'JsdocTypeKeyValue' || result.type === 'JsdocTypeParameterList' ||
            result.type === 'JsdocTypeProperty' || result.type === 'JsdocTypeReadonlyProperty' ||
            result.type === 'JsdocTypeObjectField' || result.type === 'JsdocTypeJsdocObjectField' ||
            result.type === 'JsdocTypeIndexSignature' || result.type === 'JsdocTypeMappedType') {
            throw new UnexpectedTypeError(result);
        }
        return result;
    }
    function assertPlainKeyValueOrRootResult(result) {
        if (result.type === 'JsdocTypeKeyValue') {
            return assertPlainKeyValueResult(result);
        }
        return assertRootResult(result);
    }
    function assertPlainKeyValueOrNameResult(result) {
        if (result.type === 'JsdocTypeName') {
            return result;
        }
        return assertPlainKeyValueResult(result);
    }
    function assertPlainKeyValueResult(result) {
        if (result.type !== 'JsdocTypeKeyValue') {
            throw new UnexpectedTypeError(result);
        }
        return result;
    }
    function assertNumberOrVariadicNameResult(result) {
        var _a;
        if (result.type === 'JsdocTypeVariadic') {
            if (((_a = result.element) === null || _a === void 0 ? void 0 : _a.type) === 'JsdocTypeName') {
                return result;
            }
            throw new UnexpectedTypeError(result);
        }
        if (result.type !== 'JsdocTypeNumber' && result.type !== 'JsdocTypeName') {
            throw new UnexpectedTypeError(result);
        }
        return result;
    }
    function isSquaredProperty(result) {
        return result.type === 'JsdocTypeIndexSignature' || result.type === 'JsdocTypeMappedType';
    }

    // higher precedence = higher importance
    var Precedence;
    (function (Precedence) {
        Precedence[Precedence["ALL"] = 0] = "ALL";
        Precedence[Precedence["PARAMETER_LIST"] = 1] = "PARAMETER_LIST";
        Precedence[Precedence["OBJECT"] = 2] = "OBJECT";
        Precedence[Precedence["KEY_VALUE"] = 3] = "KEY_VALUE";
        Precedence[Precedence["INDEX_BRACKETS"] = 4] = "INDEX_BRACKETS";
        Precedence[Precedence["UNION"] = 5] = "UNION";
        Precedence[Precedence["INTERSECTION"] = 6] = "INTERSECTION";
        Precedence[Precedence["PREFIX"] = 7] = "PREFIX";
        Precedence[Precedence["INFIX"] = 8] = "INFIX";
        Precedence[Precedence["TUPLE"] = 9] = "TUPLE";
        Precedence[Precedence["SYMBOL"] = 10] = "SYMBOL";
        Precedence[Precedence["OPTIONAL"] = 11] = "OPTIONAL";
        Precedence[Precedence["NULLABLE"] = 12] = "NULLABLE";
        Precedence[Precedence["KEY_OF_TYPE_OF"] = 13] = "KEY_OF_TYPE_OF";
        Precedence[Precedence["FUNCTION"] = 14] = "FUNCTION";
        Precedence[Precedence["ARROW"] = 15] = "ARROW";
        Precedence[Precedence["ARRAY_BRACKETS"] = 16] = "ARRAY_BRACKETS";
        Precedence[Precedence["GENERIC"] = 17] = "GENERIC";
        Precedence[Precedence["NAME_PATH"] = 18] = "NAME_PATH";
        Precedence[Precedence["PARENTHESIS"] = 19] = "PARENTHESIS";
        Precedence[Precedence["SPECIAL_TYPES"] = 20] = "SPECIAL_TYPES";
    })(Precedence || (Precedence = {}));

    class Parser {
        constructor(grammar, textOrLexer, baseParser) {
            this.grammar = grammar;
            if (typeof textOrLexer === 'string') {
                this._lexer = Lexer.create(textOrLexer);
            }
            else {
                this._lexer = textOrLexer;
            }
            this.baseParser = baseParser;
        }
        get lexer() {
            return this._lexer;
        }
        /**
         * Parses a given string and throws an error if the parse ended before the end of the string.
         */
        parse() {
            const result = this.parseType(Precedence.ALL);
            if (this.lexer.current.type !== 'EOF') {
                throw new EarlyEndOfParseError(this.lexer.current);
            }
            return result;
        }
        /**
         * Parses with the current lexer and asserts that the result is a {@link RootResult}.
         */
        parseType(precedence) {
            return assertRootResult(this.parseIntermediateType(precedence));
        }
        /**
         * The main parsing function. First it tries to parse the current state in the prefix step, and then it continues
         * to parse the state in the infix step.
         */
        parseIntermediateType(precedence) {
            const result = this.tryParslets(null, precedence);
            if (result === null) {
                throw new NoParsletFoundError(this.lexer.current);
            }
            return this.parseInfixIntermediateType(result, precedence);
        }
        /**
         * In the infix parsing step the parser continues to parse the current state with all parslets until none returns
         * a result.
         */
        parseInfixIntermediateType(left, precedence) {
            let result = this.tryParslets(left, precedence);
            while (result !== null) {
                left = result;
                result = this.tryParslets(left, precedence);
            }
            return left;
        }
        /**
         * Tries to parse the current state with all parslets in the grammar and returns the first non null result.
         */
        tryParslets(left, precedence) {
            for (const parslet of this.grammar) {
                const result = parslet(this, precedence, left);
                if (result !== null) {
                    return result;
                }
            }
            return null;
        }
        /**
         * If the given type equals the current type of the {@link Lexer} advance the lexer. Return true if the lexer was
         * advanced.
         */
        consume(types) {
            if (!Array.isArray(types)) {
                types = [types];
            }
            if (types.includes(this.lexer.current.type)) {
                this._lexer = this.lexer.advance();
                return true;
            }
            else {
                return false;
            }
        }
        acceptLexerState(parser) {
            this._lexer = parser.lexer;
        }
    }

    function isQuestionMarkUnknownType(next) {
        return next === 'EOF' || next === '|' || next === ',' || next === ')' || next === '>';
    }

    const nullableParslet = (parser, precedence, left) => {
        const type = parser.lexer.current.type;
        const next = parser.lexer.next.type;
        const accept = ((left == null) && type === '?' && !isQuestionMarkUnknownType(next)) ||
            ((left != null) && type === '?');
        if (!accept) {
            return null;
        }
        parser.consume('?');
        if (left == null) {
            return {
                type: 'JsdocTypeNullable',
                element: parser.parseType(Precedence.NULLABLE),
                meta: {
                    position: 'prefix'
                }
            };
        }
        else {
            return {
                type: 'JsdocTypeNullable',
                element: assertRootResult(left),
                meta: {
                    position: 'suffix'
                }
            };
        }
    };

    function composeParslet(options) {
        const parslet = (parser, curPrecedence, left) => {
            const type = parser.lexer.current.type;
            const next = parser.lexer.next.type;
            if (left === null) {
                if ('parsePrefix' in options) {
                    if (options.accept(type, next)) {
                        return options.parsePrefix(parser);
                    }
                }
            }
            else {
                if ('parseInfix' in options) {
                    if (options.precedence > curPrecedence && options.accept(type, next)) {
                        return options.parseInfix(parser, left);
                    }
                }
            }
            return null;
        };
        // for debugging
        Object.defineProperty(parslet, 'name', {
            value: options.name
        });
        return parslet;
    }

    const optionalParslet = composeParslet({
        name: 'optionalParslet',
        accept: type => type === '=',
        precedence: Precedence.OPTIONAL,
        parsePrefix: parser => {
            parser.consume('=');
            return {
                type: 'JsdocTypeOptional',
                element: parser.parseType(Precedence.OPTIONAL),
                meta: {
                    position: 'prefix'
                }
            };
        },
        parseInfix: (parser, left) => {
            parser.consume('=');
            return {
                type: 'JsdocTypeOptional',
                element: assertRootResult(left),
                meta: {
                    position: 'suffix'
                }
            };
        }
    });

    const numberParslet = composeParslet({
        name: 'numberParslet',
        accept: type => type === 'Number',
        parsePrefix: parser => {
            const value = parseFloat(parser.lexer.current.text);
            parser.consume('Number');
            return {
                type: 'JsdocTypeNumber',
                value
            };
        }
    });

    const parenthesisParslet = composeParslet({
        name: 'parenthesisParslet',
        accept: type => type === '(',
        parsePrefix: parser => {
            parser.consume('(');
            if (parser.consume(')')) {
                return {
                    type: 'JsdocTypeParameterList',
                    elements: []
                };
            }
            const result = parser.parseIntermediateType(Precedence.ALL);
            if (!parser.consume(')')) {
                throw new Error('Unterminated parenthesis');
            }
            if (result.type === 'JsdocTypeParameterList') {
                return result;
            }
            else if (result.type === 'JsdocTypeKeyValue') {
                return {
                    type: 'JsdocTypeParameterList',
                    elements: [result]
                };
            }
            return {
                type: 'JsdocTypeParenthesis',
                element: assertRootResult(result)
            };
        }
    });

    const specialTypesParslet = composeParslet({
        name: 'specialTypesParslet',
        accept: (type, next) => (type === '?' && isQuestionMarkUnknownType(next)) ||
            type === 'null' || type === 'undefined' || type === '*',
        parsePrefix: parser => {
            if (parser.consume('null')) {
                return {
                    type: 'JsdocTypeNull'
                };
            }
            if (parser.consume('undefined')) {
                return {
                    type: 'JsdocTypeUndefined'
                };
            }
            if (parser.consume('*')) {
                return {
                    type: 'JsdocTypeAny'
                };
            }
            if (parser.consume('?')) {
                return {
                    type: 'JsdocTypeUnknown'
                };
            }
            throw new Error('Unacceptable token: ' + parser.lexer.current.text);
        }
    });

    const notNullableParslet = composeParslet({
        name: 'notNullableParslet',
        accept: type => type === '!',
        precedence: Precedence.NULLABLE,
        parsePrefix: parser => {
            parser.consume('!');
            return {
                type: 'JsdocTypeNotNullable',
                element: parser.parseType(Precedence.NULLABLE),
                meta: {
                    position: 'prefix'
                }
            };
        },
        parseInfix: (parser, left) => {
            parser.consume('!');
            return {
                type: 'JsdocTypeNotNullable',
                element: assertRootResult(left),
                meta: {
                    position: 'suffix'
                }
            };
        }
    });

    function createParameterListParslet({ allowTrailingComma }) {
        return composeParslet({
            name: 'parameterListParslet',
            accept: type => type === ',',
            precedence: Precedence.PARAMETER_LIST,
            parseInfix: (parser, left) => {
                const elements = [
                    assertPlainKeyValueOrRootResult(left)
                ];
                parser.consume(',');
                do {
                    try {
                        const next = parser.parseIntermediateType(Precedence.PARAMETER_LIST);
                        elements.push(assertPlainKeyValueOrRootResult(next));
                    }
                    catch (e) {
                        if (allowTrailingComma && e instanceof NoParsletFoundError) {
                            break;
                        }
                        else {
                            throw e;
                        }
                    }
                } while (parser.consume(','));
                if (elements.length > 0 && elements.slice(0, -1).some(e => e.type === 'JsdocTypeVariadic')) {
                    throw new Error('Only the last parameter may be a rest parameter');
                }
                return {
                    type: 'JsdocTypeParameterList',
                    elements
                };
            }
        });
    }

    const genericParslet = composeParslet({
        name: 'genericParslet',
        accept: (type, next) => type === '<' || (type === '.' && next === '<'),
        precedence: Precedence.GENERIC,
        parseInfix: (parser, left) => {
            const dot = parser.consume('.');
            parser.consume('<');
            const objects = [];
            do {
                objects.push(parser.parseType(Precedence.PARAMETER_LIST));
            } while (parser.consume(','));
            if (!parser.consume('>')) {
                throw new Error('Unterminated generic parameter list');
            }
            return {
                type: 'JsdocTypeGeneric',
                left: assertRootResult(left),
                elements: objects,
                meta: {
                    brackets: 'angle',
                    dot
                }
            };
        }
    });

    const unionParslet = composeParslet({
        name: 'unionParslet',
        accept: type => type === '|',
        precedence: Precedence.UNION,
        parseInfix: (parser, left) => {
            parser.consume('|');
            const elements = [];
            do {
                elements.push(parser.parseType(Precedence.UNION));
            } while (parser.consume('|'));
            return {
                type: 'JsdocTypeUnion',
                elements: [assertRootResult(left), ...elements]
            };
        }
    });

    const baseGrammar = [
        nullableParslet,
        optionalParslet,
        numberParslet,
        parenthesisParslet,
        specialTypesParslet,
        notNullableParslet,
        createParameterListParslet({
            allowTrailingComma: true
        }),
        genericParslet,
        unionParslet,
        optionalParslet
    ];

    function createNamePathParslet({ allowSquareBracketsOnAnyType, allowJsdocNamePaths, pathGrammar }) {
        return function namePathParslet(parser, precedence, left) {
            if ((left == null) || precedence >= Precedence.NAME_PATH) {
                return null;
            }
            const type = parser.lexer.current.type;
            const next = parser.lexer.next.type;
            const accept = (type === '.' && next !== '<') ||
                (type === '[' && (allowSquareBracketsOnAnyType || left.type === 'JsdocTypeName')) ||
                (allowJsdocNamePaths && (type === '~' || type === '#'));
            if (!accept) {
                return null;
            }
            let pathType;
            let brackets = false;
            if (parser.consume('.')) {
                pathType = 'property';
            }
            else if (parser.consume('[')) {
                pathType = 'property-brackets';
                brackets = true;
            }
            else if (parser.consume('~')) {
                pathType = 'inner';
            }
            else {
                parser.consume('#');
                pathType = 'instance';
            }
            const pathParser = pathGrammar !== null
                ? new Parser(pathGrammar, parser.lexer, parser)
                : parser;
            const parsed = pathParser.parseIntermediateType(Precedence.NAME_PATH);
            parser.acceptLexerState(pathParser);
            let right;
            switch (parsed.type) {
                case 'JsdocTypeName':
                    right = {
                        type: 'JsdocTypeProperty',
                        value: parsed.value,
                        meta: {
                            quote: undefined
                        }
                    };
                    break;
                case 'JsdocTypeNumber':
                    right = {
                        type: 'JsdocTypeProperty',
                        value: parsed.value.toString(10),
                        meta: {
                            quote: undefined
                        }
                    };
                    break;
                case 'JsdocTypeStringValue':
                    right = {
                        type: 'JsdocTypeProperty',
                        value: parsed.value,
                        meta: {
                            quote: parsed.meta.quote
                        }
                    };
                    break;
                case 'JsdocTypeSpecialNamePath':
                    if (parsed.specialType === 'event') {
                        right = parsed;
                    }
                    else {
                        throw new UnexpectedTypeError(parsed, 'Type \'JsdocTypeSpecialNamePath\' is only allowed with specialType \'event\'');
                    }
                    break;
                default:
                    throw new UnexpectedTypeError(parsed, 'Expecting \'JsdocTypeName\', \'JsdocTypeNumber\', \'JsdocStringValue\' or \'JsdocTypeSpecialNamePath\'');
            }
            if (brackets && !parser.consume(']')) {
                const token = parser.lexer.current;
                throw new Error(`Unterminated square brackets. Next token is '${token.type}' ` +
                    `with text '${token.text}'`);
            }
            return {
                type: 'JsdocTypeNamePath',
                left: assertRootResult(left),
                right,
                pathType
            };
        };
    }

    function createNameParslet({ allowedAdditionalTokens }) {
        return composeParslet({
            name: 'nameParslet',
            accept: type => type === 'Identifier' || type === 'this' || type === 'new' || allowedAdditionalTokens.includes(type),
            parsePrefix: parser => {
                const { type, text } = parser.lexer.current;
                parser.consume(type);
                return {
                    type: 'JsdocTypeName',
                    value: text
                };
            }
        });
    }

    const stringValueParslet = composeParslet({
        name: 'stringValueParslet',
        accept: type => type === 'StringValue',
        parsePrefix: parser => {
            const text = parser.lexer.current.text;
            parser.consume('StringValue');
            return {
                type: 'JsdocTypeStringValue',
                value: text.slice(1, -1),
                meta: {
                    quote: text[0] === '\'' ? 'single' : 'double'
                }
            };
        }
    });

    function createSpecialNamePathParslet({ pathGrammar, allowedTypes }) {
        return composeParslet({
            name: 'specialNamePathParslet',
            accept: type => allowedTypes.includes(type),
            parsePrefix: parser => {
                const type = parser.lexer.current.type;
                parser.consume(type);
                if (!parser.consume(':')) {
                    return {
                        type: 'JsdocTypeName',
                        value: type
                    };
                }
                let result;
                let token = parser.lexer.current;
                if (parser.consume('StringValue')) {
                    result = {
                        type: 'JsdocTypeSpecialNamePath',
                        value: token.text.slice(1, -1),
                        specialType: type,
                        meta: {
                            quote: token.text[0] === '\'' ? 'single' : 'double'
                        }
                    };
                }
                else {
                    let value = '';
                    const allowed = ['Identifier', '@', '/'];
                    while (allowed.some(type => parser.consume(type))) {
                        value += token.text;
                        token = parser.lexer.current;
                    }
                    result = {
                        type: 'JsdocTypeSpecialNamePath',
                        value,
                        specialType: type,
                        meta: {
                            quote: undefined
                        }
                    };
                }
                const moduleParser = new Parser(pathGrammar, parser.lexer, parser);
                const moduleResult = moduleParser.parseInfixIntermediateType(result, Precedence.ALL);
                parser.acceptLexerState(moduleParser);
                return assertRootResult(moduleResult);
            }
        });
    }

    const basePathGrammar = [
        createNameParslet({
            allowedAdditionalTokens: ['external', 'module']
        }),
        stringValueParslet,
        numberParslet,
        createNamePathParslet({
            allowSquareBracketsOnAnyType: false,
            allowJsdocNamePaths: true,
            pathGrammar: null
        })
    ];
    const pathGrammar = [
        ...basePathGrammar,
        createSpecialNamePathParslet({
            allowedTypes: ['event'],
            pathGrammar: basePathGrammar
        })
    ];

    function getParameters(value) {
        let parameters;
        if (value.type === 'JsdocTypeParameterList') {
            parameters = value.elements;
        }
        else if (value.type === 'JsdocTypeParenthesis') {
            parameters = [value.element];
        }
        else {
            throw new UnexpectedTypeError(value);
        }
        return parameters.map(p => assertPlainKeyValueOrRootResult(p));
    }
    function getUnnamedParameters(value) {
        const parameters = getParameters(value);
        if (parameters.some(p => p.type === 'JsdocTypeKeyValue')) {
            throw new Error('No parameter should be named');
        }
        return parameters;
    }
    function createFunctionParslet({ allowNamedParameters, allowNoReturnType, allowWithoutParenthesis, allowNewAsFunctionKeyword }) {
        return composeParslet({
            name: 'functionParslet',
            accept: (type, next) => type === 'function' || (allowNewAsFunctionKeyword && type === 'new' && next === '('),
            parsePrefix: parser => {
                const newKeyword = parser.consume('new');
                parser.consume('function');
                const hasParenthesis = parser.lexer.current.type === '(';
                if (!hasParenthesis) {
                    if (!allowWithoutParenthesis) {
                        throw new Error('function is missing parameter list');
                    }
                    return {
                        type: 'JsdocTypeName',
                        value: 'function'
                    };
                }
                let result = {
                    type: 'JsdocTypeFunction',
                    parameters: [],
                    arrow: false,
                    constructor: newKeyword,
                    parenthesis: hasParenthesis
                };
                const value = parser.parseIntermediateType(Precedence.FUNCTION);
                if (allowNamedParameters === undefined) {
                    result.parameters = getUnnamedParameters(value);
                }
                else if (newKeyword && value.type === 'JsdocTypeFunction' && value.arrow) {
                    result = value;
                    result.constructor = true;
                    return result;
                }
                else {
                    result.parameters = getParameters(value);
                    for (const p of result.parameters) {
                        if (p.type === 'JsdocTypeKeyValue' && (!allowNamedParameters.includes(p.key))) {
                            throw new Error(`only allowed named parameters are ${allowNamedParameters.join(', ')} but got ${p.type}`);
                        }
                    }
                }
                if (parser.consume(':')) {
                    result.returnType = parser.parseType(Precedence.PREFIX);
                }
                else {
                    if (!allowNoReturnType) {
                        throw new Error('function is missing return type');
                    }
                }
                return result;
            }
        });
    }

    function createVariadicParslet({ allowPostfix, allowEnclosingBrackets }) {
        return composeParslet({
            name: 'variadicParslet',
            accept: type => type === '...',
            precedence: Precedence.PREFIX,
            parsePrefix: parser => {
                parser.consume('...');
                const brackets = allowEnclosingBrackets && parser.consume('[');
                try {
                    const element = parser.parseType(Precedence.PREFIX);
                    if (brackets && !parser.consume(']')) {
                        throw new Error('Unterminated variadic type. Missing \']\'');
                    }
                    return {
                        type: 'JsdocTypeVariadic',
                        element: assertRootResult(element),
                        meta: {
                            position: 'prefix',
                            squareBrackets: brackets
                        }
                    };
                }
                catch (e) {
                    if (e instanceof NoParsletFoundError) {
                        if (brackets) {
                            throw new Error('Empty square brackets for variadic are not allowed.');
                        }
                        return {
                            type: 'JsdocTypeVariadic',
                            meta: {
                                position: undefined,
                                squareBrackets: false
                            }
                        };
                    }
                    else {
                        throw e;
                    }
                }
            },
            parseInfix: allowPostfix
                ? (parser, left) => {
                    parser.consume('...');
                    return {
                        type: 'JsdocTypeVariadic',
                        element: assertRootResult(left),
                        meta: {
                            position: 'suffix',
                            squareBrackets: false
                        }
                    };
                }
                : undefined
        });
    }

    const symbolParslet = composeParslet({
        name: 'symbolParslet',
        accept: type => type === '(',
        precedence: Precedence.SYMBOL,
        parseInfix: (parser, left) => {
            if (left.type !== 'JsdocTypeName') {
                throw new Error('Symbol expects a name on the left side. (Reacting on \'(\')');
            }
            parser.consume('(');
            const result = {
                type: 'JsdocTypeSymbol',
                value: left.value
            };
            if (!parser.consume(')')) {
                const next = parser.parseIntermediateType(Precedence.SYMBOL);
                result.element = assertNumberOrVariadicNameResult(next);
                if (!parser.consume(')')) {
                    throw new Error('Symbol does not end after value');
                }
            }
            return result;
        }
    });

    const arrayBracketsParslet = composeParslet({
        name: 'arrayBracketsParslet',
        precedence: Precedence.ARRAY_BRACKETS,
        accept: (type, next) => type === '[' && next === ']',
        parseInfix: (parser, left) => {
            parser.consume('[');
            parser.consume(']');
            return {
                type: 'JsdocTypeGeneric',
                left: {
                    type: 'JsdocTypeName',
                    value: 'Array'
                },
                elements: [
                    assertRootResult(left)
                ],
                meta: {
                    brackets: 'square',
                    dot: false
                }
            };
        }
    });

    function createObjectParslet({ objectFieldGrammar, allowKeyTypes }) {
        return composeParslet({
            name: 'objectParslet',
            accept: type => type === '{',
            parsePrefix: parser => {
                parser.consume('{');
                const result = {
                    type: 'JsdocTypeObject',
                    meta: {
                        separator: 'comma'
                    },
                    elements: []
                };
                if (!parser.consume('}')) {
                    let separator;
                    const fieldParser = new Parser(objectFieldGrammar, parser.lexer, parser);
                    while (true) {
                        fieldParser.acceptLexerState(parser);
                        let field = fieldParser.parseIntermediateType(Precedence.OBJECT);
                        parser.acceptLexerState(fieldParser);
                        if (field === undefined && allowKeyTypes) {
                            field = parser.parseIntermediateType(Precedence.OBJECT);
                        }
                        let optional = false;
                        if (field.type === 'JsdocTypeNullable') {
                            optional = true;
                            field = field.element;
                        }
                        if (field.type === 'JsdocTypeNumber' || field.type === 'JsdocTypeName' || field.type === 'JsdocTypeStringValue') {
                            let quote;
                            if (field.type === 'JsdocTypeStringValue') {
                                quote = field.meta.quote;
                            }
                            result.elements.push({
                                type: 'JsdocTypeObjectField',
                                key: field.value.toString(),
                                right: undefined,
                                optional,
                                readonly: false,
                                meta: {
                                    quote
                                }
                            });
                        }
                        else if (field.type === 'JsdocTypeObjectField' || field.type === 'JsdocTypeJsdocObjectField') {
                            result.elements.push(field);
                        }
                        else {
                            throw new UnexpectedTypeError(field);
                        }
                        if (parser.lexer.current.startOfLine) {
                            separator = 'linebreak';
                        }
                        else if (parser.consume(',')) {
                            separator = 'comma';
                        }
                        else if (parser.consume(';')) {
                            separator = 'semicolon';
                        }
                        else {
                            break;
                        }
                        const type = parser.lexer.current.type;
                        if (type === '}') {
                            break;
                        }
                    }
                    result.meta.separator = separator !== null && separator !== void 0 ? separator : 'comma'; // TODO: use undefined here
                    if (!parser.consume('}')) {
                        throw new Error('Unterminated record type. Missing \'}\'');
                    }
                }
                return result;
            }
        });
    }

    function createObjectFieldParslet({ allowSquaredProperties, allowKeyTypes, allowReadonly, allowOptional }) {
        return composeParslet({
            name: 'objectFieldParslet',
            precedence: Precedence.KEY_VALUE,
            accept: type => type === ':',
            parseInfix: (parser, left) => {
                var _a;
                let optional = false;
                let readonlyProperty = false;
                if (allowOptional && left.type === 'JsdocTypeNullable') {
                    optional = true;
                    left = left.element;
                }
                if (allowReadonly && left.type === 'JsdocTypeReadonlyProperty') {
                    readonlyProperty = true;
                    left = left.element;
                }
                // object parslet uses a special grammar and for the value we want to switch back to the parent
                const parentParser = (_a = parser.baseParser) !== null && _a !== void 0 ? _a : parser;
                parentParser.acceptLexerState(parser);
                if (left.type === 'JsdocTypeNumber' || left.type === 'JsdocTypeName' || left.type === 'JsdocTypeStringValue' ||
                    isSquaredProperty(left)) {
                    if (isSquaredProperty(left) && !allowSquaredProperties) {
                        throw new UnexpectedTypeError(left);
                    }
                    parentParser.consume(':');
                    let quote;
                    if (left.type === 'JsdocTypeStringValue') {
                        quote = left.meta.quote;
                    }
                    const right = parentParser.parseType(Precedence.KEY_VALUE);
                    parser.acceptLexerState(parentParser);
                    return {
                        type: 'JsdocTypeObjectField',
                        key: isSquaredProperty(left) ? left : left.value.toString(),
                        right,
                        optional,
                        readonly: readonlyProperty,
                        meta: {
                            quote
                        }
                    };
                }
                else {
                    if (!allowKeyTypes) {
                        throw new UnexpectedTypeError(left);
                    }
                    parentParser.consume(':');
                    const right = parentParser.parseType(Precedence.KEY_VALUE);
                    parser.acceptLexerState(parentParser);
                    return {
                        type: 'JsdocTypeJsdocObjectField',
                        left: assertRootResult(left),
                        right
                    };
                }
            }
        });
    }

    function createKeyValueParslet({ allowOptional, allowVariadic }) {
        return composeParslet({
            name: 'keyValueParslet',
            precedence: Precedence.KEY_VALUE,
            accept: type => type === ':',
            parseInfix: (parser, left) => {
                let optional = false;
                let variadic = false;
                if (allowOptional && left.type === 'JsdocTypeNullable') {
                    optional = true;
                    left = left.element;
                }
                if (allowVariadic && left.type === 'JsdocTypeVariadic' && left.element !== undefined) {
                    variadic = true;
                    left = left.element;
                }
                if (left.type !== 'JsdocTypeName') {
                    throw new UnexpectedTypeError(left);
                }
                parser.consume(':');
                const right = parser.parseType(Precedence.KEY_VALUE);
                return {
                    type: 'JsdocTypeKeyValue',
                    key: left.value,
                    right,
                    optional,
                    variadic
                };
            }
        });
    }

    const jsdocBaseGrammar = [
        ...baseGrammar,
        createFunctionParslet({
            allowWithoutParenthesis: true,
            allowNamedParameters: ['this', 'new'],
            allowNoReturnType: true,
            allowNewAsFunctionKeyword: false
        }),
        stringValueParslet,
        createSpecialNamePathParslet({
            allowedTypes: ['module', 'external', 'event'],
            pathGrammar
        }),
        createVariadicParslet({
            allowEnclosingBrackets: true,
            allowPostfix: true
        }),
        createNameParslet({
            allowedAdditionalTokens: ['keyof']
        }),
        symbolParslet,
        arrayBracketsParslet,
        createNamePathParslet({
            allowSquareBracketsOnAnyType: false,
            allowJsdocNamePaths: true,
            pathGrammar
        })
    ];
    const jsdocGrammar = [
        ...jsdocBaseGrammar,
        createObjectParslet({
            // jsdoc syntax allows full types as keys, so we need to pull in the full grammar here
            // we leave out the object type deliberately
            objectFieldGrammar: [
                createNameParslet({
                    allowedAdditionalTokens: ['module', 'in']
                }),
                createObjectFieldParslet({
                    allowSquaredProperties: false,
                    allowKeyTypes: true,
                    allowOptional: false,
                    allowReadonly: false
                }),
                ...jsdocBaseGrammar
            ],
            allowKeyTypes: true
        }),
        createKeyValueParslet({
            allowOptional: true,
            allowVariadic: true
        })
    ];

    const typeOfParslet = composeParslet({
        name: 'typeOfParslet',
        accept: type => type === 'typeof',
        parsePrefix: parser => {
            parser.consume('typeof');
            return {
                type: 'JsdocTypeTypeof',
                element: assertRootResult(parser.parseType(Precedence.KEY_OF_TYPE_OF))
            };
        }
    });

    const objectFieldGrammar$1 = [
        createNameParslet({
            allowedAdditionalTokens: ['module', 'keyof', 'event', 'external', 'in']
        }),
        nullableParslet,
        optionalParslet,
        stringValueParslet,
        numberParslet,
        createObjectFieldParslet({
            allowSquaredProperties: false,
            allowKeyTypes: false,
            allowOptional: false,
            allowReadonly: false
        })
    ];
    const closureGrammar = [
        ...baseGrammar,
        createObjectParslet({
            allowKeyTypes: false,
            objectFieldGrammar: objectFieldGrammar$1
        }),
        createNameParslet({
            allowedAdditionalTokens: ['event', 'external', 'in']
        }),
        typeOfParslet,
        createFunctionParslet({
            allowWithoutParenthesis: false,
            allowNamedParameters: ['this', 'new'],
            allowNoReturnType: true,
            allowNewAsFunctionKeyword: false
        }),
        createVariadicParslet({
            allowEnclosingBrackets: false,
            allowPostfix: false
        }),
        // additional name parslet is needed for some special cases
        createNameParslet({
            allowedAdditionalTokens: ['keyof']
        }),
        createSpecialNamePathParslet({
            allowedTypes: ['module'],
            pathGrammar
        }),
        createNamePathParslet({
            allowSquareBracketsOnAnyType: false,
            allowJsdocNamePaths: true,
            pathGrammar
        }),
        createKeyValueParslet({
            allowOptional: false,
            allowVariadic: false
        }),
        symbolParslet
    ];

    const assertsParslet = composeParslet({
        name: 'assertsParslet',
        accept: type => type === 'asserts',
        parsePrefix: (parser) => {
            parser.consume('asserts');
            const left = parser.parseIntermediateType(Precedence.SYMBOL);
            if (left.type !== 'JsdocTypeName') {
                throw new UnexpectedTypeError(left, 'A typescript asserts always has to have a name on the left side.');
            }
            parser.consume('is');
            return {
                type: 'JsdocTypeAsserts',
                left,
                right: assertRootResult(parser.parseIntermediateType(Precedence.INFIX))
            };
        }
    });

    function createTupleParslet({ allowQuestionMark }) {
        return composeParslet({
            name: 'tupleParslet',
            accept: type => type === '[',
            parsePrefix: parser => {
                parser.consume('[');
                const result = {
                    type: 'JsdocTypeTuple',
                    elements: []
                };
                if (parser.consume(']')) {
                    return result;
                }
                const typeList = parser.parseIntermediateType(Precedence.ALL);
                if (typeList.type === 'JsdocTypeParameterList') {
                    if (typeList.elements[0].type === 'JsdocTypeKeyValue') {
                        result.elements = typeList.elements.map(assertPlainKeyValueResult);
                    }
                    else {
                        result.elements = typeList.elements.map(assertRootResult);
                    }
                }
                else {
                    if (typeList.type === 'JsdocTypeKeyValue') {
                        result.elements = [assertPlainKeyValueResult(typeList)];
                    }
                    else {
                        result.elements = [assertRootResult(typeList)];
                    }
                }
                if (!parser.consume(']')) {
                    throw new Error('Unterminated \'[\'');
                }
                if (!allowQuestionMark && result.elements.some((e) => e.type === 'JsdocTypeUnknown')) {
                    throw new Error('Question mark in tuple not allowed');
                }
                return result;
            }
        });
    }

    const keyOfParslet = composeParslet({
        name: 'keyOfParslet',
        accept: type => type === 'keyof',
        parsePrefix: parser => {
            parser.consume('keyof');
            return {
                type: 'JsdocTypeKeyof',
                element: assertRootResult(parser.parseType(Precedence.KEY_OF_TYPE_OF))
            };
        }
    });

    const importParslet = composeParslet({
        name: 'importParslet',
        accept: type => type === 'import',
        parsePrefix: parser => {
            parser.consume('import');
            if (!parser.consume('(')) {
                throw new Error('Missing parenthesis after import keyword');
            }
            const path = parser.parseType(Precedence.PREFIX);
            if (path.type !== 'JsdocTypeStringValue') {
                throw new Error('Only string values are allowed as paths for imports');
            }
            if (!parser.consume(')')) {
                throw new Error('Missing closing parenthesis after import keyword');
            }
            return {
                type: 'JsdocTypeImport',
                element: path
            };
        }
    });

    const readonlyPropertyParslet = composeParslet({
        name: 'readonlyPropertyParslet',
        accept: type => type === 'readonly',
        parsePrefix: parser => {
            parser.consume('readonly');
            return {
                type: 'JsdocTypeReadonlyProperty',
                element: parser.parseType(Precedence.KEY_VALUE)
            };
        }
    });

    const arrowFunctionParslet = composeParslet({
        name: 'arrowFunctionParslet',
        precedence: Precedence.ARROW,
        accept: type => type === '=>',
        parseInfix: (parser, left) => {
            parser.consume('=>');
            return {
                type: 'JsdocTypeFunction',
                parameters: getParameters(left).map(assertPlainKeyValueOrNameResult),
                arrow: true,
                constructor: false,
                parenthesis: true,
                returnType: parser.parseType(Precedence.OBJECT)
            };
        }
    });

    const intersectionParslet = composeParslet({
        name: 'intersectionParslet',
        accept: type => type === '&',
        precedence: Precedence.INTERSECTION,
        parseInfix: (parser, left) => {
            parser.consume('&');
            const elements = [];
            do {
                elements.push(parser.parseType(Precedence.INTERSECTION));
            } while (parser.consume('&'));
            return {
                type: 'JsdocTypeIntersection',
                elements: [assertRootResult(left), ...elements]
            };
        }
    });

    const predicateParslet = composeParslet({
        name: 'predicateParslet',
        precedence: Precedence.INFIX,
        accept: type => type === 'is',
        parseInfix: (parser, left) => {
            if (left.type !== 'JsdocTypeName') {
                throw new UnexpectedTypeError(left, 'A typescript predicate always has to have a name on the left side.');
            }
            parser.consume('is');
            return {
                type: 'JsdocTypePredicate',
                left,
                right: assertRootResult(parser.parseIntermediateType(Precedence.INFIX))
            };
        }
    });

    const objectSquaredPropertyParslet = composeParslet({
        name: 'objectSquareBracketPropertyParslet',
        accept: type => type === '[',
        parsePrefix: parser => {
            if (parser.baseParser === undefined) {
                throw new Error('Only allowed inside object grammar');
            }
            parser.consume('[');
            const key = parser.lexer.current.text;
            parser.consume('Identifier');
            let result;
            if (parser.consume(':')) {
                const parentParser = parser.baseParser;
                parentParser.acceptLexerState(parser);
                result = {
                    type: 'JsdocTypeIndexSignature',
                    key,
                    right: parentParser.parseType(Precedence.INDEX_BRACKETS)
                };
                parser.acceptLexerState(parentParser);
            }
            else if (parser.consume('in')) {
                const parentParser = parser.baseParser;
                parentParser.acceptLexerState(parser);
                result = {
                    type: 'JsdocTypeMappedType',
                    key,
                    right: parentParser.parseType(Precedence.ARRAY_BRACKETS)
                };
                parser.acceptLexerState(parentParser);
            }
            else {
                throw new Error('Missing \':\' or \'in\' inside square bracketed property.');
            }
            if (!parser.consume(']')) {
                throw new Error('Unterminated square brackets');
            }
            return result;
        }
    });

    const objectFieldGrammar = [
        readonlyPropertyParslet,
        createNameParslet({
            allowedAdditionalTokens: ['module', 'event', 'keyof', 'event', 'external', 'in']
        }),
        nullableParslet,
        optionalParslet,
        stringValueParslet,
        numberParslet,
        createObjectFieldParslet({
            allowSquaredProperties: true,
            allowKeyTypes: false,
            allowOptional: true,
            allowReadonly: true
        }),
        objectSquaredPropertyParslet
    ];
    const typescriptGrammar = [
        ...baseGrammar,
        createObjectParslet({
            allowKeyTypes: false,
            objectFieldGrammar
        }),
        typeOfParslet,
        keyOfParslet,
        importParslet,
        stringValueParslet,
        createFunctionParslet({
            allowWithoutParenthesis: true,
            allowNoReturnType: false,
            allowNamedParameters: ['this', 'new', 'args'],
            allowNewAsFunctionKeyword: true
        }),
        createTupleParslet({
            allowQuestionMark: false
        }),
        createVariadicParslet({
            allowEnclosingBrackets: false,
            allowPostfix: false
        }),
        assertsParslet,
        createNameParslet({
            allowedAdditionalTokens: ['event', 'external', 'in']
        }),
        createSpecialNamePathParslet({
            allowedTypes: ['module'],
            pathGrammar
        }),
        arrayBracketsParslet,
        arrowFunctionParslet,
        createNamePathParslet({
            allowSquareBracketsOnAnyType: true,
            allowJsdocNamePaths: false,
            pathGrammar
        }),
        intersectionParslet,
        predicateParslet,
        createKeyValueParslet({
            allowVariadic: true,
            allowOptional: true
        })
    ];

    /**
     * This function parses the given expression in the given mode and produces a {@link RootResult}.
     * @param expression
     * @param mode
     */
    function parse(expression, mode) {
        switch (mode) {
            case 'closure':
                return (new Parser(closureGrammar, expression)).parse();
            case 'jsdoc':
                return (new Parser(jsdocGrammar, expression)).parse();
            case 'typescript':
                return (new Parser(typescriptGrammar, expression)).parse();
        }
    }
    /**
     * This function tries to parse the given expression in multiple modes and returns the first successful
     * {@link RootResult}. By default it tries `'typescript'`, `'closure'` and `'jsdoc'` in this order. If
     * no mode was successful it throws the error that was produced by the last parsing attempt.
     * @param expression
     * @param modes
     */
    function tryParse(expression, modes = ['typescript', 'closure', 'jsdoc']) {
        let error;
        for (const mode of modes) {
            try {
                return parse(expression, mode);
            }
            catch (e) {
                error = e;
            }
        }
        throw error;
    }

    function transform(rules, parseResult) {
        const rule = rules[parseResult.type];
        if (rule === undefined) {
            throw new Error(`In this set of transform rules exists no rule for type ${parseResult.type}.`);
        }
        return rule(parseResult, aParseResult => transform(rules, aParseResult));
    }
    function notAvailableTransform(parseResult) {
        throw new Error('This transform is not available. Are you trying the correct parsing mode?');
    }
    function extractSpecialParams(source) {
        const result = {
            params: []
        };
        for (const param of source.parameters) {
            if (param.type === 'JsdocTypeKeyValue') {
                if (param.key === 'this') {
                    result.this = param.right;
                }
                else if (param.key === 'new') {
                    result.new = param.right;
                }
                else {
                    result.params.push(param);
                }
            }
            else {
                result.params.push(param);
            }
        }
        return result;
    }

    function applyPosition(position, target, value) {
        return position === 'prefix' ? value + target : target + value;
    }
    function quote(value, quote) {
        switch (quote) {
            case 'double':
                return `"${value}"`;
            case 'single':
                return `'${value}'`;
            case undefined:
                return value;
        }
    }
    function stringifyRules() {
        return {
            JsdocTypeParenthesis: (result, transform) => `(${result.element !== undefined ? transform(result.element) : ''})`,
            JsdocTypeKeyof: (result, transform) => `keyof ${transform(result.element)}`,
            JsdocTypeFunction: (result, transform) => {
                if (!result.arrow) {
                    let stringified = result.constructor ? 'new' : 'function';
                    if (!result.parenthesis) {
                        return stringified;
                    }
                    stringified += `(${result.parameters.map(transform).join(', ')})`;
                    if (result.returnType !== undefined) {
                        stringified += `: ${transform(result.returnType)}`;
                    }
                    return stringified;
                }
                else {
                    if (result.returnType === undefined) {
                        throw new Error('Arrow function needs a return type.');
                    }
                    let stringified = `(${result.parameters.map(transform).join(', ')}) => ${transform(result.returnType)}`;
                    if (result.constructor) {
                        stringified = 'new ' + stringified;
                    }
                    return stringified;
                }
            },
            JsdocTypeName: result => result.value,
            JsdocTypeTuple: (result, transform) => `[${result.elements.map(transform).join(', ')}]`,
            JsdocTypeVariadic: (result, transform) => result.meta.position === undefined
                ? '...'
                : applyPosition(result.meta.position, transform(result.element), '...'),
            JsdocTypeNamePath: (result, transform) => {
                const left = transform(result.left);
                const right = transform(result.right);
                switch (result.pathType) {
                    case 'inner':
                        return `${left}~${right}`;
                    case 'instance':
                        return `${left}#${right}`;
                    case 'property':
                        return `${left}.${right}`;
                    case 'property-brackets':
                        return `${left}[${right}]`;
                }
            },
            JsdocTypeStringValue: result => quote(result.value, result.meta.quote),
            JsdocTypeAny: () => '*',
            JsdocTypeGeneric: (result, transform) => {
                if (result.meta.brackets === 'square') {
                    const element = result.elements[0];
                    const transformed = transform(element);
                    if (element.type === 'JsdocTypeUnion' || element.type === 'JsdocTypeIntersection') {
                        return `(${transformed})[]`;
                    }
                    else {
                        return `${transformed}[]`;
                    }
                }
                else {
                    return `${transform(result.left)}${result.meta.dot ? '.' : ''}<${result.elements.map(transform).join(', ')}>`;
                }
            },
            JsdocTypeImport: (result, transform) => `import(${transform(result.element)})`,
            JsdocTypeObjectField: (result, transform) => {
                let text = '';
                if (result.readonly) {
                    text += 'readonly ';
                }
                if (typeof result.key === 'string') {
                    text += quote(result.key, result.meta.quote);
                }
                else {
                    text += transform(result.key);
                }
                if (result.optional) {
                    text += '?';
                }
                if (result.right === undefined) {
                    return text;
                }
                else {
                    return text + `: ${transform(result.right)}`;
                }
            },
            JsdocTypeJsdocObjectField: (result, transform) => {
                return `${transform(result.left)}: ${transform(result.right)}`;
            },
            JsdocTypeKeyValue: (result, transform) => {
                let text = result.key;
                if (result.optional) {
                    text += '?';
                }
                if (result.variadic) {
                    text = '...' + text;
                }
                if (result.right === undefined) {
                    return text;
                }
                else {
                    return text + `: ${transform(result.right)}`;
                }
            },
            JsdocTypeSpecialNamePath: result => `${result.specialType}:${quote(result.value, result.meta.quote)}`,
            JsdocTypeNotNullable: (result, transform) => applyPosition(result.meta.position, transform(result.element), '!'),
            JsdocTypeNull: () => 'null',
            JsdocTypeNullable: (result, transform) => applyPosition(result.meta.position, transform(result.element), '?'),
            JsdocTypeNumber: result => result.value.toString(),
            JsdocTypeObject: (result, transform) => `{${result.elements.map(transform).join((result.meta.separator === 'comma' ? ',' : ';') + ' ')}}`,
            JsdocTypeOptional: (result, transform) => applyPosition(result.meta.position, transform(result.element), '='),
            JsdocTypeSymbol: (result, transform) => `${result.value}(${result.element !== undefined ? transform(result.element) : ''})`,
            JsdocTypeTypeof: (result, transform) => `typeof ${transform(result.element)}`,
            JsdocTypeUndefined: () => 'undefined',
            JsdocTypeUnion: (result, transform) => result.elements.map(transform).join(' | '),
            JsdocTypeUnknown: () => '?',
            JsdocTypeIntersection: (result, transform) => result.elements.map(transform).join(' & '),
            JsdocTypeProperty: result => quote(result.value, result.meta.quote),
            JsdocTypePredicate: (result, transform) => `${transform(result.left)} is ${transform(result.right)}`,
            JsdocTypeIndexSignature: (result, transform) => `[${result.key}: ${transform(result.right)}]`,
            JsdocTypeMappedType: (result, transform) => `[${result.key} in ${transform(result.right)}]`,
            JsdocTypeAsserts: (result, transform) => `asserts ${transform(result.left)} is ${transform(result.right)}`
        };
    }
    const storedStringifyRules = stringifyRules();
    function stringify(result) {
        return transform(storedStringifyRules, result);
    }

    const reservedWords = [
        'null',
        'true',
        'false',
        'break',
        'case',
        'catch',
        'class',
        'const',
        'continue',
        'debugger',
        'default',
        'delete',
        'do',
        'else',
        'export',
        'extends',
        'finally',
        'for',
        'function',
        'if',
        'import',
        'in',
        'instanceof',
        'new',
        'return',
        'super',
        'switch',
        'this',
        'throw',
        'try',
        'typeof',
        'var',
        'void',
        'while',
        'with',
        'yield'
    ];
    function makeName(value) {
        const result = {
            type: 'NameExpression',
            name: value
        };
        if (reservedWords.includes(value)) {
            result.reservedWord = true;
        }
        return result;
    }
    const catharsisTransformRules = {
        JsdocTypeOptional: (result, transform) => {
            const transformed = transform(result.element);
            transformed.optional = true;
            return transformed;
        },
        JsdocTypeNullable: (result, transform) => {
            const transformed = transform(result.element);
            transformed.nullable = true;
            return transformed;
        },
        JsdocTypeNotNullable: (result, transform) => {
            const transformed = transform(result.element);
            transformed.nullable = false;
            return transformed;
        },
        JsdocTypeVariadic: (result, transform) => {
            if (result.element === undefined) {
                throw new Error('dots without value are not allowed in catharsis mode');
            }
            const transformed = transform(result.element);
            transformed.repeatable = true;
            return transformed;
        },
        JsdocTypeAny: () => ({
            type: 'AllLiteral'
        }),
        JsdocTypeNull: () => ({
            type: 'NullLiteral'
        }),
        JsdocTypeStringValue: result => makeName(quote(result.value, result.meta.quote)),
        JsdocTypeUndefined: () => ({
            type: 'UndefinedLiteral'
        }),
        JsdocTypeUnknown: () => ({
            type: 'UnknownLiteral'
        }),
        JsdocTypeFunction: (result, transform) => {
            const params = extractSpecialParams(result);
            const transformed = {
                type: 'FunctionType',
                params: params.params.map(transform)
            };
            if (params.this !== undefined) {
                transformed.this = transform(params.this);
            }
            if (params.new !== undefined) {
                transformed.new = transform(params.new);
            }
            if (result.returnType !== undefined) {
                transformed.result = transform(result.returnType);
            }
            return transformed;
        },
        JsdocTypeGeneric: (result, transform) => ({
            type: 'TypeApplication',
            applications: result.elements.map(o => transform(o)),
            expression: transform(result.left)
        }),
        JsdocTypeSpecialNamePath: result => makeName(result.specialType + ':' + quote(result.value, result.meta.quote)),
        JsdocTypeName: result => {
            if (result.value !== 'function') {
                return makeName(result.value);
            }
            else {
                return {
                    type: 'FunctionType',
                    params: []
                };
            }
        },
        JsdocTypeNumber: result => makeName(result.value.toString()),
        JsdocTypeObject: (result, transform) => {
            const transformed = {
                type: 'RecordType',
                fields: []
            };
            for (const field of result.elements) {
                if (field.type !== 'JsdocTypeObjectField' && field.type !== 'JsdocTypeJsdocObjectField') {
                    transformed.fields.push({
                        type: 'FieldType',
                        key: transform(field),
                        value: undefined
                    });
                }
                else {
                    transformed.fields.push(transform(field));
                }
            }
            return transformed;
        },
        JsdocTypeObjectField: (result, transform) => {
            if (typeof result.key !== 'string') {
                throw new Error('Index signatures and mapped types are not supported');
            }
            return {
                type: 'FieldType',
                key: makeName(quote(result.key, result.meta.quote)),
                value: result.right === undefined ? undefined : transform(result.right)
            };
        },
        JsdocTypeJsdocObjectField: (result, transform) => ({
            type: 'FieldType',
            key: transform(result.left),
            value: transform(result.right)
        }),
        JsdocTypeUnion: (result, transform) => ({
            type: 'TypeUnion',
            elements: result.elements.map(e => transform(e))
        }),
        JsdocTypeKeyValue: (result, transform) => {
            return {
                type: 'FieldType',
                key: makeName(result.key),
                value: result.right === undefined ? undefined : transform(result.right)
            };
        },
        JsdocTypeNamePath: (result, transform) => {
            const leftResult = transform(result.left);
            let rightValue;
            if (result.right.type === 'JsdocTypeSpecialNamePath') {
                rightValue = transform(result.right).name;
            }
            else {
                rightValue = quote(result.right.value, result.right.meta.quote);
            }
            const joiner = result.pathType === 'inner' ? '~' : result.pathType === 'instance' ? '#' : '.';
            return makeName(`${leftResult.name}${joiner}${rightValue}`);
        },
        JsdocTypeSymbol: result => {
            let value = '';
            let element = result.element;
            let trailingDots = false;
            if ((element === null || element === void 0 ? void 0 : element.type) === 'JsdocTypeVariadic') {
                if (element.meta.position === 'prefix') {
                    value = '...';
                }
                else {
                    trailingDots = true;
                }
                element = element.element;
            }
            if ((element === null || element === void 0 ? void 0 : element.type) === 'JsdocTypeName') {
                value += element.value;
            }
            else if ((element === null || element === void 0 ? void 0 : element.type) === 'JsdocTypeNumber') {
                value += element.value.toString();
            }
            if (trailingDots) {
                value += '...';
            }
            return makeName(`${result.value}(${value})`);
        },
        JsdocTypeParenthesis: (result, transform) => transform(assertRootResult(result.element)),
        JsdocTypeMappedType: notAvailableTransform,
        JsdocTypeIndexSignature: notAvailableTransform,
        JsdocTypeImport: notAvailableTransform,
        JsdocTypeKeyof: notAvailableTransform,
        JsdocTypeTuple: notAvailableTransform,
        JsdocTypeTypeof: notAvailableTransform,
        JsdocTypeIntersection: notAvailableTransform,
        JsdocTypeProperty: notAvailableTransform,
        JsdocTypePredicate: notAvailableTransform,
        JsdocTypeAsserts: notAvailableTransform
    };
    function catharsisTransform(result) {
        return transform(catharsisTransformRules, result);
    }

    function getQuoteStyle(quote) {
        switch (quote) {
            case undefined:
                return 'none';
            case 'single':
                return 'single';
            case 'double':
                return 'double';
        }
    }
    function getMemberType(type) {
        switch (type) {
            case 'inner':
                return 'INNER_MEMBER';
            case 'instance':
                return 'INSTANCE_MEMBER';
            case 'property':
                return 'MEMBER';
            case 'property-brackets':
                return 'MEMBER';
        }
    }
    function nestResults(type, results) {
        if (results.length === 2) {
            return {
                type,
                left: results[0],
                right: results[1]
            };
        }
        else {
            return {
                type,
                left: results[0],
                right: nestResults(type, results.slice(1))
            };
        }
    }
    const jtpRules = {
        JsdocTypeOptional: (result, transform) => ({
            type: 'OPTIONAL',
            value: transform(result.element),
            meta: {
                syntax: result.meta.position === 'prefix' ? 'PREFIX_EQUAL_SIGN' : 'SUFFIX_EQUALS_SIGN'
            }
        }),
        JsdocTypeNullable: (result, transform) => ({
            type: 'NULLABLE',
            value: transform(result.element),
            meta: {
                syntax: result.meta.position === 'prefix' ? 'PREFIX_QUESTION_MARK' : 'SUFFIX_QUESTION_MARK'
            }
        }),
        JsdocTypeNotNullable: (result, transform) => ({
            type: 'NOT_NULLABLE',
            value: transform(result.element),
            meta: {
                syntax: result.meta.position === 'prefix' ? 'PREFIX_BANG' : 'SUFFIX_BANG'
            }
        }),
        JsdocTypeVariadic: (result, transform) => {
            const transformed = {
                type: 'VARIADIC',
                meta: {
                    syntax: result.meta.position === 'prefix'
                        ? 'PREFIX_DOTS'
                        : result.meta.position === 'suffix' ? 'SUFFIX_DOTS' : 'ONLY_DOTS'
                }
            };
            if (result.element !== undefined) {
                transformed.value = transform(result.element);
            }
            return transformed;
        },
        JsdocTypeName: result => ({
            type: 'NAME',
            name: result.value
        }),
        JsdocTypeTypeof: (result, transform) => ({
            type: 'TYPE_QUERY',
            name: transform(result.element)
        }),
        JsdocTypeTuple: (result, transform) => ({
            type: 'TUPLE',
            entries: result.elements.map(transform)
        }),
        JsdocTypeKeyof: (result, transform) => ({
            type: 'KEY_QUERY',
            value: transform(result.element)
        }),
        JsdocTypeImport: result => ({
            type: 'IMPORT',
            path: {
                type: 'STRING_VALUE',
                quoteStyle: getQuoteStyle(result.element.meta.quote),
                string: result.element.value
            }
        }),
        JsdocTypeUndefined: () => ({
            type: 'NAME',
            name: 'undefined'
        }),
        JsdocTypeAny: () => ({
            type: 'ANY'
        }),
        JsdocTypeFunction: (result, transform) => {
            const specialParams = extractSpecialParams(result);
            const transformed = {
                type: result.arrow ? 'ARROW' : 'FUNCTION',
                params: specialParams.params.map(param => {
                    if (param.type === 'JsdocTypeKeyValue') {
                        if (param.right === undefined) {
                            throw new Error('Function parameter without \':\' is not expected to be \'KEY_VALUE\'');
                        }
                        return {
                            type: 'NAMED_PARAMETER',
                            name: param.key,
                            typeName: transform(param.right)
                        };
                    }
                    else {
                        return transform(param);
                    }
                }),
                new: null,
                returns: null
            };
            if (specialParams.this !== undefined) {
                transformed.this = transform(specialParams.this);
            }
            else if (!result.arrow) {
                transformed.this = null;
            }
            if (specialParams.new !== undefined) {
                transformed.new = transform(specialParams.new);
            }
            if (result.returnType !== undefined) {
                transformed.returns = transform(result.returnType);
            }
            return transformed;
        },
        JsdocTypeGeneric: (result, transform) => {
            const transformed = {
                type: 'GENERIC',
                subject: transform(result.left),
                objects: result.elements.map(transform),
                meta: {
                    syntax: result.meta.brackets === 'square' ? 'SQUARE_BRACKET' : result.meta.dot ? 'ANGLE_BRACKET_WITH_DOT' : 'ANGLE_BRACKET'
                }
            };
            if (result.meta.brackets === 'square' && result.elements[0].type === 'JsdocTypeFunction' && !result.elements[0].parenthesis) {
                transformed.objects[0] = {
                    type: 'NAME',
                    name: 'function'
                };
            }
            return transformed;
        },
        JsdocTypeObjectField: (result, transform) => {
            if (typeof result.key !== 'string') {
                throw new Error('Index signatures and mapped types are not supported');
            }
            if (result.right === undefined) {
                return {
                    type: 'RECORD_ENTRY',
                    key: result.key,
                    quoteStyle: getQuoteStyle(result.meta.quote),
                    value: null,
                    readonly: false
                };
            }
            let right = transform(result.right);
            if (result.optional) {
                right = {
                    type: 'OPTIONAL',
                    value: right,
                    meta: {
                        syntax: 'SUFFIX_KEY_QUESTION_MARK'
                    }
                };
            }
            return {
                type: 'RECORD_ENTRY',
                key: result.key.toString(),
                quoteStyle: getQuoteStyle(result.meta.quote),
                value: right,
                readonly: false
            };
        },
        JsdocTypeJsdocObjectField: () => {
            throw new Error('Keys may not be typed in jsdoctypeparser.');
        },
        JsdocTypeKeyValue: (result, transform) => {
            if (result.right === undefined) {
                return {
                    type: 'RECORD_ENTRY',
                    key: result.key,
                    quoteStyle: 'none',
                    value: null,
                    readonly: false
                };
            }
            let right = transform(result.right);
            if (result.optional) {
                right = {
                    type: 'OPTIONAL',
                    value: right,
                    meta: {
                        syntax: 'SUFFIX_KEY_QUESTION_MARK'
                    }
                };
            }
            return {
                type: 'RECORD_ENTRY',
                key: result.key,
                quoteStyle: 'none',
                value: right,
                readonly: false
            };
        },
        JsdocTypeObject: (result, transform) => {
            const entries = [];
            for (const field of result.elements) {
                if (field.type === 'JsdocTypeObjectField' || field.type === 'JsdocTypeJsdocObjectField') {
                    entries.push(transform(field));
                }
            }
            return {
                type: 'RECORD',
                entries
            };
        },
        JsdocTypeSpecialNamePath: result => {
            if (result.specialType !== 'module') {
                throw new Error(`jsdoctypeparser does not support type ${result.specialType} at this point.`);
            }
            return {
                type: 'MODULE',
                value: {
                    type: 'FILE_PATH',
                    quoteStyle: getQuoteStyle(result.meta.quote),
                    path: result.value
                }
            };
        },
        JsdocTypeNamePath: (result, transform) => {
            let hasEventPrefix = false;
            let name;
            let quoteStyle;
            if (result.right.type === 'JsdocTypeSpecialNamePath' && result.right.specialType === 'event') {
                hasEventPrefix = true;
                name = result.right.value;
                quoteStyle = getQuoteStyle(result.right.meta.quote);
            }
            else {
                name = result.right.value;
                quoteStyle = getQuoteStyle(result.right.meta.quote);
            }
            const transformed = {
                type: getMemberType(result.pathType),
                owner: transform(result.left),
                name,
                quoteStyle,
                hasEventPrefix
            };
            if (transformed.owner.type === 'MODULE') {
                const tModule = transformed.owner;
                transformed.owner = transformed.owner.value;
                tModule.value = transformed;
                return tModule;
            }
            else {
                return transformed;
            }
        },
        JsdocTypeUnion: (result, transform) => nestResults('UNION', result.elements.map(transform)),
        JsdocTypeParenthesis: (result, transform) => ({
            type: 'PARENTHESIS',
            value: transform(assertRootResult(result.element))
        }),
        JsdocTypeNull: () => ({
            type: 'NAME',
            name: 'null'
        }),
        JsdocTypeUnknown: () => ({
            type: 'UNKNOWN'
        }),
        JsdocTypeStringValue: result => ({
            type: 'STRING_VALUE',
            quoteStyle: getQuoteStyle(result.meta.quote),
            string: result.value
        }),
        JsdocTypeIntersection: (result, transform) => nestResults('INTERSECTION', result.elements.map(transform)),
        JsdocTypeNumber: result => ({
            type: 'NUMBER_VALUE',
            number: result.value.toString()
        }),
        JsdocTypeSymbol: notAvailableTransform,
        JsdocTypeProperty: notAvailableTransform,
        JsdocTypePredicate: notAvailableTransform,
        JsdocTypeMappedType: notAvailableTransform,
        JsdocTypeIndexSignature: notAvailableTransform,
        JsdocTypeAsserts: notAvailableTransform
    };
    function jtpTransform(result) {
        return transform(jtpRules, result);
    }

    function identityTransformRules() {
        return {
            JsdocTypeIntersection: (result, transform) => ({
                type: 'JsdocTypeIntersection',
                elements: result.elements.map(transform)
            }),
            JsdocTypeGeneric: (result, transform) => ({
                type: 'JsdocTypeGeneric',
                left: transform(result.left),
                elements: result.elements.map(transform),
                meta: {
                    dot: result.meta.dot,
                    brackets: result.meta.brackets
                }
            }),
            JsdocTypeNullable: result => result,
            JsdocTypeUnion: (result, transform) => ({
                type: 'JsdocTypeUnion',
                elements: result.elements.map(transform)
            }),
            JsdocTypeUnknown: result => result,
            JsdocTypeUndefined: result => result,
            JsdocTypeTypeof: (result, transform) => ({
                type: 'JsdocTypeTypeof',
                element: transform(result.element)
            }),
            JsdocTypeSymbol: (result, transform) => {
                const transformed = {
                    type: 'JsdocTypeSymbol',
                    value: result.value
                };
                if (result.element !== undefined) {
                    transformed.element = transform(result.element);
                }
                return transformed;
            },
            JsdocTypeOptional: (result, transform) => ({
                type: 'JsdocTypeOptional',
                element: transform(result.element),
                meta: {
                    position: result.meta.position
                }
            }),
            JsdocTypeObject: (result, transform) => ({
                type: 'JsdocTypeObject',
                meta: {
                    separator: 'comma'
                },
                elements: result.elements.map(transform)
            }),
            JsdocTypeNumber: result => result,
            JsdocTypeNull: result => result,
            JsdocTypeNotNullable: (result, transform) => ({
                type: 'JsdocTypeNotNullable',
                element: transform(result.element),
                meta: {
                    position: result.meta.position
                }
            }),
            JsdocTypeSpecialNamePath: result => result,
            JsdocTypeObjectField: (result, transform) => ({
                type: 'JsdocTypeObjectField',
                key: result.key,
                right: result.right === undefined ? undefined : transform(result.right),
                optional: result.optional,
                readonly: result.readonly,
                meta: result.meta
            }),
            JsdocTypeJsdocObjectField: (result, transform) => ({
                type: 'JsdocTypeJsdocObjectField',
                left: transform(result.left),
                right: transform(result.right)
            }),
            JsdocTypeKeyValue: (result, transform) => {
                return {
                    type: 'JsdocTypeKeyValue',
                    key: result.key,
                    right: result.right === undefined ? undefined : transform(result.right),
                    optional: result.optional,
                    variadic: result.variadic
                };
            },
            JsdocTypeImport: (result, transform) => ({
                type: 'JsdocTypeImport',
                element: transform(result.element)
            }),
            JsdocTypeAny: result => result,
            JsdocTypeStringValue: result => result,
            JsdocTypeNamePath: result => result,
            JsdocTypeVariadic: (result, transform) => {
                const transformed = {
                    type: 'JsdocTypeVariadic',
                    meta: {
                        position: result.meta.position,
                        squareBrackets: result.meta.squareBrackets
                    }
                };
                if (result.element !== undefined) {
                    transformed.element = transform(result.element);
                }
                return transformed;
            },
            JsdocTypeTuple: (result, transform) => ({
                type: 'JsdocTypeTuple',
                elements: result.elements.map(transform)
            }),
            JsdocTypeName: result => result,
            JsdocTypeFunction: (result, transform) => {
                const transformed = {
                    type: 'JsdocTypeFunction',
                    arrow: result.arrow,
                    parameters: result.parameters.map(transform),
                    constructor: result.constructor,
                    parenthesis: result.parenthesis
                };
                if (result.returnType !== undefined) {
                    transformed.returnType = transform(result.returnType);
                }
                return transformed;
            },
            JsdocTypeKeyof: (result, transform) => ({
                type: 'JsdocTypeKeyof',
                element: transform(result.element)
            }),
            JsdocTypeParenthesis: (result, transform) => ({
                type: 'JsdocTypeParenthesis',
                element: transform(result.element)
            }),
            JsdocTypeProperty: result => result,
            JsdocTypePredicate: (result, transform) => ({
                type: 'JsdocTypePredicate',
                left: transform(result.left),
                right: transform(result.right)
            }),
            JsdocTypeIndexSignature: (result, transform) => ({
                type: 'JsdocTypeIndexSignature',
                key: result.key,
                right: transform(result.right)
            }),
            JsdocTypeMappedType: (result, transform) => ({
                type: 'JsdocTypeMappedType',
                key: result.key,
                right: transform(result.right)
            }),
            JsdocTypeAsserts: (result, transform) => ({
                type: 'JsdocTypeAsserts',
                left: transform(result.left),
                right: transform(result.right)
            })
        };
    }

    const visitorKeys = {
        JsdocTypeAny: [],
        JsdocTypeFunction: ['parameters', 'returnType'],
        JsdocTypeGeneric: ['left', 'elements'],
        JsdocTypeImport: [],
        JsdocTypeIndexSignature: ['right'],
        JsdocTypeIntersection: ['elements'],
        JsdocTypeKeyof: ['element'],
        JsdocTypeKeyValue: ['right'],
        JsdocTypeMappedType: ['right'],
        JsdocTypeName: [],
        JsdocTypeNamePath: ['left', 'right'],
        JsdocTypeNotNullable: ['element'],
        JsdocTypeNull: [],
        JsdocTypeNullable: ['element'],
        JsdocTypeNumber: [],
        JsdocTypeObject: ['elements'],
        JsdocTypeObjectField: ['right'],
        JsdocTypeJsdocObjectField: ['left', 'right'],
        JsdocTypeOptional: ['element'],
        JsdocTypeParenthesis: ['element'],
        JsdocTypeSpecialNamePath: [],
        JsdocTypeStringValue: [],
        JsdocTypeSymbol: ['element'],
        JsdocTypeTuple: ['elements'],
        JsdocTypeTypeof: ['element'],
        JsdocTypeUndefined: [],
        JsdocTypeUnion: ['elements'],
        JsdocTypeUnknown: [],
        JsdocTypeVariadic: ['element'],
        JsdocTypeProperty: [],
        JsdocTypePredicate: ['left', 'right'],
        JsdocTypeAsserts: ['left', 'right']
    };

    function _traverse(node, parentNode, property, onEnter, onLeave) {
        onEnter === null || onEnter === void 0 ? void 0 : onEnter(node, parentNode, property);
        const keysToVisit = visitorKeys[node.type];
        for (const key of keysToVisit) {
            const value = node[key];
            if (value !== undefined) {
                if (Array.isArray(value)) {
                    for (const element of value) {
                        _traverse(element, node, key, onEnter, onLeave);
                    }
                }
                else {
                    _traverse(value, node, key, onEnter, onLeave);
                }
            }
        }
        onLeave === null || onLeave === void 0 ? void 0 : onLeave(node, parentNode, property);
    }
    /**
     * A function to traverse an AST. It traverses it depth first.
     * @param node the node to start traversing at.
     * @param onEnter node visitor function that will be called on entering the node. This corresponds to preorder traversing.
     * @param onLeave node visitor function that will be called on leaving the node. This corresponds to postorder traversing.
     */
    function traverse(node, onEnter, onLeave) {
        _traverse(node, undefined, undefined, onEnter, onLeave);
    }

    exports.catharsisTransform = catharsisTransform;
    exports.identityTransformRules = identityTransformRules;
    exports.jtpTransform = jtpTransform;
    exports.parse = parse;
    exports.stringify = stringify;
    exports.stringifyRules = stringifyRules;
    exports.transform = transform;
    exports.traverse = traverse;
    exports.tryParse = tryParse;
    exports.visitorKeys = visitorKeys;

}));


/***/ }),

/***/ "./node_modules/process/browser.js":
/*!*****************************************!*\
  !*** ./node_modules/process/browser.js ***!
  \*****************************************/
/***/ ((module) => {

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };


/***/ })

}]);
//# sourceMappingURL=vendors-node_modules_a.iframe.bundle.js.map