{"version":3,"file":"vendors-node_modules_a.iframe.bundle.js","mappings":";;;;;;;;;;;;;;;AAAA;;;;;;;;;;;;;;;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AClFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC/KA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AChIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACjDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACjCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;ACjBA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACvgFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sources":["webpack://motion-kit/./node_modules/@mdx-js/react/index.js","webpack://motion-kit/./node_modules/@mdx-js/react/lib/index.js","webpack://motion-kit/./node_modules/ansi-html-community/index.js","webpack://motion-kit/./node_modules/ansi-regex/index.js","webpack://motion-kit/./node_modules/html-entities/dist/commonjs/index.js","webpack://motion-kit/./node_modules/html-entities/dist/commonjs/named-references.js","webpack://motion-kit/./node_modules/html-entities/dist/commonjs/numeric-unicode-map.js","webpack://motion-kit/./node_modules/html-entities/dist/commonjs/surrogate-pairs.js","webpack://motion-kit/./node_modules/jsdoc-type-pratt-parser/dist/index.js","webpack://motion-kit/./node_modules/process/browser.js"],"sourcesContent":["export {MDXProvider, useMDXComponents} from './lib/index.js'\n","/**\n * @import {MDXComponents} from 'mdx/types.js'\n * @import {Component, ReactElement, ReactNode} from 'react'\n */\n\n/**\n * @callback MergeComponents\n *   Custom merge function.\n * @param {Readonly<MDXComponents>} currentComponents\n *   Current components from the context.\n * @returns {MDXComponents}\n *   Additional components.\n *\n * @typedef Props\n *   Configuration for `MDXProvider`.\n * @property {ReactNode | null | undefined} [children]\n *   Children (optional).\n * @property {Readonly<MDXComponents> | MergeComponents | null | undefined} [components]\n *   Additional components to use or a function that creates them (optional).\n * @property {boolean | null | undefined} [disableParentContext=false]\n *   Turn off outer component context (default: `false`).\n */\n\nimport React from 'react'\n\n/** @type {Readonly<MDXComponents>} */\nconst emptyComponents = {}\n\nconst MDXContext = React.createContext(emptyComponents)\n\n/**\n * Get current components from the MDX Context.\n *\n * @param {Readonly<MDXComponents> | MergeComponents | null | undefined} [components]\n *   Additional components to use or a function that creates them (optional).\n * @returns {MDXComponents}\n *   Current components.\n */\nexport function useMDXComponents(components) {\n  const contextComponents = React.useContext(MDXContext)\n\n  // Memoize to avoid unnecessary top-level context changes\n  return React.useMemo(\n    function () {\n      // Custom merge via a function prop\n      if (typeof components === 'function') {\n        return components(contextComponents)\n      }\n\n      return {...contextComponents, ...components}\n    },\n    [contextComponents, components]\n  )\n}\n\n/**\n * Provider for MDX context.\n *\n * @param {Readonly<Props>} properties\n *   Properties.\n * @returns {ReactElement}\n *   Element.\n * @satisfies {Component}\n */\nexport function MDXProvider(properties) {\n  /** @type {Readonly<MDXComponents>} */\n  let allComponents\n\n  if (properties.disableParentContext) {\n    allComponents =\n      typeof properties.components === 'function'\n        ? properties.components(emptyComponents)\n        : properties.components || emptyComponents\n  } else {\n    allComponents = useMDXComponents(properties.components)\n  }\n\n  return React.createElement(\n    MDXContext.Provider,\n    {value: allComponents},\n    properties.children\n  )\n}\n","'use strict'\n\nmodule.exports = ansiHTML\n\n// Reference to https://github.com/sindresorhus/ansi-regex\nvar _regANSI = /(?:(?:\\u001b\\[)|\\u009b)(?:(?:[0-9]{1,3})?(?:(?:;[0-9]{0,3})*)?[A-M|f-m])|\\u001b[A-M]/\n\nvar _defColors = {\n  reset: ['fff', '000'], // [FOREGROUD_COLOR, BACKGROUND_COLOR]\n  black: '000',\n  red: 'ff0000',\n  green: '209805',\n  yellow: 'e8bf03',\n  blue: '0000ff',\n  magenta: 'ff00ff',\n  cyan: '00ffee',\n  lightgrey: 'f0f0f0',\n  darkgrey: '888'\n}\nvar _styles = {\n  30: 'black',\n  31: 'red',\n  32: 'green',\n  33: 'yellow',\n  34: 'blue',\n  35: 'magenta',\n  36: 'cyan',\n  37: 'lightgrey'\n}\nvar _openTags = {\n  '1': 'font-weight:bold', // bold\n  '2': 'opacity:0.5', // dim\n  '3': '<i>', // italic\n  '4': '<u>', // underscore\n  '8': 'display:none', // hidden\n  '9': '<del>' // delete\n}\nvar _closeTags = {\n  '23': '</i>', // reset italic\n  '24': '</u>', // reset underscore\n  '29': '</del>' // reset delete\n}\n\n;[0, 21, 22, 27, 28, 39, 49].forEach(function (n) {\n  _closeTags[n] = '</span>'\n})\n\n/**\n * Converts text with ANSI color codes to HTML markup.\n * @param {String} text\n * @returns {*}\n */\nfunction ansiHTML (text) {\n  // Returns the text if the string has no ANSI escape code.\n  if (!_regANSI.test(text)) {\n    return text\n  }\n\n  // Cache opened sequence.\n  var ansiCodes = []\n  // Replace with markup.\n  var ret = text.replace(/\\033\\[(\\d+)m/g, function (match, seq) {\n    var ot = _openTags[seq]\n    if (ot) {\n      // If current sequence has been opened, close it.\n      if (!!~ansiCodes.indexOf(seq)) { // eslint-disable-line no-extra-boolean-cast\n        ansiCodes.pop()\n        return '</span>'\n      }\n      // Open tag.\n      ansiCodes.push(seq)\n      return ot[0] === '<' ? ot : '<span style=\"' + ot + ';\">'\n    }\n\n    var ct = _closeTags[seq]\n    if (ct) {\n      // Pop sequence\n      ansiCodes.pop()\n      return ct\n    }\n    return ''\n  })\n\n  // Make sure tags are closed.\n  var l = ansiCodes.length\n  ;(l > 0) && (ret += Array(l + 1).join('</span>'))\n\n  return ret\n}\n\n/**\n * Customize colors.\n * @param {Object} colors reference to _defColors\n */\nansiHTML.setColors = function (colors) {\n  if (typeof colors !== 'object') {\n    throw new Error('`colors` parameter must be an Object.')\n  }\n\n  var _finalColors = {}\n  for (var key in _defColors) {\n    var hex = colors.hasOwnProperty(key) ? colors[key] : null\n    if (!hex) {\n      _finalColors[key] = _defColors[key]\n      continue\n    }\n    if ('reset' === key) {\n      if (typeof hex === 'string') {\n        hex = [hex]\n      }\n      if (!Array.isArray(hex) || hex.length === 0 || hex.some(function (h) {\n        return typeof h !== 'string'\n      })) {\n        throw new Error('The value of `' + key + '` property must be an Array and each item could only be a hex string, e.g.: FF0000')\n      }\n      var defHexColor = _defColors[key]\n      if (!hex[0]) {\n        hex[0] = defHexColor[0]\n      }\n      if (hex.length === 1 || !hex[1]) {\n        hex = [hex[0]]\n        hex.push(defHexColor[1])\n      }\n\n      hex = hex.slice(0, 2)\n    } else if (typeof hex !== 'string') {\n      throw new Error('The value of `' + key + '` property must be a hex string, e.g.: FF0000')\n    }\n    _finalColors[key] = hex\n  }\n  _setTags(_finalColors)\n}\n\n/**\n * Reset colors.\n */\nansiHTML.reset = function () {\n  _setTags(_defColors)\n}\n\n/**\n * Expose tags, including open and close.\n * @type {Object}\n */\nansiHTML.tags = {}\n\nif (Object.defineProperty) {\n  Object.defineProperty(ansiHTML.tags, 'open', {\n    get: function () { return _openTags }\n  })\n  Object.defineProperty(ansiHTML.tags, 'close', {\n    get: function () { return _closeTags }\n  })\n} else {\n  ansiHTML.tags.open = _openTags\n  ansiHTML.tags.close = _closeTags\n}\n\nfunction _setTags (colors) {\n  // reset all\n  _openTags['0'] = 'font-weight:normal;opacity:1;color:#' + colors.reset[0] + ';background:#' + colors.reset[1]\n  // inverse\n  _openTags['7'] = 'color:#' + colors.reset[1] + ';background:#' + colors.reset[0]\n  // dark grey\n  _openTags['90'] = 'color:#' + colors.darkgrey\n\n  for (var code in _styles) {\n    var color = _styles[code]\n    var oriColor = colors[color] || '000'\n    _openTags[code] = 'color:#' + oriColor\n    code = parseInt(code)\n    _openTags[(code + 10).toString()] = 'background:#' + oriColor\n  }\n}\n\nansiHTML.reset()\n","'use strict';\n\nmodule.exports = ({onlyFirst = false} = {}) => {\n\tconst pattern = [\n\t\t'[\\\\u001B\\\\u009B][[\\\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\\\d\\\\/#&.:=?%@~_]+)*|[a-zA-Z\\\\d]+(?:;[-a-zA-Z\\\\d\\\\/#&.:=?%@~_]*)*)?\\\\u0007)',\n\t\t'(?:(?:\\\\d{1,4}(?:;\\\\d{0,4})*)?[\\\\dA-PR-TZcf-ntqry=><~]))'\n\t].join('|');\n\n\treturn new RegExp(pattern, onlyFirst ? undefined : 'g');\n};\n","\"use strict\";\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.encode = encode;\nexports.decodeEntity = decodeEntity;\nexports.decode = decode;\nvar named_references_js_1 = require(\"./named-references.js\");\nvar numeric_unicode_map_js_1 = require(\"./numeric-unicode-map.js\");\nvar surrogate_pairs_js_1 = require(\"./surrogate-pairs.js\");\nvar allNamedReferences = __assign(__assign({}, named_references_js_1.namedReferences), { all: named_references_js_1.namedReferences.html5 });\nvar encodeRegExps = {\n    specialChars: /[<>'\"&]/g,\n    nonAscii: /[<>'\"&\\u0080-\\uD7FF\\uE000-\\uFFFF\\uDC00-\\uDFFF]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]?/g,\n    nonAsciiPrintable: /[<>'\"&\\x01-\\x08\\x11-\\x15\\x17-\\x1F\\x7f-\\uD7FF\\uE000-\\uFFFF\\uDC00-\\uDFFF]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]?/g,\n    nonAsciiPrintableOnly: /[\\x01-\\x08\\x11-\\x15\\x17-\\x1F\\x7f-\\uD7FF\\uE000-\\uFFFF\\uDC00-\\uDFFF]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]?/g,\n    extensive: /[\\x01-\\x0c\\x0e-\\x1f\\x21-\\x2c\\x2e-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\x7d\\x7f-\\uD7FF\\uE000-\\uFFFF\\uDC00-\\uDFFF]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]?/g\n};\nvar defaultEncodeOptions = {\n    mode: 'specialChars',\n    level: 'all',\n    numeric: 'decimal'\n};\n/** Encodes all the necessary (specified by `level`) characters in the text */\nfunction encode(text, _a) {\n    var _b = _a === void 0 ? defaultEncodeOptions : _a, _c = _b.mode, mode = _c === void 0 ? 'specialChars' : _c, _d = _b.numeric, numeric = _d === void 0 ? 'decimal' : _d, _e = _b.level, level = _e === void 0 ? 'all' : _e;\n    if (!text) {\n        return '';\n    }\n    var encodeRegExp = encodeRegExps[mode];\n    var references = allNamedReferences[level].characters;\n    var isHex = numeric === 'hexadecimal';\n    return String.prototype.replace.call(text, encodeRegExp, function (input) {\n        var result = references[input];\n        if (!result) {\n            var code = input.length > 1 ? (0, surrogate_pairs_js_1.getCodePoint)(input, 0) : input.charCodeAt(0);\n            result = (isHex ? '&#x' + code.toString(16) : '&#' + code) + ';';\n        }\n        return result;\n    });\n}\nvar defaultDecodeOptions = {\n    scope: 'body',\n    level: 'all'\n};\nvar strict = /&(?:#\\d+|#[xX][\\da-fA-F]+|[0-9a-zA-Z]+);/g;\nvar attribute = /&(?:#\\d+|#[xX][\\da-fA-F]+|[0-9a-zA-Z]+)[;=]?/g;\nvar baseDecodeRegExps = {\n    xml: {\n        strict: strict,\n        attribute: attribute,\n        body: named_references_js_1.bodyRegExps.xml\n    },\n    html4: {\n        strict: strict,\n        attribute: attribute,\n        body: named_references_js_1.bodyRegExps.html4\n    },\n    html5: {\n        strict: strict,\n        attribute: attribute,\n        body: named_references_js_1.bodyRegExps.html5\n    }\n};\nvar decodeRegExps = __assign(__assign({}, baseDecodeRegExps), { all: baseDecodeRegExps.html5 });\nvar fromCharCode = String.fromCharCode;\nvar outOfBoundsChar = fromCharCode(65533);\nvar defaultDecodeEntityOptions = {\n    level: 'all'\n};\nfunction getDecodedEntity(entity, references, isAttribute, isStrict) {\n    var decodeResult = entity;\n    var decodeEntityLastChar = entity[entity.length - 1];\n    if (isAttribute && decodeEntityLastChar === '=') {\n        decodeResult = entity;\n    }\n    else if (isStrict && decodeEntityLastChar !== ';') {\n        decodeResult = entity;\n    }\n    else {\n        var decodeResultByReference = references[entity];\n        if (decodeResultByReference) {\n            decodeResult = decodeResultByReference;\n        }\n        else if (entity[0] === '&' && entity[1] === '#') {\n            var decodeSecondChar = entity[2];\n            var decodeCode = decodeSecondChar == 'x' || decodeSecondChar == 'X'\n                ? parseInt(entity.substr(3), 16)\n                : parseInt(entity.substr(2));\n            decodeResult =\n                decodeCode >= 0x10ffff\n                    ? outOfBoundsChar\n                    : decodeCode > 65535\n                        ? (0, surrogate_pairs_js_1.fromCodePoint)(decodeCode)\n                        : fromCharCode(numeric_unicode_map_js_1.numericUnicodeMap[decodeCode] || decodeCode);\n        }\n    }\n    return decodeResult;\n}\n/** Decodes a single entity */\nfunction decodeEntity(entity, _a) {\n    var _b = _a === void 0 ? defaultDecodeEntityOptions : _a, _c = _b.level, level = _c === void 0 ? 'all' : _c;\n    if (!entity) {\n        return '';\n    }\n    return getDecodedEntity(entity, allNamedReferences[level].entities, false, false);\n}\n/** Decodes all entities in the text */\nfunction decode(text, _a) {\n    var _b = _a === void 0 ? defaultDecodeOptions : _a, _c = _b.level, level = _c === void 0 ? 'all' : _c, _d = _b.scope, scope = _d === void 0 ? level === 'xml' ? 'strict' : 'body' : _d;\n    if (!text) {\n        return '';\n    }\n    var decodeRegExp = decodeRegExps[level][scope];\n    var references = allNamedReferences[level].entities;\n    var isAttribute = scope === 'attribute';\n    var isStrict = scope === 'strict';\n    return text.replace(decodeRegExp, function (entity) { return getDecodedEntity(entity, references, isAttribute, isStrict); });\n}\n//# sourceMappingURL=index.js.map","\"use strict\";\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.namedReferences = exports.bodyRegExps = void 0;\n// This file is autogenerated by tools/process-named-references.ts\nvar pairDivider = \"~\";\nvar blockDivider = \"~~\";\nfunction generateNamedReferences(input, prev) {\n    var entities = {};\n    var characters = {};\n    var blocks = input.split(blockDivider);\n    var isOptionalBlock = false;\n    for (var i = 0; blocks.length > i; i++) {\n        var entries = blocks[i].split(pairDivider);\n        for (var j = 0; j < entries.length; j += 2) {\n            var entity = entries[j];\n            var character = entries[j + 1];\n            var fullEntity = '&' + entity + ';';\n            entities[fullEntity] = character;\n            if (isOptionalBlock) {\n                entities['&' + entity] = character;\n            }\n            characters[character] = fullEntity;\n        }\n        isOptionalBlock = true;\n    }\n    return prev ?\n        { entities: __assign(__assign({}, entities), prev.entities), characters: __assign(__assign({}, characters), prev.characters) } :\n        { entities: entities, characters: characters };\n}\nexports.bodyRegExps = {\n    xml: /&(?:#\\d+|#[xX][\\da-fA-F]+|[0-9a-zA-Z]+);?/g,\n    html4: /&notin;|&(?:nbsp|iexcl|cent|pound|curren|yen|brvbar|sect|uml|copy|ordf|laquo|not|shy|reg|macr|deg|plusmn|sup2|sup3|acute|micro|para|middot|cedil|sup1|ordm|raquo|frac14|frac12|frac34|iquest|Agrave|Aacute|Acirc|Atilde|Auml|Aring|AElig|Ccedil|Egrave|Eacute|Ecirc|Euml|Igrave|Iacute|Icirc|Iuml|ETH|Ntilde|Ograve|Oacute|Ocirc|Otilde|Ouml|times|Oslash|Ugrave|Uacute|Ucirc|Uuml|Yacute|THORN|szlig|agrave|aacute|acirc|atilde|auml|aring|aelig|ccedil|egrave|eacute|ecirc|euml|igrave|iacute|icirc|iuml|eth|ntilde|ograve|oacute|ocirc|otilde|ouml|divide|oslash|ugrave|uacute|ucirc|uuml|yacute|thorn|yuml|quot|amp|lt|gt|#\\d+|#[xX][\\da-fA-F]+|[0-9a-zA-Z]+);?/g,\n    html5: /&centerdot;|&copysr;|&divideontimes;|&gtcc;|&gtcir;|&gtdot;|&gtlPar;|&gtquest;|&gtrapprox;|&gtrarr;|&gtrdot;|&gtreqless;|&gtreqqless;|&gtrless;|&gtrsim;|&ltcc;|&ltcir;|&ltdot;|&lthree;|&ltimes;|&ltlarr;|&ltquest;|&ltrPar;|&ltri;|&ltrie;|&ltrif;|&notin;|&notinE;|&notindot;|&notinva;|&notinvb;|&notinvc;|&notni;|&notniva;|&notnivb;|&notnivc;|&parallel;|&timesb;|&timesbar;|&timesd;|&(?:AElig|AMP|Aacute|Acirc|Agrave|Aring|Atilde|Auml|COPY|Ccedil|ETH|Eacute|Ecirc|Egrave|Euml|GT|Iacute|Icirc|Igrave|Iuml|LT|Ntilde|Oacute|Ocirc|Ograve|Oslash|Otilde|Ouml|QUOT|REG|THORN|Uacute|Ucirc|Ugrave|Uuml|Yacute|aacute|acirc|acute|aelig|agrave|amp|aring|atilde|auml|brvbar|ccedil|cedil|cent|copy|curren|deg|divide|eacute|ecirc|egrave|eth|euml|frac12|frac14|frac34|gt|iacute|icirc|iexcl|igrave|iquest|iuml|laquo|lt|macr|micro|middot|nbsp|not|ntilde|oacute|ocirc|ograve|ordf|ordm|oslash|otilde|ouml|para|plusmn|pound|quot|raquo|reg|sect|shy|sup1|sup2|sup3|szlig|thorn|times|uacute|ucirc|ugrave|uml|uuml|yacute|yen|yuml|#\\d+|#[xX][\\da-fA-F]+|[0-9a-zA-Z]+);?/g\n};\nexports.namedReferences = {};\nexports.namedReferences['xml'] = generateNamedReferences(\"lt~<~gt~>~quot~\\\"~apos~'~amp~&\");\nexports.namedReferences['html4'] = generateNamedReferences(\"apos~'~OElig~≈í~oelig~≈ì~Scaron~≈†~scaron~≈°~Yuml~≈∏~circ~ÀÜ~tilde~Àú~ensp~‚ÄÇ~emsp~‚ÄÉ~thinsp~‚Äâ~zwnj~‚Äå~zwj~‚Äç~lrm~‚Äé~rlm~‚Äè~ndash~‚Äì~mdash~‚Äî~lsquo~‚Äò~rsquo~‚Äô~sbquo~‚Äö~ldquo~‚Äú~rdquo~‚Äù~bdquo~‚Äû~dagger~‚Ä†~Dagger~‚Ä°~permil~‚Ä∞~lsaquo~‚Äπ~rsaquo~‚Ä∫~euro~‚Ç¨~fnof~∆í~Alpha~Œë~Beta~Œí~Gamma~Œì~Delta~Œî~Epsilon~Œï~Zeta~Œñ~Eta~Œó~Theta~Œò~Iota~Œô~Kappa~Œö~Lambda~Œõ~Mu~Œú~Nu~Œù~Xi~Œû~Omicron~Œü~Pi~Œ†~Rho~Œ°~Sigma~Œ£~Tau~Œ§~Upsilon~Œ•~Phi~Œ¶~Chi~Œß~Psi~Œ®~Omega~Œ©~alpha~Œ±~beta~Œ≤~gamma~Œ≥~delta~Œ¥~epsilon~Œµ~zeta~Œ∂~eta~Œ∑~theta~Œ∏~iota~Œπ~kappa~Œ∫~lambda~Œª~mu~Œº~nu~ŒΩ~xi~Œæ~omicron~Œø~pi~œÄ~rho~œÅ~sigmaf~œÇ~sigma~œÉ~tau~œÑ~upsilon~œÖ~phi~œÜ~chi~œá~psi~œà~omega~œâ~thetasym~œë~upsih~œí~piv~œñ~bull~‚Ä¢~hellip~‚Ä¶~prime~‚Ä≤~Prime~‚Ä≥~oline~‚Äæ~frasl~‚ÅÑ~weierp~‚Ñò~image~‚Ñë~real~‚Ñú~trade~‚Ñ¢~alefsym~‚Ñµ~larr~‚Üê~uarr~‚Üë~rarr~‚Üí~darr~‚Üì~harr~‚Üî~crarr~‚Üµ~lArr~‚áê~uArr~‚áë~rArr~‚áí~dArr~‚áì~hArr~‚áî~forall~‚àÄ~part~‚àÇ~exist~‚àÉ~empty~‚àÖ~nabla~‚àá~isin~‚àà~notin~‚àâ~ni~‚àã~prod~‚àè~sum~‚àë~minus~‚àí~lowast~‚àó~radic~‚àö~prop~‚àù~infin~‚àû~ang~‚à†~and~‚àß~or~‚à®~cap~‚à©~cup~‚à™~int~‚à´~there4~‚à¥~sim~‚àº~cong~‚âÖ~asymp~‚âà~ne~‚â†~equiv~‚â°~le~‚â§~ge~‚â•~sub~‚äÇ~sup~‚äÉ~nsub~‚äÑ~sube~‚äÜ~supe~‚äá~oplus~‚äï~otimes~‚äó~perp~‚ä•~sdot~‚ãÖ~lceil~‚åà~rceil~‚åâ~lfloor~‚åä~rfloor~‚åã~lang~‚å©~rang~‚å™~loz~‚óä~spades~‚ô†~clubs~‚ô£~hearts~‚ô•~diams~‚ô¶~~nbsp~¬†~iexcl~¬°~cent~¬¢~pound~¬£~curren~¬§~yen~¬•~brvbar~¬¶~sect~¬ß~uml~¬®~copy~¬©~ordf~¬™~laquo~¬´~not~¬¨~shy~¬≠~reg~¬Æ~macr~¬Ø~deg~¬∞~plusmn~¬±~sup2~¬≤~sup3~¬≥~acute~¬¥~micro~¬µ~para~¬∂~middot~¬∑~cedil~¬∏~sup1~¬π~ordm~¬∫~raquo~¬ª~frac14~¬º~frac12~¬Ω~frac34~¬æ~iquest~¬ø~Agrave~√Ä~Aacute~√Å~Acirc~√Ç~Atilde~√É~Auml~√Ñ~Aring~√Ö~AElig~√Ü~Ccedil~√á~Egrave~√à~Eacute~√â~Ecirc~√ä~Euml~√ã~Igrave~√å~Iacute~√ç~Icirc~√é~Iuml~√è~ETH~√ê~Ntilde~√ë~Ograve~√í~Oacute~√ì~Ocirc~√î~Otilde~√ï~Ouml~√ñ~times~√ó~Oslash~√ò~Ugrave~√ô~Uacute~√ö~Ucirc~√õ~Uuml~√ú~Yacute~√ù~THORN~√û~szlig~√ü~agrave~√†~aacute~√°~acirc~√¢~atilde~√£~auml~√§~aring~√•~aelig~√¶~ccedil~√ß~egrave~√®~eacute~√©~ecirc~√™~euml~√´~igrave~√¨~iacute~√≠~icirc~√Æ~iuml~√Ø~eth~√∞~ntilde~√±~ograve~√≤~oacute~√≥~ocirc~√¥~otilde~√µ~ouml~√∂~divide~√∑~oslash~√∏~ugrave~√π~uacute~√∫~ucirc~√ª~uuml~√º~yacute~√Ω~thorn~√æ~yuml~√ø~quot~\\\"~amp~&~lt~<~gt~>\");\nexports.namedReferences['html5'] = generateNamedReferences(\"Abreve~ƒÇ~Acy~–ê~Afr~ùîÑ~Amacr~ƒÄ~And~‚©ì~Aogon~ƒÑ~Aopf~ùî∏~ApplyFunction~‚Å°~Ascr~ùíú~Assign~‚âî~Backslash~‚àñ~Barv~‚´ß~Barwed~‚åÜ~Bcy~–ë~Because~‚àµ~Bernoullis~‚Ñ¨~Bfr~ùîÖ~Bopf~ùîπ~Breve~Àò~Bscr~‚Ñ¨~Bumpeq~‚âé~CHcy~–ß~Cacute~ƒÜ~Cap~‚ãí~CapitalDifferentialD~‚ÖÖ~Cayleys~‚Ñ≠~Ccaron~ƒå~Ccirc~ƒà~Cconint~‚à∞~Cdot~ƒä~Cedilla~¬∏~CenterDot~¬∑~Cfr~‚Ñ≠~CircleDot~‚äô~CircleMinus~‚äñ~CirclePlus~‚äï~CircleTimes~‚äó~ClockwiseContourIntegral~‚à≤~CloseCurlyDoubleQuote~‚Äù~CloseCurlyQuote~‚Äô~Colon~‚à∑~Colone~‚©¥~Congruent~‚â°~Conint~‚àØ~ContourIntegral~‚àÆ~Copf~‚ÑÇ~Coproduct~‚àê~CounterClockwiseContourIntegral~‚à≥~Cross~‚®Ø~Cscr~ùíû~Cup~‚ãì~CupCap~‚âç~DD~‚ÖÖ~DDotrahd~‚§ë~DJcy~–Ç~DScy~–Ö~DZcy~–è~Darr~‚Ü°~Dashv~‚´§~Dcaron~ƒé~Dcy~–î~Del~‚àá~Dfr~ùîá~DiacriticalAcute~¬¥~DiacriticalDot~Àô~DiacriticalDoubleAcute~Àù~DiacriticalGrave~`~DiacriticalTilde~Àú~Diamond~‚ãÑ~DifferentialD~‚ÖÜ~Dopf~ùîª~Dot~¬®~DotDot~‚Éú~DotEqual~‚âê~DoubleContourIntegral~‚àØ~DoubleDot~¬®~DoubleDownArrow~‚áì~DoubleLeftArrow~‚áê~DoubleLeftRightArrow~‚áî~DoubleLeftTee~‚´§~DoubleLongLeftArrow~‚ü∏~DoubleLongLeftRightArrow~‚ü∫~DoubleLongRightArrow~‚üπ~DoubleRightArrow~‚áí~DoubleRightTee~‚ä®~DoubleUpArrow~‚áë~DoubleUpDownArrow~‚áï~DoubleVerticalBar~‚à•~DownArrow~‚Üì~DownArrowBar~‚§ì~DownArrowUpArrow~‚áµ~DownBreve~Ãë~DownLeftRightVector~‚•ê~DownLeftTeeVector~‚•û~DownLeftVector~‚ÜΩ~DownLeftVectorBar~‚•ñ~DownRightTeeVector~‚•ü~DownRightVector~‚áÅ~DownRightVectorBar~‚•ó~DownTee~‚ä§~DownTeeArrow~‚Üß~Downarrow~‚áì~Dscr~ùíü~Dstrok~ƒê~ENG~≈ä~Ecaron~ƒö~Ecy~–≠~Edot~ƒñ~Efr~ùîà~Element~‚àà~Emacr~ƒí~EmptySmallSquare~‚óª~EmptyVerySmallSquare~‚ñ´~Eogon~ƒò~Eopf~ùîº~Equal~‚©µ~EqualTilde~‚âÇ~Equilibrium~‚áå~Escr~‚Ñ∞~Esim~‚©≥~Exists~‚àÉ~ExponentialE~‚Öá~Fcy~–§~Ffr~ùîâ~FilledSmallSquare~‚óº~FilledVerySmallSquare~‚ñ™~Fopf~ùîΩ~ForAll~‚àÄ~Fouriertrf~‚Ñ±~Fscr~‚Ñ±~GJcy~–É~Gammad~œú~Gbreve~ƒû~Gcedil~ƒ¢~Gcirc~ƒú~Gcy~–ì~Gdot~ƒ†~Gfr~ùîä~Gg~‚ãô~Gopf~ùîæ~GreaterEqual~‚â•~GreaterEqualLess~‚ãõ~GreaterFullEqual~‚âß~GreaterGreater~‚™¢~GreaterLess~‚â∑~GreaterSlantEqual~‚©æ~GreaterTilde~‚â≥~Gscr~ùí¢~Gt~‚â´~HARDcy~–™~Hacek~Àá~Hat~^~Hcirc~ƒ§~Hfr~‚Ñå~HilbertSpace~‚Ñã~Hopf~‚Ñç~HorizontalLine~‚îÄ~Hscr~‚Ñã~Hstrok~ƒ¶~HumpDownHump~‚âé~HumpEqual~‚âè~IEcy~–ï~IJlig~ƒ≤~IOcy~–Å~Icy~–ò~Idot~ƒ∞~Ifr~‚Ñë~Im~‚Ñë~Imacr~ƒ™~ImaginaryI~‚Öà~Implies~‚áí~Int~‚à¨~Integral~‚à´~Intersection~‚ãÇ~InvisibleComma~‚Å£~InvisibleTimes~‚Å¢~Iogon~ƒÆ~Iopf~ùïÄ~Iscr~‚Ñê~Itilde~ƒ®~Iukcy~–Ü~Jcirc~ƒ¥~Jcy~–ô~Jfr~ùîç~Jopf~ùïÅ~Jscr~ùí•~Jsercy~–à~Jukcy~–Ñ~KHcy~–•~KJcy~–å~Kcedil~ƒ∂~Kcy~–ö~Kfr~ùîé~Kopf~ùïÇ~Kscr~ùí¶~LJcy~–â~Lacute~ƒπ~Lang~‚ü™~Laplacetrf~‚Ñí~Larr~‚Üû~Lcaron~ƒΩ~Lcedil~ƒª~Lcy~–õ~LeftAngleBracket~‚ü®~LeftArrow~‚Üê~LeftArrowBar~‚á§~LeftArrowRightArrow~‚áÜ~LeftCeiling~‚åà~LeftDoubleBracket~‚ü¶~LeftDownTeeVector~‚•°~LeftDownVector~‚áÉ~LeftDownVectorBar~‚•ô~LeftFloor~‚åä~LeftRightArrow~‚Üî~LeftRightVector~‚•é~LeftTee~‚ä£~LeftTeeArrow~‚Ü§~LeftTeeVector~‚•ö~LeftTriangle~‚ä≤~LeftTriangleBar~‚ßè~LeftTriangleEqual~‚ä¥~LeftUpDownVector~‚•ë~LeftUpTeeVector~‚•†~LeftUpVector~‚Üø~LeftUpVectorBar~‚•ò~LeftVector~‚Üº~LeftVectorBar~‚•í~Leftarrow~‚áê~Leftrightarrow~‚áî~LessEqualGreater~‚ãö~LessFullEqual~‚â¶~LessGreater~‚â∂~LessLess~‚™°~LessSlantEqual~‚©Ω~LessTilde~‚â≤~Lfr~ùîè~Ll~‚ãò~Lleftarrow~‚áö~Lmidot~ƒø~LongLeftArrow~‚üµ~LongLeftRightArrow~‚ü∑~LongRightArrow~‚ü∂~Longleftarrow~‚ü∏~Longleftrightarrow~‚ü∫~Longrightarrow~‚üπ~Lopf~ùïÉ~LowerLeftArrow~‚Üô~LowerRightArrow~‚Üò~Lscr~‚Ñí~Lsh~‚Ü∞~Lstrok~≈Å~Lt~‚â™~Map~‚§Ö~Mcy~–ú~MediumSpace~‚Åü~Mellintrf~‚Ñ≥~Mfr~ùîê~MinusPlus~‚àì~Mopf~ùïÑ~Mscr~‚Ñ≥~NJcy~–ä~Nacute~≈É~Ncaron~≈á~Ncedil~≈Ö~Ncy~–ù~NegativeMediumSpace~‚Äã~NegativeThickSpace~‚Äã~NegativeThinSpace~‚Äã~NegativeVeryThinSpace~‚Äã~NestedGreaterGreater~‚â´~NestedLessLess~‚â™~NewLine~\\n~Nfr~ùîë~NoBreak~‚Å†~NonBreakingSpace~¬†~Nopf~‚Ñï~Not~‚´¨~NotCongruent~‚â¢~NotCupCap~‚â≠~NotDoubleVerticalBar~‚à¶~NotElement~‚àâ~NotEqual~‚â†~NotEqualTilde~‚âÇÃ∏~NotExists~‚àÑ~NotGreater~‚âØ~NotGreaterEqual~‚â±~NotGreaterFullEqual~‚âßÃ∏~NotGreaterGreater~‚â´Ã∏~NotGreaterLess~‚âπ~NotGreaterSlantEqual~‚©æÃ∏~NotGreaterTilde~‚âµ~NotHumpDownHump~‚âéÃ∏~NotHumpEqual~‚âèÃ∏~NotLeftTriangle~‚ã™~NotLeftTriangleBar~‚ßèÃ∏~NotLeftTriangleEqual~‚ã¨~NotLess~‚âÆ~NotLessEqual~‚â∞~NotLessGreater~‚â∏~NotLessLess~‚â™Ã∏~NotLessSlantEqual~‚©ΩÃ∏~NotLessTilde~‚â¥~NotNestedGreaterGreater~‚™¢Ã∏~NotNestedLessLess~‚™°Ã∏~NotPrecedes~‚äÄ~NotPrecedesEqual~‚™ØÃ∏~NotPrecedesSlantEqual~‚ã†~NotReverseElement~‚àå~NotRightTriangle~‚ã´~NotRightTriangleBar~‚ßêÃ∏~NotRightTriangleEqual~‚ã≠~NotSquareSubset~‚äèÃ∏~NotSquareSubsetEqual~‚ã¢~NotSquareSuperset~‚äêÃ∏~NotSquareSupersetEqual~‚ã£~NotSubset~‚äÇ‚Éí~NotSubsetEqual~‚äà~NotSucceeds~‚äÅ~NotSucceedsEqual~‚™∞Ã∏~NotSucceedsSlantEqual~‚ã°~NotSucceedsTilde~‚âøÃ∏~NotSuperset~‚äÉ‚Éí~NotSupersetEqual~‚äâ~NotTilde~‚âÅ~NotTildeEqual~‚âÑ~NotTildeFullEqual~‚âá~NotTildeTilde~‚ââ~NotVerticalBar~‚à§~Nscr~ùí©~Ocy~–û~Odblac~≈ê~Ofr~ùîí~Omacr~≈å~Oopf~ùïÜ~OpenCurlyDoubleQuote~‚Äú~OpenCurlyQuote~‚Äò~Or~‚©î~Oscr~ùí™~Otimes~‚®∑~OverBar~‚Äæ~OverBrace~‚èû~OverBracket~‚é¥~OverParenthesis~‚èú~PartialD~‚àÇ~Pcy~–ü~Pfr~ùîì~PlusMinus~¬±~Poincareplane~‚Ñå~Popf~‚Ñô~Pr~‚™ª~Precedes~‚â∫~PrecedesEqual~‚™Ø~PrecedesSlantEqual~‚âº~PrecedesTilde~‚âæ~Product~‚àè~Proportion~‚à∑~Proportional~‚àù~Pscr~ùí´~Qfr~ùîî~Qopf~‚Ñö~Qscr~ùí¨~RBarr~‚§ê~Racute~≈î~Rang~‚ü´~Rarr~‚Ü†~Rarrtl~‚§ñ~Rcaron~≈ò~Rcedil~≈ñ~Rcy~–†~Re~‚Ñú~ReverseElement~‚àã~ReverseEquilibrium~‚áã~ReverseUpEquilibrium~‚•Ø~Rfr~‚Ñú~RightAngleBracket~‚ü©~RightArrow~‚Üí~RightArrowBar~‚á•~RightArrowLeftArrow~‚áÑ~RightCeiling~‚åâ~RightDoubleBracket~‚üß~RightDownTeeVector~‚•ù~RightDownVector~‚áÇ~RightDownVectorBar~‚•ï~RightFloor~‚åã~RightTee~‚ä¢~RightTeeArrow~‚Ü¶~RightTeeVector~‚•õ~RightTriangle~‚ä≥~RightTriangleBar~‚ßê~RightTriangleEqual~‚äµ~RightUpDownVector~‚•è~RightUpTeeVector~‚•ú~RightUpVector~‚Üæ~RightUpVectorBar~‚•î~RightVector~‚áÄ~RightVectorBar~‚•ì~Rightarrow~‚áí~Ropf~‚Ñù~RoundImplies~‚•∞~Rrightarrow~‚áõ~Rscr~‚Ñõ~Rsh~‚Ü±~RuleDelayed~‚ß¥~SHCHcy~–©~SHcy~–®~SOFTcy~–¨~Sacute~≈ö~Sc~‚™º~Scedil~≈û~Scirc~≈ú~Scy~–°~Sfr~ùîñ~ShortDownArrow~‚Üì~ShortLeftArrow~‚Üê~ShortRightArrow~‚Üí~ShortUpArrow~‚Üë~SmallCircle~‚àò~Sopf~ùïä~Sqrt~‚àö~Square~‚ñ°~SquareIntersection~‚äì~SquareSubset~‚äè~SquareSubsetEqual~‚äë~SquareSuperset~‚äê~SquareSupersetEqual~‚äí~SquareUnion~‚äî~Sscr~ùíÆ~Star~‚ãÜ~Sub~‚ãê~Subset~‚ãê~SubsetEqual~‚äÜ~Succeeds~‚âª~SucceedsEqual~‚™∞~SucceedsSlantEqual~‚âΩ~SucceedsTilde~‚âø~SuchThat~‚àã~Sum~‚àë~Sup~‚ãë~Superset~‚äÉ~SupersetEqual~‚äá~Supset~‚ãë~TRADE~‚Ñ¢~TSHcy~–ã~TScy~–¶~Tab~\\t~Tcaron~≈§~Tcedil~≈¢~Tcy~–¢~Tfr~ùîó~Therefore~‚à¥~ThickSpace~‚Åü‚Ää~ThinSpace~‚Äâ~Tilde~‚àº~TildeEqual~‚âÉ~TildeFullEqual~‚âÖ~TildeTilde~‚âà~Topf~ùïã~TripleDot~‚Éõ~Tscr~ùíØ~Tstrok~≈¶~Uarr~‚Üü~Uarrocir~‚•â~Ubrcy~–é~Ubreve~≈¨~Ucy~–£~Udblac~≈∞~Ufr~ùîò~Umacr~≈™~UnderBar~_~UnderBrace~‚èü~UnderBracket~‚éµ~UnderParenthesis~‚èù~Union~‚ãÉ~UnionPlus~‚äé~Uogon~≈≤~Uopf~ùïå~UpArrow~‚Üë~UpArrowBar~‚§í~UpArrowDownArrow~‚áÖ~UpDownArrow~‚Üï~UpEquilibrium~‚•Æ~UpTee~‚ä•~UpTeeArrow~‚Ü•~Uparrow~‚áë~Updownarrow~‚áï~UpperLeftArrow~‚Üñ~UpperRightArrow~‚Üó~Upsi~œí~Uring~≈Æ~Uscr~ùí∞~Utilde~≈®~VDash~‚ä´~Vbar~‚´´~Vcy~–í~Vdash~‚ä©~Vdashl~‚´¶~Vee~‚ãÅ~Verbar~‚Äñ~Vert~‚Äñ~VerticalBar~‚à£~VerticalLine~|~VerticalSeparator~‚ùò~VerticalTilde~‚âÄ~VeryThinSpace~‚Ää~Vfr~ùîô~Vopf~ùïç~Vscr~ùí±~Vvdash~‚ä™~Wcirc~≈¥~Wedge~‚ãÄ~Wfr~ùîö~Wopf~ùïé~Wscr~ùí≤~Xfr~ùîõ~Xopf~ùïè~Xscr~ùí≥~YAcy~–Ø~YIcy~–á~YUcy~–Æ~Ycirc~≈∂~Ycy~–´~Yfr~ùîú~Yopf~ùïê~Yscr~ùí¥~ZHcy~–ñ~Zacute~≈π~Zcaron~≈Ω~Zcy~–ó~Zdot~≈ª~ZeroWidthSpace~‚Äã~Zfr~‚Ñ®~Zopf~‚Ñ§~Zscr~ùíµ~abreve~ƒÉ~ac~‚àæ~acE~‚àæÃ≥~acd~‚àø~acy~–∞~af~‚Å°~afr~ùîû~aleph~‚Ñµ~amacr~ƒÅ~amalg~‚®ø~andand~‚©ï~andd~‚©ú~andslope~‚©ò~andv~‚©ö~ange~‚¶§~angle~‚à†~angmsd~‚à°~angmsdaa~‚¶®~angmsdab~‚¶©~angmsdac~‚¶™~angmsdad~‚¶´~angmsdae~‚¶¨~angmsdaf~‚¶≠~angmsdag~‚¶Æ~angmsdah~‚¶Ø~angrt~‚àü~angrtvb~‚äæ~angrtvbd~‚¶ù~angsph~‚à¢~angst~√Ö~angzarr~‚çº~aogon~ƒÖ~aopf~ùïí~ap~‚âà~apE~‚©∞~apacir~‚©Ø~ape~‚âä~apid~‚âã~approx~‚âà~approxeq~‚âä~ascr~ùí∂~ast~*~asympeq~‚âç~awconint~‚à≥~awint~‚®ë~bNot~‚´≠~backcong~‚âå~backepsilon~œ∂~backprime~‚Äµ~backsim~‚àΩ~backsimeq~‚ãç~barvee~‚äΩ~barwed~‚åÖ~barwedge~‚åÖ~bbrk~‚éµ~bbrktbrk~‚é∂~bcong~‚âå~bcy~–±~becaus~‚àµ~because~‚àµ~bemptyv~‚¶∞~bepsi~œ∂~bernou~‚Ñ¨~beth~‚Ñ∂~between~‚â¨~bfr~ùîü~bigcap~‚ãÇ~bigcirc~‚óØ~bigcup~‚ãÉ~bigodot~‚®Ä~bigoplus~‚®Å~bigotimes~‚®Ç~bigsqcup~‚®Ü~bigstar~‚òÖ~bigtriangledown~‚ñΩ~bigtriangleup~‚ñ≥~biguplus~‚®Ñ~bigvee~‚ãÅ~bigwedge~‚ãÄ~bkarow~‚§ç~blacklozenge~‚ß´~blacksquare~‚ñ™~blacktriangle~‚ñ¥~blacktriangledown~‚ñæ~blacktriangleleft~‚óÇ~blacktriangleright~‚ñ∏~blank~‚ê£~blk12~‚ñí~blk14~‚ñë~blk34~‚ñì~block~‚ñà~bne~=‚É•~bnequiv~‚â°‚É•~bnot~‚åê~bopf~ùïì~bot~‚ä•~bottom~‚ä•~bowtie~‚ãà~boxDL~‚ïó~boxDR~‚ïî~boxDl~‚ïñ~boxDr~‚ïì~boxH~‚ïê~boxHD~‚ï¶~boxHU~‚ï©~boxHd~‚ï§~boxHu~‚ïß~boxUL~‚ïù~boxUR~‚ïö~boxUl~‚ïú~boxUr~‚ïô~boxV~‚ïë~boxVH~‚ï¨~boxVL~‚ï£~boxVR~‚ï†~boxVh~‚ï´~boxVl~‚ï¢~boxVr~‚ïü~boxbox~‚ßâ~boxdL~‚ïï~boxdR~‚ïí~boxdl~‚îê~boxdr~‚îå~boxh~‚îÄ~boxhD~‚ï•~boxhU~‚ï®~boxhd~‚î¨~boxhu~‚î¥~boxminus~‚äü~boxplus~‚äû~boxtimes~‚ä†~boxuL~‚ïõ~boxuR~‚ïò~boxul~‚îò~boxur~‚îî~boxv~‚îÇ~boxvH~‚ï™~boxvL~‚ï°~boxvR~‚ïû~boxvh~‚îº~boxvl~‚î§~boxvr~‚îú~bprime~‚Äµ~breve~Àò~bscr~ùí∑~bsemi~‚Åè~bsim~‚àΩ~bsime~‚ãç~bsol~\\\\~bsolb~‚ßÖ~bsolhsub~‚üà~bullet~‚Ä¢~bump~‚âé~bumpE~‚™Æ~bumpe~‚âè~bumpeq~‚âè~cacute~ƒá~capand~‚©Ñ~capbrcup~‚©â~capcap~‚©ã~capcup~‚©á~capdot~‚©Ä~caps~‚à©Ô∏Ä~caret~‚ÅÅ~caron~Àá~ccaps~‚©ç~ccaron~ƒç~ccirc~ƒâ~ccups~‚©å~ccupssm~‚©ê~cdot~ƒã~cemptyv~‚¶≤~centerdot~¬∑~cfr~ùî†~chcy~—á~check~‚úì~checkmark~‚úì~cir~‚óã~cirE~‚ßÉ~circeq~‚âó~circlearrowleft~‚Ü∫~circlearrowright~‚Üª~circledR~¬Æ~circledS~‚ìà~circledast~‚äõ~circledcirc~‚äö~circleddash~‚äù~cire~‚âó~cirfnint~‚®ê~cirmid~‚´Ø~cirscir~‚ßÇ~clubsuit~‚ô£~colon~:~colone~‚âî~coloneq~‚âî~comma~,~commat~@~comp~‚àÅ~compfn~‚àò~complement~‚àÅ~complexes~‚ÑÇ~congdot~‚©≠~conint~‚àÆ~copf~ùïî~coprod~‚àê~copysr~‚Ñó~cross~‚úó~cscr~ùí∏~csub~‚´è~csube~‚´ë~csup~‚´ê~csupe~‚´í~ctdot~‚ãØ~cudarrl~‚§∏~cudarrr~‚§µ~cuepr~‚ãû~cuesc~‚ãü~cularr~‚Ü∂~cularrp~‚§Ω~cupbrcap~‚©à~cupcap~‚©Ü~cupcup~‚©ä~cupdot~‚äç~cupor~‚©Ö~cups~‚à™Ô∏Ä~curarr~‚Ü∑~curarrm~‚§º~curlyeqprec~‚ãû~curlyeqsucc~‚ãü~curlyvee~‚ãé~curlywedge~‚ãè~curvearrowleft~‚Ü∂~curvearrowright~‚Ü∑~cuvee~‚ãé~cuwed~‚ãè~cwconint~‚à≤~cwint~‚à±~cylcty~‚å≠~dHar~‚••~daleth~‚Ñ∏~dash~‚Äê~dashv~‚ä£~dbkarow~‚§è~dblac~Àù~dcaron~ƒè~dcy~–¥~dd~‚ÖÜ~ddagger~‚Ä°~ddarr~‚áä~ddotseq~‚©∑~demptyv~‚¶±~dfisht~‚•ø~dfr~ùî°~dharl~‚áÉ~dharr~‚áÇ~diam~‚ãÑ~diamond~‚ãÑ~diamondsuit~‚ô¶~die~¬®~digamma~œù~disin~‚ã≤~div~√∑~divideontimes~‚ãá~divonx~‚ãá~djcy~—í~dlcorn~‚åû~dlcrop~‚åç~dollar~$~dopf~ùïï~dot~Àô~doteq~‚âê~doteqdot~‚âë~dotminus~‚à∏~dotplus~‚àî~dotsquare~‚ä°~doublebarwedge~‚åÜ~downarrow~‚Üì~downdownarrows~‚áä~downharpoonleft~‚áÉ~downharpoonright~‚áÇ~drbkarow~‚§ê~drcorn~‚åü~drcrop~‚åå~dscr~ùíπ~dscy~—ï~dsol~‚ß∂~dstrok~ƒë~dtdot~‚ã±~dtri~‚ñø~dtrif~‚ñæ~duarr~‚áµ~duhar~‚•Ø~dwangle~‚¶¶~dzcy~—ü~dzigrarr~‚üø~eDDot~‚©∑~eDot~‚âë~easter~‚©Æ~ecaron~ƒõ~ecir~‚âñ~ecolon~‚âï~ecy~—ç~edot~ƒó~ee~‚Öá~efDot~‚âí~efr~ùî¢~eg~‚™ö~egs~‚™ñ~egsdot~‚™ò~el~‚™ô~elinters~‚èß~ell~‚Ñì~els~‚™ï~elsdot~‚™ó~emacr~ƒì~emptyset~‚àÖ~emptyv~‚àÖ~emsp13~‚ÄÑ~emsp14~‚ÄÖ~eng~≈ã~eogon~ƒô~eopf~ùïñ~epar~‚ãï~eparsl~‚ß£~eplus~‚©±~epsi~Œµ~epsiv~œµ~eqcirc~‚âñ~eqcolon~‚âï~eqsim~‚âÇ~eqslantgtr~‚™ñ~eqslantless~‚™ï~equals~=~equest~‚âü~equivDD~‚©∏~eqvparsl~‚ß•~erDot~‚âì~erarr~‚•±~escr~‚ÑØ~esdot~‚âê~esim~‚âÇ~excl~!~expectation~‚Ñ∞~exponentiale~‚Öá~fallingdotseq~‚âí~fcy~—Ñ~female~‚ôÄ~ffilig~Ô¨É~fflig~Ô¨Ä~ffllig~Ô¨Ñ~ffr~ùî£~filig~Ô¨Å~fjlig~fj~flat~‚ô≠~fllig~Ô¨Ç~fltns~‚ñ±~fopf~ùïó~fork~‚ãî~forkv~‚´ô~fpartint~‚®ç~frac13~‚Öì~frac15~‚Öï~frac16~‚Öô~frac18~‚Öõ~frac23~‚Öî~frac25~‚Öñ~frac35~‚Öó~frac38~‚Öú~frac45~‚Öò~frac56~‚Öö~frac58~‚Öù~frac78~‚Öû~frown~‚å¢~fscr~ùíª~gE~‚âß~gEl~‚™å~gacute~«µ~gammad~œù~gap~‚™Ü~gbreve~ƒü~gcirc~ƒù~gcy~–≥~gdot~ƒ°~gel~‚ãõ~geq~‚â•~geqq~‚âß~geqslant~‚©æ~ges~‚©æ~gescc~‚™©~gesdot~‚™Ä~gesdoto~‚™Ç~gesdotol~‚™Ñ~gesl~‚ãõÔ∏Ä~gesles~‚™î~gfr~ùî§~gg~‚â´~ggg~‚ãô~gimel~‚Ñ∑~gjcy~—ì~gl~‚â∑~glE~‚™í~gla~‚™•~glj~‚™§~gnE~‚â©~gnap~‚™ä~gnapprox~‚™ä~gne~‚™à~gneq~‚™à~gneqq~‚â©~gnsim~‚ãß~gopf~ùïò~grave~`~gscr~‚Ñä~gsim~‚â≥~gsime~‚™é~gsiml~‚™ê~gtcc~‚™ß~gtcir~‚©∫~gtdot~‚ãó~gtlPar~‚¶ï~gtquest~‚©º~gtrapprox~‚™Ü~gtrarr~‚•∏~gtrdot~‚ãó~gtreqless~‚ãõ~gtreqqless~‚™å~gtrless~‚â∑~gtrsim~‚â≥~gvertneqq~‚â©Ô∏Ä~gvnE~‚â©Ô∏Ä~hairsp~‚Ää~half~¬Ω~hamilt~‚Ñã~hardcy~—ä~harrcir~‚•à~harrw~‚Ü≠~hbar~‚Ñè~hcirc~ƒ•~heartsuit~‚ô•~hercon~‚äπ~hfr~ùî•~hksearow~‚§•~hkswarow~‚§¶~hoarr~‚áø~homtht~‚àª~hookleftarrow~‚Ü©~hookrightarrow~‚Ü™~hopf~ùïô~horbar~‚Äï~hscr~ùíΩ~hslash~‚Ñè~hstrok~ƒß~hybull~‚ÅÉ~hyphen~‚Äê~ic~‚Å£~icy~–∏~iecy~–µ~iff~‚áî~ifr~ùî¶~ii~‚Öà~iiiint~‚®å~iiint~‚à≠~iinfin~‚ßú~iiota~‚Ñ©~ijlig~ƒ≥~imacr~ƒ´~imagline~‚Ñê~imagpart~‚Ñë~imath~ƒ±~imof~‚ä∑~imped~∆µ~in~‚àà~incare~‚ÑÖ~infintie~‚ßù~inodot~ƒ±~intcal~‚ä∫~integers~‚Ñ§~intercal~‚ä∫~intlarhk~‚®ó~intprod~‚®º~iocy~—ë~iogon~ƒØ~iopf~ùïö~iprod~‚®º~iscr~ùíæ~isinE~‚ãπ~isindot~‚ãµ~isins~‚ã¥~isinsv~‚ã≥~isinv~‚àà~it~‚Å¢~itilde~ƒ©~iukcy~—ñ~jcirc~ƒµ~jcy~–π~jfr~ùîß~jmath~»∑~jopf~ùïõ~jscr~ùíø~jsercy~—ò~jukcy~—î~kappav~œ∞~kcedil~ƒ∑~kcy~–∫~kfr~ùî®~kgreen~ƒ∏~khcy~—Ö~kjcy~—ú~kopf~ùïú~kscr~ùìÄ~lAarr~‚áö~lAtail~‚§õ~lBarr~‚§é~lE~‚â¶~lEg~‚™ã~lHar~‚•¢~lacute~ƒ∫~laemptyv~‚¶¥~lagran~‚Ñí~langd~‚¶ë~langle~‚ü®~lap~‚™Ö~larrb~‚á§~larrbfs~‚§ü~larrfs~‚§ù~larrhk~‚Ü©~larrlp~‚Ü´~larrpl~‚§π~larrsim~‚•≥~larrtl~‚Ü¢~lat~‚™´~latail~‚§ô~late~‚™≠~lates~‚™≠Ô∏Ä~lbarr~‚§å~lbbrk~‚ù≤~lbrace~{~lbrack~[~lbrke~‚¶ã~lbrksld~‚¶è~lbrkslu~‚¶ç~lcaron~ƒæ~lcedil~ƒº~lcub~{~lcy~–ª~ldca~‚§∂~ldquor~‚Äû~ldrdhar~‚•ß~ldrushar~‚•ã~ldsh~‚Ü≤~leftarrow~‚Üê~leftarrowtail~‚Ü¢~leftharpoondown~‚ÜΩ~leftharpoonup~‚Üº~leftleftarrows~‚áá~leftrightarrow~‚Üî~leftrightarrows~‚áÜ~leftrightharpoons~‚áã~leftrightsquigarrow~‚Ü≠~leftthreetimes~‚ãã~leg~‚ãö~leq~‚â§~leqq~‚â¶~leqslant~‚©Ω~les~‚©Ω~lescc~‚™®~lesdot~‚©ø~lesdoto~‚™Å~lesdotor~‚™É~lesg~‚ãöÔ∏Ä~lesges~‚™ì~lessapprox~‚™Ö~lessdot~‚ãñ~lesseqgtr~‚ãö~lesseqqgtr~‚™ã~lessgtr~‚â∂~lesssim~‚â≤~lfisht~‚•º~lfr~ùî©~lg~‚â∂~lgE~‚™ë~lhard~‚ÜΩ~lharu~‚Üº~lharul~‚•™~lhblk~‚ñÑ~ljcy~—ô~ll~‚â™~llarr~‚áá~llcorner~‚åû~llhard~‚•´~lltri~‚ó∫~lmidot~≈Ä~lmoust~‚é∞~lmoustache~‚é∞~lnE~‚â®~lnap~‚™â~lnapprox~‚™â~lne~‚™á~lneq~‚™á~lneqq~‚â®~lnsim~‚ã¶~loang~‚ü¨~loarr~‚áΩ~lobrk~‚ü¶~longleftarrow~‚üµ~longleftrightarrow~‚ü∑~longmapsto~‚üº~longrightarrow~‚ü∂~looparrowleft~‚Ü´~looparrowright~‚Ü¨~lopar~‚¶Ö~lopf~ùïù~loplus~‚®≠~lotimes~‚®¥~lowbar~_~lozenge~‚óä~lozf~‚ß´~lpar~(~lparlt~‚¶ì~lrarr~‚áÜ~lrcorner~‚åü~lrhar~‚áã~lrhard~‚•≠~lrtri~‚äø~lscr~ùìÅ~lsh~‚Ü∞~lsim~‚â≤~lsime~‚™ç~lsimg~‚™è~lsqb~[~lsquor~‚Äö~lstrok~≈Ç~ltcc~‚™¶~ltcir~‚©π~ltdot~‚ãñ~lthree~‚ãã~ltimes~‚ãâ~ltlarr~‚•∂~ltquest~‚©ª~ltrPar~‚¶ñ~ltri~‚óÉ~ltrie~‚ä¥~ltrif~‚óÇ~lurdshar~‚•ä~luruhar~‚•¶~lvertneqq~‚â®Ô∏Ä~lvnE~‚â®Ô∏Ä~mDDot~‚à∫~male~‚ôÇ~malt~‚ú†~maltese~‚ú†~map~‚Ü¶~mapsto~‚Ü¶~mapstodown~‚Üß~mapstoleft~‚Ü§~mapstoup~‚Ü•~marker~‚ñÆ~mcomma~‚®©~mcy~–º~measuredangle~‚à°~mfr~ùî™~mho~‚Ñß~mid~‚à£~midast~*~midcir~‚´∞~minusb~‚äü~minusd~‚à∏~minusdu~‚®™~mlcp~‚´õ~mldr~‚Ä¶~mnplus~‚àì~models~‚äß~mopf~ùïû~mp~‚àì~mscr~ùìÇ~mstpos~‚àæ~multimap~‚ä∏~mumap~‚ä∏~nGg~‚ãôÃ∏~nGt~‚â´‚Éí~nGtv~‚â´Ã∏~nLeftarrow~‚áç~nLeftrightarrow~‚áé~nLl~‚ãòÃ∏~nLt~‚â™‚Éí~nLtv~‚â™Ã∏~nRightarrow~‚áè~nVDash~‚äØ~nVdash~‚äÆ~nacute~≈Ñ~nang~‚à†‚Éí~nap~‚ââ~napE~‚©∞Ã∏~napid~‚âãÃ∏~napos~≈â~napprox~‚ââ~natur~‚ôÆ~natural~‚ôÆ~naturals~‚Ñï~nbump~‚âéÃ∏~nbumpe~‚âèÃ∏~ncap~‚©É~ncaron~≈à~ncedil~≈Ü~ncong~‚âá~ncongdot~‚©≠Ã∏~ncup~‚©Ç~ncy~–Ω~neArr~‚áó~nearhk~‚§§~nearr~‚Üó~nearrow~‚Üó~nedot~‚âêÃ∏~nequiv~‚â¢~nesear~‚§®~nesim~‚âÇÃ∏~nexist~‚àÑ~nexists~‚àÑ~nfr~ùî´~ngE~‚âßÃ∏~nge~‚â±~ngeq~‚â±~ngeqq~‚âßÃ∏~ngeqslant~‚©æÃ∏~nges~‚©æÃ∏~ngsim~‚âµ~ngt~‚âØ~ngtr~‚âØ~nhArr~‚áé~nharr~‚ÜÆ~nhpar~‚´≤~nis~‚ãº~nisd~‚ã∫~niv~‚àã~njcy~—ö~nlArr~‚áç~nlE~‚â¶Ã∏~nlarr~‚Üö~nldr~‚Ä•~nle~‚â∞~nleftarrow~‚Üö~nleftrightarrow~‚ÜÆ~nleq~‚â∞~nleqq~‚â¶Ã∏~nleqslant~‚©ΩÃ∏~nles~‚©ΩÃ∏~nless~‚âÆ~nlsim~‚â¥~nlt~‚âÆ~nltri~‚ã™~nltrie~‚ã¨~nmid~‚à§~nopf~ùïü~notinE~‚ãπÃ∏~notindot~‚ãµÃ∏~notinva~‚àâ~notinvb~‚ã∑~notinvc~‚ã∂~notni~‚àå~notniva~‚àå~notnivb~‚ãæ~notnivc~‚ãΩ~npar~‚à¶~nparallel~‚à¶~nparsl~‚´Ω‚É•~npart~‚àÇÃ∏~npolint~‚®î~npr~‚äÄ~nprcue~‚ã†~npre~‚™ØÃ∏~nprec~‚äÄ~npreceq~‚™ØÃ∏~nrArr~‚áè~nrarr~‚Üõ~nrarrc~‚§≥Ã∏~nrarrw~‚ÜùÃ∏~nrightarrow~‚Üõ~nrtri~‚ã´~nrtrie~‚ã≠~nsc~‚äÅ~nsccue~‚ã°~nsce~‚™∞Ã∏~nscr~ùìÉ~nshortmid~‚à§~nshortparallel~‚à¶~nsim~‚âÅ~nsime~‚âÑ~nsimeq~‚âÑ~nsmid~‚à§~nspar~‚à¶~nsqsube~‚ã¢~nsqsupe~‚ã£~nsubE~‚´ÖÃ∏~nsube~‚äà~nsubset~‚äÇ‚Éí~nsubseteq~‚äà~nsubseteqq~‚´ÖÃ∏~nsucc~‚äÅ~nsucceq~‚™∞Ã∏~nsup~‚äÖ~nsupE~‚´ÜÃ∏~nsupe~‚äâ~nsupset~‚äÉ‚Éí~nsupseteq~‚äâ~nsupseteqq~‚´ÜÃ∏~ntgl~‚âπ~ntlg~‚â∏~ntriangleleft~‚ã™~ntrianglelefteq~‚ã¨~ntriangleright~‚ã´~ntrianglerighteq~‚ã≠~num~#~numero~‚Ññ~numsp~‚Äá~nvDash~‚ä≠~nvHarr~‚§Ñ~nvap~‚âç‚Éí~nvdash~‚ä¨~nvge~‚â•‚Éí~nvgt~>‚Éí~nvinfin~‚ßû~nvlArr~‚§Ç~nvle~‚â§‚Éí~nvlt~<‚Éí~nvltrie~‚ä¥‚Éí~nvrArr~‚§É~nvrtrie~‚äµ‚Éí~nvsim~‚àº‚Éí~nwArr~‚áñ~nwarhk~‚§£~nwarr~‚Üñ~nwarrow~‚Üñ~nwnear~‚§ß~oS~‚ìà~oast~‚äõ~ocir~‚äö~ocy~–æ~odash~‚äù~odblac~≈ë~odiv~‚®∏~odot~‚äô~odsold~‚¶º~ofcir~‚¶ø~ofr~ùî¨~ogon~Àõ~ogt~‚ßÅ~ohbar~‚¶µ~ohm~Œ©~oint~‚àÆ~olarr~‚Ü∫~olcir~‚¶æ~olcross~‚¶ª~olt~‚ßÄ~omacr~≈ç~omid~‚¶∂~ominus~‚äñ~oopf~ùï†~opar~‚¶∑~operp~‚¶π~orarr~‚Üª~ord~‚©ù~order~‚Ñ¥~orderof~‚Ñ¥~origof~‚ä∂~oror~‚©ñ~orslope~‚©ó~orv~‚©õ~oscr~‚Ñ¥~osol~‚äò~otimesas~‚®∂~ovbar~‚åΩ~par~‚à•~parallel~‚à•~parsim~‚´≥~parsl~‚´Ω~pcy~–ø~percnt~%~period~.~pertenk~‚Ä±~pfr~ùî≠~phiv~œï~phmmat~‚Ñ≥~phone~‚òé~pitchfork~‚ãî~planck~‚Ñè~planckh~‚Ñé~plankv~‚Ñè~plus~+~plusacir~‚®£~plusb~‚äû~pluscir~‚®¢~plusdo~‚àî~plusdu~‚®•~pluse~‚©≤~plussim~‚®¶~plustwo~‚®ß~pm~¬±~pointint~‚®ï~popf~ùï°~pr~‚â∫~prE~‚™≥~prap~‚™∑~prcue~‚âº~pre~‚™Ø~prec~‚â∫~precapprox~‚™∑~preccurlyeq~‚âº~preceq~‚™Ø~precnapprox~‚™π~precneqq~‚™µ~precnsim~‚ã®~precsim~‚âæ~primes~‚Ñô~prnE~‚™µ~prnap~‚™π~prnsim~‚ã®~profalar~‚åÆ~profline~‚åí~profsurf~‚åì~propto~‚àù~prsim~‚âæ~prurel~‚ä∞~pscr~ùìÖ~puncsp~‚Äà~qfr~ùîÆ~qint~‚®å~qopf~ùï¢~qprime~‚Åó~qscr~ùìÜ~quaternions~‚Ñç~quatint~‚®ñ~quest~?~questeq~‚âü~rAarr~‚áõ~rAtail~‚§ú~rBarr~‚§è~rHar~‚•§~race~‚àΩÃ±~racute~≈ï~raemptyv~‚¶≥~rangd~‚¶í~range~‚¶•~rangle~‚ü©~rarrap~‚•µ~rarrb~‚á•~rarrbfs~‚§†~rarrc~‚§≥~rarrfs~‚§û~rarrhk~‚Ü™~rarrlp~‚Ü¨~rarrpl~‚•Ö~rarrsim~‚•¥~rarrtl~‚Ü£~rarrw~‚Üù~ratail~‚§ö~ratio~‚à∂~rationals~‚Ñö~rbarr~‚§ç~rbbrk~‚ù≥~rbrace~}~rbrack~]~rbrke~‚¶å~rbrksld~‚¶é~rbrkslu~‚¶ê~rcaron~≈ô~rcedil~≈ó~rcub~}~rcy~—Ä~rdca~‚§∑~rdldhar~‚•©~rdquor~‚Äù~rdsh~‚Ü≥~realine~‚Ñõ~realpart~‚Ñú~reals~‚Ñù~rect~‚ñ≠~rfisht~‚•Ω~rfr~ùîØ~rhard~‚áÅ~rharu~‚áÄ~rharul~‚•¨~rhov~œ±~rightarrow~‚Üí~rightarrowtail~‚Ü£~rightharpoondown~‚áÅ~rightharpoonup~‚áÄ~rightleftarrows~‚áÑ~rightleftharpoons~‚áå~rightrightarrows~‚áâ~rightsquigarrow~‚Üù~rightthreetimes~‚ãå~ring~Àö~risingdotseq~‚âì~rlarr~‚áÑ~rlhar~‚áå~rmoust~‚é±~rmoustache~‚é±~rnmid~‚´Æ~roang~‚ü≠~roarr~‚áæ~robrk~‚üß~ropar~‚¶Ü~ropf~ùï£~roplus~‚®Æ~rotimes~‚®µ~rpar~)~rpargt~‚¶î~rppolint~‚®í~rrarr~‚áâ~rscr~ùìá~rsh~‚Ü±~rsqb~]~rsquor~‚Äô~rthree~‚ãå~rtimes~‚ãä~rtri~‚ñπ~rtrie~‚äµ~rtrif~‚ñ∏~rtriltri~‚ßé~ruluhar~‚•®~rx~‚Ñû~sacute~≈õ~sc~‚âª~scE~‚™¥~scap~‚™∏~sccue~‚âΩ~sce~‚™∞~scedil~≈ü~scirc~≈ù~scnE~‚™∂~scnap~‚™∫~scnsim~‚ã©~scpolint~‚®ì~scsim~‚âø~scy~—Å~sdotb~‚ä°~sdote~‚©¶~seArr~‚áò~searhk~‚§•~searr~‚Üò~searrow~‚Üò~semi~;~seswar~‚§©~setminus~‚àñ~setmn~‚àñ~sext~‚ú∂~sfr~ùî∞~sfrown~‚å¢~sharp~‚ôØ~shchcy~—â~shcy~—à~shortmid~‚à£~shortparallel~‚à•~sigmav~œÇ~simdot~‚©™~sime~‚âÉ~simeq~‚âÉ~simg~‚™û~simgE~‚™†~siml~‚™ù~simlE~‚™ü~simne~‚âÜ~simplus~‚®§~simrarr~‚•≤~slarr~‚Üê~smallsetminus~‚àñ~smashp~‚®≥~smeparsl~‚ß§~smid~‚à£~smile~‚å£~smt~‚™™~smte~‚™¨~smtes~‚™¨Ô∏Ä~softcy~—å~sol~/~solb~‚ßÑ~solbar~‚åø~sopf~ùï§~spadesuit~‚ô†~spar~‚à•~sqcap~‚äì~sqcaps~‚äìÔ∏Ä~sqcup~‚äî~sqcups~‚äîÔ∏Ä~sqsub~‚äè~sqsube~‚äë~sqsubset~‚äè~sqsubseteq~‚äë~sqsup~‚äê~sqsupe~‚äí~sqsupset~‚äê~sqsupseteq~‚äí~squ~‚ñ°~square~‚ñ°~squarf~‚ñ™~squf~‚ñ™~srarr~‚Üí~sscr~ùìà~ssetmn~‚àñ~ssmile~‚å£~sstarf~‚ãÜ~star~‚òÜ~starf~‚òÖ~straightepsilon~œµ~straightphi~œï~strns~¬Ø~subE~‚´Ö~subdot~‚™Ω~subedot~‚´É~submult~‚´Å~subnE~‚´ã~subne~‚ää~subplus~‚™ø~subrarr~‚•π~subset~‚äÇ~subseteq~‚äÜ~subseteqq~‚´Ö~subsetneq~‚ää~subsetneqq~‚´ã~subsim~‚´á~subsub~‚´ï~subsup~‚´ì~succ~‚âª~succapprox~‚™∏~succcurlyeq~‚âΩ~succeq~‚™∞~succnapprox~‚™∫~succneqq~‚™∂~succnsim~‚ã©~succsim~‚âø~sung~‚ô™~supE~‚´Ü~supdot~‚™æ~supdsub~‚´ò~supedot~‚´Ñ~suphsol~‚üâ~suphsub~‚´ó~suplarr~‚•ª~supmult~‚´Ç~supnE~‚´å~supne~‚äã~supplus~‚´Ä~supset~‚äÉ~supseteq~‚äá~supseteqq~‚´Ü~supsetneq~‚äã~supsetneqq~‚´å~supsim~‚´à~supsub~‚´î~supsup~‚´ñ~swArr~‚áô~swarhk~‚§¶~swarr~‚Üô~swarrow~‚Üô~swnwar~‚§™~target~‚åñ~tbrk~‚é¥~tcaron~≈•~tcedil~≈£~tcy~—Ç~tdot~‚Éõ~telrec~‚åï~tfr~ùî±~therefore~‚à¥~thetav~œë~thickapprox~‚âà~thicksim~‚àº~thkap~‚âà~thksim~‚àº~timesb~‚ä†~timesbar~‚®±~timesd~‚®∞~tint~‚à≠~toea~‚§®~top~‚ä§~topbot~‚å∂~topcir~‚´±~topf~ùï•~topfork~‚´ö~tosa~‚§©~tprime~‚Ä¥~triangle~‚ñµ~triangledown~‚ñø~triangleleft~‚óÉ~trianglelefteq~‚ä¥~triangleq~‚âú~triangleright~‚ñπ~trianglerighteq~‚äµ~tridot~‚ó¨~trie~‚âú~triminus~‚®∫~triplus~‚®π~trisb~‚ßç~tritime~‚®ª~trpezium~‚è¢~tscr~ùìâ~tscy~—Ü~tshcy~—õ~tstrok~≈ß~twixt~‚â¨~twoheadleftarrow~‚Üû~twoheadrightarrow~‚Ü†~uHar~‚•£~ubrcy~—û~ubreve~≈≠~ucy~—É~udarr~‚áÖ~udblac~≈±~udhar~‚•Æ~ufisht~‚•æ~ufr~ùî≤~uharl~‚Üø~uharr~‚Üæ~uhblk~‚ñÄ~ulcorn~‚åú~ulcorner~‚åú~ulcrop~‚åè~ultri~‚ó∏~umacr~≈´~uogon~≈≥~uopf~ùï¶~uparrow~‚Üë~updownarrow~‚Üï~upharpoonleft~‚Üø~upharpoonright~‚Üæ~uplus~‚äé~upsi~œÖ~upuparrows~‚áà~urcorn~‚åù~urcorner~‚åù~urcrop~‚åé~uring~≈Ø~urtri~‚óπ~uscr~ùìä~utdot~‚ã∞~utilde~≈©~utri~‚ñµ~utrif~‚ñ¥~uuarr~‚áà~uwangle~‚¶ß~vArr~‚áï~vBar~‚´®~vBarv~‚´©~vDash~‚ä®~vangrt~‚¶ú~varepsilon~œµ~varkappa~œ∞~varnothing~‚àÖ~varphi~œï~varpi~œñ~varpropto~‚àù~varr~‚Üï~varrho~œ±~varsigma~œÇ~varsubsetneq~‚ääÔ∏Ä~varsubsetneqq~‚´ãÔ∏Ä~varsupsetneq~‚äãÔ∏Ä~varsupsetneqq~‚´åÔ∏Ä~vartheta~œë~vartriangleleft~‚ä≤~vartriangleright~‚ä≥~vcy~–≤~vdash~‚ä¢~vee~‚à®~veebar~‚äª~veeeq~‚âö~vellip~‚ãÆ~verbar~|~vert~|~vfr~ùî≥~vltri~‚ä≤~vnsub~‚äÇ‚Éí~vnsup~‚äÉ‚Éí~vopf~ùïß~vprop~‚àù~vrtri~‚ä≥~vscr~ùìã~vsubnE~‚´ãÔ∏Ä~vsubne~‚ääÔ∏Ä~vsupnE~‚´åÔ∏Ä~vsupne~‚äãÔ∏Ä~vzigzag~‚¶ö~wcirc~≈µ~wedbar~‚©ü~wedge~‚àß~wedgeq~‚âô~wfr~ùî¥~wopf~ùï®~wp~‚Ñò~wr~‚âÄ~wreath~‚âÄ~wscr~ùìå~xcap~‚ãÇ~xcirc~‚óØ~xcup~‚ãÉ~xdtri~‚ñΩ~xfr~ùîµ~xhArr~‚ü∫~xharr~‚ü∑~xlArr~‚ü∏~xlarr~‚üµ~xmap~‚üº~xnis~‚ãª~xodot~‚®Ä~xopf~ùï©~xoplus~‚®Å~xotime~‚®Ç~xrArr~‚üπ~xrarr~‚ü∂~xscr~ùìç~xsqcup~‚®Ü~xuplus~‚®Ñ~xutri~‚ñ≥~xvee~‚ãÅ~xwedge~‚ãÄ~yacy~—è~ycirc~≈∑~ycy~—ã~yfr~ùî∂~yicy~—ó~yopf~ùï™~yscr~ùìé~yucy~—é~zacute~≈∫~zcaron~≈æ~zcy~–∑~zdot~≈º~zeetrf~‚Ñ®~zfr~ùî∑~zhcy~–∂~zigrarr~‚áù~zopf~ùï´~zscr~ùìè~~AMP~&~COPY~¬©~GT~>~LT~<~QUOT~\\\"~REG~¬Æ\", exports.namedReferences['html4']);\n//# sourceMappingURL=named-references.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.numericUnicodeMap = void 0;\nexports.numericUnicodeMap = {\n    0: 65533,\n    128: 8364,\n    130: 8218,\n    131: 402,\n    132: 8222,\n    133: 8230,\n    134: 8224,\n    135: 8225,\n    136: 710,\n    137: 8240,\n    138: 352,\n    139: 8249,\n    140: 338,\n    142: 381,\n    145: 8216,\n    146: 8217,\n    147: 8220,\n    148: 8221,\n    149: 8226,\n    150: 8211,\n    151: 8212,\n    152: 732,\n    153: 8482,\n    154: 353,\n    155: 8250,\n    156: 339,\n    158: 382,\n    159: 376\n};\n//# sourceMappingURL=numeric-unicode-map.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.highSurrogateTo = exports.highSurrogateFrom = exports.getCodePoint = exports.fromCodePoint = void 0;\nexports.fromCodePoint = String.fromCodePoint ||\n    function (astralCodePoint) {\n        return String.fromCharCode(Math.floor((astralCodePoint - 0x10000) / 0x400) + 0xd800, ((astralCodePoint - 0x10000) % 0x400) + 0xdc00);\n    };\n// @ts-expect-error - String.prototype.codePointAt might not exist in older node versions\nexports.getCodePoint = String.prototype.codePointAt\n    ? function (input, position) {\n        return input.codePointAt(position);\n    }\n    : function (input, position) {\n        return (input.charCodeAt(position) - 0xd800) * 0x400 + input.charCodeAt(position + 1) - 0xdc00 + 0x10000;\n    };\nexports.highSurrogateFrom = 0xd800;\nexports.highSurrogateTo = 0xdbff;\n//# sourceMappingURL=surrogate-pairs.js.map","(function (global, factory) {\n    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n    typeof define === 'function' && define.amd ? define(['exports'], factory) :\n    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.jtpp = {}));\n})(this, (function (exports) { 'use strict';\n\n    function tokenToString(token) {\n        if (token.text !== undefined && token.text !== '') {\n            return `'${token.type}' with value '${token.text}'`;\n        }\n        else {\n            return `'${token.type}'`;\n        }\n    }\n    class NoParsletFoundError extends Error {\n        constructor(token) {\n            super(`No parslet found for token: ${tokenToString(token)}`);\n            this.token = token;\n            Object.setPrototypeOf(this, NoParsletFoundError.prototype);\n        }\n        getToken() {\n            return this.token;\n        }\n    }\n    class EarlyEndOfParseError extends Error {\n        constructor(token) {\n            super(`The parsing ended early. The next token was: ${tokenToString(token)}`);\n            this.token = token;\n            Object.setPrototypeOf(this, EarlyEndOfParseError.prototype);\n        }\n        getToken() {\n            return this.token;\n        }\n    }\n    class UnexpectedTypeError extends Error {\n        constructor(result, message) {\n            let error = `Unexpected type: '${result.type}'.`;\n            if (message !== undefined) {\n                error += ` Message: ${message}`;\n            }\n            super(error);\n            Object.setPrototypeOf(this, UnexpectedTypeError.prototype);\n        }\n    }\n    // export class UnexpectedTokenError extends Error {\n    //   private expected: Token\n    //   private found: Token\n    //\n    //   constructor (expected: Token, found: Token) {\n    //     super(`The parsing ended early. The next token was: ${tokenToString(token)}`)\n    //\n    //     this.token = token\n    //\n    //     Object.setPrototypeOf(this, EarlyEndOfParseError.prototype)\n    //   }\n    //\n    //   getToken() {\n    //     return this.token\n    //   }\n    // }\n\n    function makePunctuationRule(type) {\n        return text => {\n            if (text.startsWith(type)) {\n                return { type, text: type };\n            }\n            else {\n                return null;\n            }\n        };\n    }\n    function getQuoted(text) {\n        let position = 0;\n        let char;\n        const mark = text[0];\n        let escaped = false;\n        if (mark !== '\\'' && mark !== '\"') {\n            return null;\n        }\n        while (position < text.length) {\n            position++;\n            char = text[position];\n            if (!escaped && char === mark) {\n                position++;\n                break;\n            }\n            escaped = !escaped && char === '\\\\';\n        }\n        if (char !== mark) {\n            throw new Error('Unterminated String');\n        }\n        return text.slice(0, position);\n    }\n    const identifierStartRegex = /[$_\\p{ID_Start}]|\\\\u\\p{Hex_Digit}{4}|\\\\u\\{0*(?:\\p{Hex_Digit}{1,5}|10\\p{Hex_Digit}{4})\\}/u;\n    // A hyphen is not technically allowed, but to keep it liberal for now,\n    //  adding it here\n    const identifierContinueRegex = /[$\\-\\p{ID_Continue}\\u200C\\u200D]|\\\\u\\p{Hex_Digit}{4}|\\\\u\\{0*(?:\\p{Hex_Digit}{1,5}|10\\p{Hex_Digit}{4})\\}/u;\n    function getIdentifier(text) {\n        let char = text[0];\n        if (!identifierStartRegex.test(char)) {\n            return null;\n        }\n        let position = 1;\n        do {\n            char = text[position];\n            if (!identifierContinueRegex.test(char)) {\n                break;\n            }\n            position++;\n        } while (position < text.length);\n        return text.slice(0, position);\n    }\n    // we are a bit more liberal than TypeScript here and allow `NaN`, `Infinity` and `-Infinity`\n    const numberRegex = /^(NaN|-?((\\d*\\.\\d+|\\d+)([Ee][+-]?\\d+)?|Infinity))/;\n    function getNumber(text) {\n        var _a, _b;\n        return (_b = (_a = numberRegex.exec(text)) === null || _a === void 0 ? void 0 : _a[0]) !== null && _b !== void 0 ? _b : null;\n    }\n    const identifierRule = text => {\n        const value = getIdentifier(text);\n        if (value == null) {\n            return null;\n        }\n        return {\n            type: 'Identifier',\n            text: value\n        };\n    };\n    function makeKeyWordRule(type) {\n        return text => {\n            if (!text.startsWith(type)) {\n                return null;\n            }\n            const prepends = text[type.length];\n            if (prepends !== undefined && identifierContinueRegex.test(prepends)) {\n                return null;\n            }\n            return {\n                type,\n                text: type\n            };\n        };\n    }\n    const stringValueRule = text => {\n        const value = getQuoted(text);\n        if (value == null) {\n            return null;\n        }\n        return {\n            type: 'StringValue',\n            text: value\n        };\n    };\n    const eofRule = text => {\n        if (text.length > 0) {\n            return null;\n        }\n        return {\n            type: 'EOF',\n            text: ''\n        };\n    };\n    const numberRule = text => {\n        const value = getNumber(text);\n        if (value === null) {\n            return null;\n        }\n        return {\n            type: 'Number',\n            text: value\n        };\n    };\n    const rules = [\n        eofRule,\n        makePunctuationRule('=>'),\n        makePunctuationRule('('),\n        makePunctuationRule(')'),\n        makePunctuationRule('{'),\n        makePunctuationRule('}'),\n        makePunctuationRule('['),\n        makePunctuationRule(']'),\n        makePunctuationRule('|'),\n        makePunctuationRule('&'),\n        makePunctuationRule('<'),\n        makePunctuationRule('>'),\n        makePunctuationRule(','),\n        makePunctuationRule(';'),\n        makePunctuationRule('*'),\n        makePunctuationRule('?'),\n        makePunctuationRule('!'),\n        makePunctuationRule('='),\n        makePunctuationRule(':'),\n        makePunctuationRule('...'),\n        makePunctuationRule('.'),\n        makePunctuationRule('#'),\n        makePunctuationRule('~'),\n        makePunctuationRule('/'),\n        makePunctuationRule('@'),\n        makeKeyWordRule('undefined'),\n        makeKeyWordRule('null'),\n        makeKeyWordRule('function'),\n        makeKeyWordRule('this'),\n        makeKeyWordRule('new'),\n        makeKeyWordRule('module'),\n        makeKeyWordRule('event'),\n        makeKeyWordRule('external'),\n        makeKeyWordRule('typeof'),\n        makeKeyWordRule('keyof'),\n        makeKeyWordRule('readonly'),\n        makeKeyWordRule('import'),\n        makeKeyWordRule('is'),\n        makeKeyWordRule('in'),\n        makeKeyWordRule('asserts'),\n        numberRule,\n        identifierRule,\n        stringValueRule\n    ];\n    const breakingWhitespaceRegex = /^\\s*\\n\\s*/;\n    class Lexer {\n        static create(text) {\n            const current = this.read(text);\n            text = current.text;\n            const next = this.read(text);\n            text = next.text;\n            return new Lexer(text, undefined, current.token, next.token);\n        }\n        constructor(text, previous, current, next) {\n            this.text = '';\n            this.text = text;\n            this.previous = previous;\n            this.current = current;\n            this.next = next;\n        }\n        static read(text, startOfLine = false) {\n            startOfLine = startOfLine || breakingWhitespaceRegex.test(text);\n            text = text.trim();\n            for (const rule of rules) {\n                const partial = rule(text);\n                if (partial !== null) {\n                    const token = Object.assign(Object.assign({}, partial), { startOfLine });\n                    text = text.slice(token.text.length);\n                    return { text, token };\n                }\n            }\n            throw new Error('Unexpected Token ' + text);\n        }\n        advance() {\n            const next = Lexer.read(this.text);\n            return new Lexer(next.text, this.current, this.next, next.token);\n        }\n    }\n\n    /**\n     * Throws an error if the provided result is not a {@link RootResult}\n     */\n    function assertRootResult(result) {\n        if (result === undefined) {\n            throw new Error('Unexpected undefined');\n        }\n        if (result.type === 'JsdocTypeKeyValue' || result.type === 'JsdocTypeParameterList' ||\n            result.type === 'JsdocTypeProperty' || result.type === 'JsdocTypeReadonlyProperty' ||\n            result.type === 'JsdocTypeObjectField' || result.type === 'JsdocTypeJsdocObjectField' ||\n            result.type === 'JsdocTypeIndexSignature' || result.type === 'JsdocTypeMappedType') {\n            throw new UnexpectedTypeError(result);\n        }\n        return result;\n    }\n    function assertPlainKeyValueOrRootResult(result) {\n        if (result.type === 'JsdocTypeKeyValue') {\n            return assertPlainKeyValueResult(result);\n        }\n        return assertRootResult(result);\n    }\n    function assertPlainKeyValueOrNameResult(result) {\n        if (result.type === 'JsdocTypeName') {\n            return result;\n        }\n        return assertPlainKeyValueResult(result);\n    }\n    function assertPlainKeyValueResult(result) {\n        if (result.type !== 'JsdocTypeKeyValue') {\n            throw new UnexpectedTypeError(result);\n        }\n        return result;\n    }\n    function assertNumberOrVariadicNameResult(result) {\n        var _a;\n        if (result.type === 'JsdocTypeVariadic') {\n            if (((_a = result.element) === null || _a === void 0 ? void 0 : _a.type) === 'JsdocTypeName') {\n                return result;\n            }\n            throw new UnexpectedTypeError(result);\n        }\n        if (result.type !== 'JsdocTypeNumber' && result.type !== 'JsdocTypeName') {\n            throw new UnexpectedTypeError(result);\n        }\n        return result;\n    }\n    function isSquaredProperty(result) {\n        return result.type === 'JsdocTypeIndexSignature' || result.type === 'JsdocTypeMappedType';\n    }\n\n    // higher precedence = higher importance\n    var Precedence;\n    (function (Precedence) {\n        Precedence[Precedence[\"ALL\"] = 0] = \"ALL\";\n        Precedence[Precedence[\"PARAMETER_LIST\"] = 1] = \"PARAMETER_LIST\";\n        Precedence[Precedence[\"OBJECT\"] = 2] = \"OBJECT\";\n        Precedence[Precedence[\"KEY_VALUE\"] = 3] = \"KEY_VALUE\";\n        Precedence[Precedence[\"INDEX_BRACKETS\"] = 4] = \"INDEX_BRACKETS\";\n        Precedence[Precedence[\"UNION\"] = 5] = \"UNION\";\n        Precedence[Precedence[\"INTERSECTION\"] = 6] = \"INTERSECTION\";\n        Precedence[Precedence[\"PREFIX\"] = 7] = \"PREFIX\";\n        Precedence[Precedence[\"INFIX\"] = 8] = \"INFIX\";\n        Precedence[Precedence[\"TUPLE\"] = 9] = \"TUPLE\";\n        Precedence[Precedence[\"SYMBOL\"] = 10] = \"SYMBOL\";\n        Precedence[Precedence[\"OPTIONAL\"] = 11] = \"OPTIONAL\";\n        Precedence[Precedence[\"NULLABLE\"] = 12] = \"NULLABLE\";\n        Precedence[Precedence[\"KEY_OF_TYPE_OF\"] = 13] = \"KEY_OF_TYPE_OF\";\n        Precedence[Precedence[\"FUNCTION\"] = 14] = \"FUNCTION\";\n        Precedence[Precedence[\"ARROW\"] = 15] = \"ARROW\";\n        Precedence[Precedence[\"ARRAY_BRACKETS\"] = 16] = \"ARRAY_BRACKETS\";\n        Precedence[Precedence[\"GENERIC\"] = 17] = \"GENERIC\";\n        Precedence[Precedence[\"NAME_PATH\"] = 18] = \"NAME_PATH\";\n        Precedence[Precedence[\"PARENTHESIS\"] = 19] = \"PARENTHESIS\";\n        Precedence[Precedence[\"SPECIAL_TYPES\"] = 20] = \"SPECIAL_TYPES\";\n    })(Precedence || (Precedence = {}));\n\n    class Parser {\n        constructor(grammar, textOrLexer, baseParser) {\n            this.grammar = grammar;\n            if (typeof textOrLexer === 'string') {\n                this._lexer = Lexer.create(textOrLexer);\n            }\n            else {\n                this._lexer = textOrLexer;\n            }\n            this.baseParser = baseParser;\n        }\n        get lexer() {\n            return this._lexer;\n        }\n        /**\n         * Parses a given string and throws an error if the parse ended before the end of the string.\n         */\n        parse() {\n            const result = this.parseType(Precedence.ALL);\n            if (this.lexer.current.type !== 'EOF') {\n                throw new EarlyEndOfParseError(this.lexer.current);\n            }\n            return result;\n        }\n        /**\n         * Parses with the current lexer and asserts that the result is a {@link RootResult}.\n         */\n        parseType(precedence) {\n            return assertRootResult(this.parseIntermediateType(precedence));\n        }\n        /**\n         * The main parsing function. First it tries to parse the current state in the prefix step, and then it continues\n         * to parse the state in the infix step.\n         */\n        parseIntermediateType(precedence) {\n            const result = this.tryParslets(null, precedence);\n            if (result === null) {\n                throw new NoParsletFoundError(this.lexer.current);\n            }\n            return this.parseInfixIntermediateType(result, precedence);\n        }\n        /**\n         * In the infix parsing step the parser continues to parse the current state with all parslets until none returns\n         * a result.\n         */\n        parseInfixIntermediateType(left, precedence) {\n            let result = this.tryParslets(left, precedence);\n            while (result !== null) {\n                left = result;\n                result = this.tryParslets(left, precedence);\n            }\n            return left;\n        }\n        /**\n         * Tries to parse the current state with all parslets in the grammar and returns the first non null result.\n         */\n        tryParslets(left, precedence) {\n            for (const parslet of this.grammar) {\n                const result = parslet(this, precedence, left);\n                if (result !== null) {\n                    return result;\n                }\n            }\n            return null;\n        }\n        /**\n         * If the given type equals the current type of the {@link Lexer} advance the lexer. Return true if the lexer was\n         * advanced.\n         */\n        consume(types) {\n            if (!Array.isArray(types)) {\n                types = [types];\n            }\n            if (types.includes(this.lexer.current.type)) {\n                this._lexer = this.lexer.advance();\n                return true;\n            }\n            else {\n                return false;\n            }\n        }\n        acceptLexerState(parser) {\n            this._lexer = parser.lexer;\n        }\n    }\n\n    function isQuestionMarkUnknownType(next) {\n        return next === 'EOF' || next === '|' || next === ',' || next === ')' || next === '>';\n    }\n\n    const nullableParslet = (parser, precedence, left) => {\n        const type = parser.lexer.current.type;\n        const next = parser.lexer.next.type;\n        const accept = ((left == null) && type === '?' && !isQuestionMarkUnknownType(next)) ||\n            ((left != null) && type === '?');\n        if (!accept) {\n            return null;\n        }\n        parser.consume('?');\n        if (left == null) {\n            return {\n                type: 'JsdocTypeNullable',\n                element: parser.parseType(Precedence.NULLABLE),\n                meta: {\n                    position: 'prefix'\n                }\n            };\n        }\n        else {\n            return {\n                type: 'JsdocTypeNullable',\n                element: assertRootResult(left),\n                meta: {\n                    position: 'suffix'\n                }\n            };\n        }\n    };\n\n    function composeParslet(options) {\n        const parslet = (parser, curPrecedence, left) => {\n            const type = parser.lexer.current.type;\n            const next = parser.lexer.next.type;\n            if (left === null) {\n                if ('parsePrefix' in options) {\n                    if (options.accept(type, next)) {\n                        return options.parsePrefix(parser);\n                    }\n                }\n            }\n            else {\n                if ('parseInfix' in options) {\n                    if (options.precedence > curPrecedence && options.accept(type, next)) {\n                        return options.parseInfix(parser, left);\n                    }\n                }\n            }\n            return null;\n        };\n        // for debugging\n        Object.defineProperty(parslet, 'name', {\n            value: options.name\n        });\n        return parslet;\n    }\n\n    const optionalParslet = composeParslet({\n        name: 'optionalParslet',\n        accept: type => type === '=',\n        precedence: Precedence.OPTIONAL,\n        parsePrefix: parser => {\n            parser.consume('=');\n            return {\n                type: 'JsdocTypeOptional',\n                element: parser.parseType(Precedence.OPTIONAL),\n                meta: {\n                    position: 'prefix'\n                }\n            };\n        },\n        parseInfix: (parser, left) => {\n            parser.consume('=');\n            return {\n                type: 'JsdocTypeOptional',\n                element: assertRootResult(left),\n                meta: {\n                    position: 'suffix'\n                }\n            };\n        }\n    });\n\n    const numberParslet = composeParslet({\n        name: 'numberParslet',\n        accept: type => type === 'Number',\n        parsePrefix: parser => {\n            const value = parseFloat(parser.lexer.current.text);\n            parser.consume('Number');\n            return {\n                type: 'JsdocTypeNumber',\n                value\n            };\n        }\n    });\n\n    const parenthesisParslet = composeParslet({\n        name: 'parenthesisParslet',\n        accept: type => type === '(',\n        parsePrefix: parser => {\n            parser.consume('(');\n            if (parser.consume(')')) {\n                return {\n                    type: 'JsdocTypeParameterList',\n                    elements: []\n                };\n            }\n            const result = parser.parseIntermediateType(Precedence.ALL);\n            if (!parser.consume(')')) {\n                throw new Error('Unterminated parenthesis');\n            }\n            if (result.type === 'JsdocTypeParameterList') {\n                return result;\n            }\n            else if (result.type === 'JsdocTypeKeyValue') {\n                return {\n                    type: 'JsdocTypeParameterList',\n                    elements: [result]\n                };\n            }\n            return {\n                type: 'JsdocTypeParenthesis',\n                element: assertRootResult(result)\n            };\n        }\n    });\n\n    const specialTypesParslet = composeParslet({\n        name: 'specialTypesParslet',\n        accept: (type, next) => (type === '?' && isQuestionMarkUnknownType(next)) ||\n            type === 'null' || type === 'undefined' || type === '*',\n        parsePrefix: parser => {\n            if (parser.consume('null')) {\n                return {\n                    type: 'JsdocTypeNull'\n                };\n            }\n            if (parser.consume('undefined')) {\n                return {\n                    type: 'JsdocTypeUndefined'\n                };\n            }\n            if (parser.consume('*')) {\n                return {\n                    type: 'JsdocTypeAny'\n                };\n            }\n            if (parser.consume('?')) {\n                return {\n                    type: 'JsdocTypeUnknown'\n                };\n            }\n            throw new Error('Unacceptable token: ' + parser.lexer.current.text);\n        }\n    });\n\n    const notNullableParslet = composeParslet({\n        name: 'notNullableParslet',\n        accept: type => type === '!',\n        precedence: Precedence.NULLABLE,\n        parsePrefix: parser => {\n            parser.consume('!');\n            return {\n                type: 'JsdocTypeNotNullable',\n                element: parser.parseType(Precedence.NULLABLE),\n                meta: {\n                    position: 'prefix'\n                }\n            };\n        },\n        parseInfix: (parser, left) => {\n            parser.consume('!');\n            return {\n                type: 'JsdocTypeNotNullable',\n                element: assertRootResult(left),\n                meta: {\n                    position: 'suffix'\n                }\n            };\n        }\n    });\n\n    function createParameterListParslet({ allowTrailingComma }) {\n        return composeParslet({\n            name: 'parameterListParslet',\n            accept: type => type === ',',\n            precedence: Precedence.PARAMETER_LIST,\n            parseInfix: (parser, left) => {\n                const elements = [\n                    assertPlainKeyValueOrRootResult(left)\n                ];\n                parser.consume(',');\n                do {\n                    try {\n                        const next = parser.parseIntermediateType(Precedence.PARAMETER_LIST);\n                        elements.push(assertPlainKeyValueOrRootResult(next));\n                    }\n                    catch (e) {\n                        if (allowTrailingComma && e instanceof NoParsletFoundError) {\n                            break;\n                        }\n                        else {\n                            throw e;\n                        }\n                    }\n                } while (parser.consume(','));\n                if (elements.length > 0 && elements.slice(0, -1).some(e => e.type === 'JsdocTypeVariadic')) {\n                    throw new Error('Only the last parameter may be a rest parameter');\n                }\n                return {\n                    type: 'JsdocTypeParameterList',\n                    elements\n                };\n            }\n        });\n    }\n\n    const genericParslet = composeParslet({\n        name: 'genericParslet',\n        accept: (type, next) => type === '<' || (type === '.' && next === '<'),\n        precedence: Precedence.GENERIC,\n        parseInfix: (parser, left) => {\n            const dot = parser.consume('.');\n            parser.consume('<');\n            const objects = [];\n            do {\n                objects.push(parser.parseType(Precedence.PARAMETER_LIST));\n            } while (parser.consume(','));\n            if (!parser.consume('>')) {\n                throw new Error('Unterminated generic parameter list');\n            }\n            return {\n                type: 'JsdocTypeGeneric',\n                left: assertRootResult(left),\n                elements: objects,\n                meta: {\n                    brackets: 'angle',\n                    dot\n                }\n            };\n        }\n    });\n\n    const unionParslet = composeParslet({\n        name: 'unionParslet',\n        accept: type => type === '|',\n        precedence: Precedence.UNION,\n        parseInfix: (parser, left) => {\n            parser.consume('|');\n            const elements = [];\n            do {\n                elements.push(parser.parseType(Precedence.UNION));\n            } while (parser.consume('|'));\n            return {\n                type: 'JsdocTypeUnion',\n                elements: [assertRootResult(left), ...elements]\n            };\n        }\n    });\n\n    const baseGrammar = [\n        nullableParslet,\n        optionalParslet,\n        numberParslet,\n        parenthesisParslet,\n        specialTypesParslet,\n        notNullableParslet,\n        createParameterListParslet({\n            allowTrailingComma: true\n        }),\n        genericParslet,\n        unionParslet,\n        optionalParslet\n    ];\n\n    function createNamePathParslet({ allowSquareBracketsOnAnyType, allowJsdocNamePaths, pathGrammar }) {\n        return function namePathParslet(parser, precedence, left) {\n            if ((left == null) || precedence >= Precedence.NAME_PATH) {\n                return null;\n            }\n            const type = parser.lexer.current.type;\n            const next = parser.lexer.next.type;\n            const accept = (type === '.' && next !== '<') ||\n                (type === '[' && (allowSquareBracketsOnAnyType || left.type === 'JsdocTypeName')) ||\n                (allowJsdocNamePaths && (type === '~' || type === '#'));\n            if (!accept) {\n                return null;\n            }\n            let pathType;\n            let brackets = false;\n            if (parser.consume('.')) {\n                pathType = 'property';\n            }\n            else if (parser.consume('[')) {\n                pathType = 'property-brackets';\n                brackets = true;\n            }\n            else if (parser.consume('~')) {\n                pathType = 'inner';\n            }\n            else {\n                parser.consume('#');\n                pathType = 'instance';\n            }\n            const pathParser = pathGrammar !== null\n                ? new Parser(pathGrammar, parser.lexer, parser)\n                : parser;\n            const parsed = pathParser.parseIntermediateType(Precedence.NAME_PATH);\n            parser.acceptLexerState(pathParser);\n            let right;\n            switch (parsed.type) {\n                case 'JsdocTypeName':\n                    right = {\n                        type: 'JsdocTypeProperty',\n                        value: parsed.value,\n                        meta: {\n                            quote: undefined\n                        }\n                    };\n                    break;\n                case 'JsdocTypeNumber':\n                    right = {\n                        type: 'JsdocTypeProperty',\n                        value: parsed.value.toString(10),\n                        meta: {\n                            quote: undefined\n                        }\n                    };\n                    break;\n                case 'JsdocTypeStringValue':\n                    right = {\n                        type: 'JsdocTypeProperty',\n                        value: parsed.value,\n                        meta: {\n                            quote: parsed.meta.quote\n                        }\n                    };\n                    break;\n                case 'JsdocTypeSpecialNamePath':\n                    if (parsed.specialType === 'event') {\n                        right = parsed;\n                    }\n                    else {\n                        throw new UnexpectedTypeError(parsed, 'Type \\'JsdocTypeSpecialNamePath\\' is only allowed with specialType \\'event\\'');\n                    }\n                    break;\n                default:\n                    throw new UnexpectedTypeError(parsed, 'Expecting \\'JsdocTypeName\\', \\'JsdocTypeNumber\\', \\'JsdocStringValue\\' or \\'JsdocTypeSpecialNamePath\\'');\n            }\n            if (brackets && !parser.consume(']')) {\n                const token = parser.lexer.current;\n                throw new Error(`Unterminated square brackets. Next token is '${token.type}' ` +\n                    `with text '${token.text}'`);\n            }\n            return {\n                type: 'JsdocTypeNamePath',\n                left: assertRootResult(left),\n                right,\n                pathType\n            };\n        };\n    }\n\n    function createNameParslet({ allowedAdditionalTokens }) {\n        return composeParslet({\n            name: 'nameParslet',\n            accept: type => type === 'Identifier' || type === 'this' || type === 'new' || allowedAdditionalTokens.includes(type),\n            parsePrefix: parser => {\n                const { type, text } = parser.lexer.current;\n                parser.consume(type);\n                return {\n                    type: 'JsdocTypeName',\n                    value: text\n                };\n            }\n        });\n    }\n\n    const stringValueParslet = composeParslet({\n        name: 'stringValueParslet',\n        accept: type => type === 'StringValue',\n        parsePrefix: parser => {\n            const text = parser.lexer.current.text;\n            parser.consume('StringValue');\n            return {\n                type: 'JsdocTypeStringValue',\n                value: text.slice(1, -1),\n                meta: {\n                    quote: text[0] === '\\'' ? 'single' : 'double'\n                }\n            };\n        }\n    });\n\n    function createSpecialNamePathParslet({ pathGrammar, allowedTypes }) {\n        return composeParslet({\n            name: 'specialNamePathParslet',\n            accept: type => allowedTypes.includes(type),\n            parsePrefix: parser => {\n                const type = parser.lexer.current.type;\n                parser.consume(type);\n                if (!parser.consume(':')) {\n                    return {\n                        type: 'JsdocTypeName',\n                        value: type\n                    };\n                }\n                let result;\n                let token = parser.lexer.current;\n                if (parser.consume('StringValue')) {\n                    result = {\n                        type: 'JsdocTypeSpecialNamePath',\n                        value: token.text.slice(1, -1),\n                        specialType: type,\n                        meta: {\n                            quote: token.text[0] === '\\'' ? 'single' : 'double'\n                        }\n                    };\n                }\n                else {\n                    let value = '';\n                    const allowed = ['Identifier', '@', '/'];\n                    while (allowed.some(type => parser.consume(type))) {\n                        value += token.text;\n                        token = parser.lexer.current;\n                    }\n                    result = {\n                        type: 'JsdocTypeSpecialNamePath',\n                        value,\n                        specialType: type,\n                        meta: {\n                            quote: undefined\n                        }\n                    };\n                }\n                const moduleParser = new Parser(pathGrammar, parser.lexer, parser);\n                const moduleResult = moduleParser.parseInfixIntermediateType(result, Precedence.ALL);\n                parser.acceptLexerState(moduleParser);\n                return assertRootResult(moduleResult);\n            }\n        });\n    }\n\n    const basePathGrammar = [\n        createNameParslet({\n            allowedAdditionalTokens: ['external', 'module']\n        }),\n        stringValueParslet,\n        numberParslet,\n        createNamePathParslet({\n            allowSquareBracketsOnAnyType: false,\n            allowJsdocNamePaths: true,\n            pathGrammar: null\n        })\n    ];\n    const pathGrammar = [\n        ...basePathGrammar,\n        createSpecialNamePathParslet({\n            allowedTypes: ['event'],\n            pathGrammar: basePathGrammar\n        })\n    ];\n\n    function getParameters(value) {\n        let parameters;\n        if (value.type === 'JsdocTypeParameterList') {\n            parameters = value.elements;\n        }\n        else if (value.type === 'JsdocTypeParenthesis') {\n            parameters = [value.element];\n        }\n        else {\n            throw new UnexpectedTypeError(value);\n        }\n        return parameters.map(p => assertPlainKeyValueOrRootResult(p));\n    }\n    function getUnnamedParameters(value) {\n        const parameters = getParameters(value);\n        if (parameters.some(p => p.type === 'JsdocTypeKeyValue')) {\n            throw new Error('No parameter should be named');\n        }\n        return parameters;\n    }\n    function createFunctionParslet({ allowNamedParameters, allowNoReturnType, allowWithoutParenthesis, allowNewAsFunctionKeyword }) {\n        return composeParslet({\n            name: 'functionParslet',\n            accept: (type, next) => type === 'function' || (allowNewAsFunctionKeyword && type === 'new' && next === '('),\n            parsePrefix: parser => {\n                const newKeyword = parser.consume('new');\n                parser.consume('function');\n                const hasParenthesis = parser.lexer.current.type === '(';\n                if (!hasParenthesis) {\n                    if (!allowWithoutParenthesis) {\n                        throw new Error('function is missing parameter list');\n                    }\n                    return {\n                        type: 'JsdocTypeName',\n                        value: 'function'\n                    };\n                }\n                let result = {\n                    type: 'JsdocTypeFunction',\n                    parameters: [],\n                    arrow: false,\n                    constructor: newKeyword,\n                    parenthesis: hasParenthesis\n                };\n                const value = parser.parseIntermediateType(Precedence.FUNCTION);\n                if (allowNamedParameters === undefined) {\n                    result.parameters = getUnnamedParameters(value);\n                }\n                else if (newKeyword && value.type === 'JsdocTypeFunction' && value.arrow) {\n                    result = value;\n                    result.constructor = true;\n                    return result;\n                }\n                else {\n                    result.parameters = getParameters(value);\n                    for (const p of result.parameters) {\n                        if (p.type === 'JsdocTypeKeyValue' && (!allowNamedParameters.includes(p.key))) {\n                            throw new Error(`only allowed named parameters are ${allowNamedParameters.join(', ')} but got ${p.type}`);\n                        }\n                    }\n                }\n                if (parser.consume(':')) {\n                    result.returnType = parser.parseType(Precedence.PREFIX);\n                }\n                else {\n                    if (!allowNoReturnType) {\n                        throw new Error('function is missing return type');\n                    }\n                }\n                return result;\n            }\n        });\n    }\n\n    function createVariadicParslet({ allowPostfix, allowEnclosingBrackets }) {\n        return composeParslet({\n            name: 'variadicParslet',\n            accept: type => type === '...',\n            precedence: Precedence.PREFIX,\n            parsePrefix: parser => {\n                parser.consume('...');\n                const brackets = allowEnclosingBrackets && parser.consume('[');\n                try {\n                    const element = parser.parseType(Precedence.PREFIX);\n                    if (brackets && !parser.consume(']')) {\n                        throw new Error('Unterminated variadic type. Missing \\']\\'');\n                    }\n                    return {\n                        type: 'JsdocTypeVariadic',\n                        element: assertRootResult(element),\n                        meta: {\n                            position: 'prefix',\n                            squareBrackets: brackets\n                        }\n                    };\n                }\n                catch (e) {\n                    if (e instanceof NoParsletFoundError) {\n                        if (brackets) {\n                            throw new Error('Empty square brackets for variadic are not allowed.');\n                        }\n                        return {\n                            type: 'JsdocTypeVariadic',\n                            meta: {\n                                position: undefined,\n                                squareBrackets: false\n                            }\n                        };\n                    }\n                    else {\n                        throw e;\n                    }\n                }\n            },\n            parseInfix: allowPostfix\n                ? (parser, left) => {\n                    parser.consume('...');\n                    return {\n                        type: 'JsdocTypeVariadic',\n                        element: assertRootResult(left),\n                        meta: {\n                            position: 'suffix',\n                            squareBrackets: false\n                        }\n                    };\n                }\n                : undefined\n        });\n    }\n\n    const symbolParslet = composeParslet({\n        name: 'symbolParslet',\n        accept: type => type === '(',\n        precedence: Precedence.SYMBOL,\n        parseInfix: (parser, left) => {\n            if (left.type !== 'JsdocTypeName') {\n                throw new Error('Symbol expects a name on the left side. (Reacting on \\'(\\')');\n            }\n            parser.consume('(');\n            const result = {\n                type: 'JsdocTypeSymbol',\n                value: left.value\n            };\n            if (!parser.consume(')')) {\n                const next = parser.parseIntermediateType(Precedence.SYMBOL);\n                result.element = assertNumberOrVariadicNameResult(next);\n                if (!parser.consume(')')) {\n                    throw new Error('Symbol does not end after value');\n                }\n            }\n            return result;\n        }\n    });\n\n    const arrayBracketsParslet = composeParslet({\n        name: 'arrayBracketsParslet',\n        precedence: Precedence.ARRAY_BRACKETS,\n        accept: (type, next) => type === '[' && next === ']',\n        parseInfix: (parser, left) => {\n            parser.consume('[');\n            parser.consume(']');\n            return {\n                type: 'JsdocTypeGeneric',\n                left: {\n                    type: 'JsdocTypeName',\n                    value: 'Array'\n                },\n                elements: [\n                    assertRootResult(left)\n                ],\n                meta: {\n                    brackets: 'square',\n                    dot: false\n                }\n            };\n        }\n    });\n\n    function createObjectParslet({ objectFieldGrammar, allowKeyTypes }) {\n        return composeParslet({\n            name: 'objectParslet',\n            accept: type => type === '{',\n            parsePrefix: parser => {\n                parser.consume('{');\n                const result = {\n                    type: 'JsdocTypeObject',\n                    meta: {\n                        separator: 'comma'\n                    },\n                    elements: []\n                };\n                if (!parser.consume('}')) {\n                    let separator;\n                    const fieldParser = new Parser(objectFieldGrammar, parser.lexer, parser);\n                    while (true) {\n                        fieldParser.acceptLexerState(parser);\n                        let field = fieldParser.parseIntermediateType(Precedence.OBJECT);\n                        parser.acceptLexerState(fieldParser);\n                        if (field === undefined && allowKeyTypes) {\n                            field = parser.parseIntermediateType(Precedence.OBJECT);\n                        }\n                        let optional = false;\n                        if (field.type === 'JsdocTypeNullable') {\n                            optional = true;\n                            field = field.element;\n                        }\n                        if (field.type === 'JsdocTypeNumber' || field.type === 'JsdocTypeName' || field.type === 'JsdocTypeStringValue') {\n                            let quote;\n                            if (field.type === 'JsdocTypeStringValue') {\n                                quote = field.meta.quote;\n                            }\n                            result.elements.push({\n                                type: 'JsdocTypeObjectField',\n                                key: field.value.toString(),\n                                right: undefined,\n                                optional,\n                                readonly: false,\n                                meta: {\n                                    quote\n                                }\n                            });\n                        }\n                        else if (field.type === 'JsdocTypeObjectField' || field.type === 'JsdocTypeJsdocObjectField') {\n                            result.elements.push(field);\n                        }\n                        else {\n                            throw new UnexpectedTypeError(field);\n                        }\n                        if (parser.lexer.current.startOfLine) {\n                            separator = 'linebreak';\n                        }\n                        else if (parser.consume(',')) {\n                            separator = 'comma';\n                        }\n                        else if (parser.consume(';')) {\n                            separator = 'semicolon';\n                        }\n                        else {\n                            break;\n                        }\n                        const type = parser.lexer.current.type;\n                        if (type === '}') {\n                            break;\n                        }\n                    }\n                    result.meta.separator = separator !== null && separator !== void 0 ? separator : 'comma'; // TODO: use undefined here\n                    if (!parser.consume('}')) {\n                        throw new Error('Unterminated record type. Missing \\'}\\'');\n                    }\n                }\n                return result;\n            }\n        });\n    }\n\n    function createObjectFieldParslet({ allowSquaredProperties, allowKeyTypes, allowReadonly, allowOptional }) {\n        return composeParslet({\n            name: 'objectFieldParslet',\n            precedence: Precedence.KEY_VALUE,\n            accept: type => type === ':',\n            parseInfix: (parser, left) => {\n                var _a;\n                let optional = false;\n                let readonlyProperty = false;\n                if (allowOptional && left.type === 'JsdocTypeNullable') {\n                    optional = true;\n                    left = left.element;\n                }\n                if (allowReadonly && left.type === 'JsdocTypeReadonlyProperty') {\n                    readonlyProperty = true;\n                    left = left.element;\n                }\n                // object parslet uses a special grammar and for the value we want to switch back to the parent\n                const parentParser = (_a = parser.baseParser) !== null && _a !== void 0 ? _a : parser;\n                parentParser.acceptLexerState(parser);\n                if (left.type === 'JsdocTypeNumber' || left.type === 'JsdocTypeName' || left.type === 'JsdocTypeStringValue' ||\n                    isSquaredProperty(left)) {\n                    if (isSquaredProperty(left) && !allowSquaredProperties) {\n                        throw new UnexpectedTypeError(left);\n                    }\n                    parentParser.consume(':');\n                    let quote;\n                    if (left.type === 'JsdocTypeStringValue') {\n                        quote = left.meta.quote;\n                    }\n                    const right = parentParser.parseType(Precedence.KEY_VALUE);\n                    parser.acceptLexerState(parentParser);\n                    return {\n                        type: 'JsdocTypeObjectField',\n                        key: isSquaredProperty(left) ? left : left.value.toString(),\n                        right,\n                        optional,\n                        readonly: readonlyProperty,\n                        meta: {\n                            quote\n                        }\n                    };\n                }\n                else {\n                    if (!allowKeyTypes) {\n                        throw new UnexpectedTypeError(left);\n                    }\n                    parentParser.consume(':');\n                    const right = parentParser.parseType(Precedence.KEY_VALUE);\n                    parser.acceptLexerState(parentParser);\n                    return {\n                        type: 'JsdocTypeJsdocObjectField',\n                        left: assertRootResult(left),\n                        right\n                    };\n                }\n            }\n        });\n    }\n\n    function createKeyValueParslet({ allowOptional, allowVariadic }) {\n        return composeParslet({\n            name: 'keyValueParslet',\n            precedence: Precedence.KEY_VALUE,\n            accept: type => type === ':',\n            parseInfix: (parser, left) => {\n                let optional = false;\n                let variadic = false;\n                if (allowOptional && left.type === 'JsdocTypeNullable') {\n                    optional = true;\n                    left = left.element;\n                }\n                if (allowVariadic && left.type === 'JsdocTypeVariadic' && left.element !== undefined) {\n                    variadic = true;\n                    left = left.element;\n                }\n                if (left.type !== 'JsdocTypeName') {\n                    throw new UnexpectedTypeError(left);\n                }\n                parser.consume(':');\n                const right = parser.parseType(Precedence.KEY_VALUE);\n                return {\n                    type: 'JsdocTypeKeyValue',\n                    key: left.value,\n                    right,\n                    optional,\n                    variadic\n                };\n            }\n        });\n    }\n\n    const jsdocBaseGrammar = [\n        ...baseGrammar,\n        createFunctionParslet({\n            allowWithoutParenthesis: true,\n            allowNamedParameters: ['this', 'new'],\n            allowNoReturnType: true,\n            allowNewAsFunctionKeyword: false\n        }),\n        stringValueParslet,\n        createSpecialNamePathParslet({\n            allowedTypes: ['module', 'external', 'event'],\n            pathGrammar\n        }),\n        createVariadicParslet({\n            allowEnclosingBrackets: true,\n            allowPostfix: true\n        }),\n        createNameParslet({\n            allowedAdditionalTokens: ['keyof']\n        }),\n        symbolParslet,\n        arrayBracketsParslet,\n        createNamePathParslet({\n            allowSquareBracketsOnAnyType: false,\n            allowJsdocNamePaths: true,\n            pathGrammar\n        })\n    ];\n    const jsdocGrammar = [\n        ...jsdocBaseGrammar,\n        createObjectParslet({\n            // jsdoc syntax allows full types as keys, so we need to pull in the full grammar here\n            // we leave out the object type deliberately\n            objectFieldGrammar: [\n                createNameParslet({\n                    allowedAdditionalTokens: ['module', 'in']\n                }),\n                createObjectFieldParslet({\n                    allowSquaredProperties: false,\n                    allowKeyTypes: true,\n                    allowOptional: false,\n                    allowReadonly: false\n                }),\n                ...jsdocBaseGrammar\n            ],\n            allowKeyTypes: true\n        }),\n        createKeyValueParslet({\n            allowOptional: true,\n            allowVariadic: true\n        })\n    ];\n\n    const typeOfParslet = composeParslet({\n        name: 'typeOfParslet',\n        accept: type => type === 'typeof',\n        parsePrefix: parser => {\n            parser.consume('typeof');\n            return {\n                type: 'JsdocTypeTypeof',\n                element: assertRootResult(parser.parseType(Precedence.KEY_OF_TYPE_OF))\n            };\n        }\n    });\n\n    const objectFieldGrammar$1 = [\n        createNameParslet({\n            allowedAdditionalTokens: ['module', 'keyof', 'event', 'external', 'in']\n        }),\n        nullableParslet,\n        optionalParslet,\n        stringValueParslet,\n        numberParslet,\n        createObjectFieldParslet({\n            allowSquaredProperties: false,\n            allowKeyTypes: false,\n            allowOptional: false,\n            allowReadonly: false\n        })\n    ];\n    const closureGrammar = [\n        ...baseGrammar,\n        createObjectParslet({\n            allowKeyTypes: false,\n            objectFieldGrammar: objectFieldGrammar$1\n        }),\n        createNameParslet({\n            allowedAdditionalTokens: ['event', 'external', 'in']\n        }),\n        typeOfParslet,\n        createFunctionParslet({\n            allowWithoutParenthesis: false,\n            allowNamedParameters: ['this', 'new'],\n            allowNoReturnType: true,\n            allowNewAsFunctionKeyword: false\n        }),\n        createVariadicParslet({\n            allowEnclosingBrackets: false,\n            allowPostfix: false\n        }),\n        // additional name parslet is needed for some special cases\n        createNameParslet({\n            allowedAdditionalTokens: ['keyof']\n        }),\n        createSpecialNamePathParslet({\n            allowedTypes: ['module'],\n            pathGrammar\n        }),\n        createNamePathParslet({\n            allowSquareBracketsOnAnyType: false,\n            allowJsdocNamePaths: true,\n            pathGrammar\n        }),\n        createKeyValueParslet({\n            allowOptional: false,\n            allowVariadic: false\n        }),\n        symbolParslet\n    ];\n\n    const assertsParslet = composeParslet({\n        name: 'assertsParslet',\n        accept: type => type === 'asserts',\n        parsePrefix: (parser) => {\n            parser.consume('asserts');\n            const left = parser.parseIntermediateType(Precedence.SYMBOL);\n            if (left.type !== 'JsdocTypeName') {\n                throw new UnexpectedTypeError(left, 'A typescript asserts always has to have a name on the left side.');\n            }\n            parser.consume('is');\n            return {\n                type: 'JsdocTypeAsserts',\n                left,\n                right: assertRootResult(parser.parseIntermediateType(Precedence.INFIX))\n            };\n        }\n    });\n\n    function createTupleParslet({ allowQuestionMark }) {\n        return composeParslet({\n            name: 'tupleParslet',\n            accept: type => type === '[',\n            parsePrefix: parser => {\n                parser.consume('[');\n                const result = {\n                    type: 'JsdocTypeTuple',\n                    elements: []\n                };\n                if (parser.consume(']')) {\n                    return result;\n                }\n                const typeList = parser.parseIntermediateType(Precedence.ALL);\n                if (typeList.type === 'JsdocTypeParameterList') {\n                    if (typeList.elements[0].type === 'JsdocTypeKeyValue') {\n                        result.elements = typeList.elements.map(assertPlainKeyValueResult);\n                    }\n                    else {\n                        result.elements = typeList.elements.map(assertRootResult);\n                    }\n                }\n                else {\n                    if (typeList.type === 'JsdocTypeKeyValue') {\n                        result.elements = [assertPlainKeyValueResult(typeList)];\n                    }\n                    else {\n                        result.elements = [assertRootResult(typeList)];\n                    }\n                }\n                if (!parser.consume(']')) {\n                    throw new Error('Unterminated \\'[\\'');\n                }\n                if (!allowQuestionMark && result.elements.some((e) => e.type === 'JsdocTypeUnknown')) {\n                    throw new Error('Question mark in tuple not allowed');\n                }\n                return result;\n            }\n        });\n    }\n\n    const keyOfParslet = composeParslet({\n        name: 'keyOfParslet',\n        accept: type => type === 'keyof',\n        parsePrefix: parser => {\n            parser.consume('keyof');\n            return {\n                type: 'JsdocTypeKeyof',\n                element: assertRootResult(parser.parseType(Precedence.KEY_OF_TYPE_OF))\n            };\n        }\n    });\n\n    const importParslet = composeParslet({\n        name: 'importParslet',\n        accept: type => type === 'import',\n        parsePrefix: parser => {\n            parser.consume('import');\n            if (!parser.consume('(')) {\n                throw new Error('Missing parenthesis after import keyword');\n            }\n            const path = parser.parseType(Precedence.PREFIX);\n            if (path.type !== 'JsdocTypeStringValue') {\n                throw new Error('Only string values are allowed as paths for imports');\n            }\n            if (!parser.consume(')')) {\n                throw new Error('Missing closing parenthesis after import keyword');\n            }\n            return {\n                type: 'JsdocTypeImport',\n                element: path\n            };\n        }\n    });\n\n    const readonlyPropertyParslet = composeParslet({\n        name: 'readonlyPropertyParslet',\n        accept: type => type === 'readonly',\n        parsePrefix: parser => {\n            parser.consume('readonly');\n            return {\n                type: 'JsdocTypeReadonlyProperty',\n                element: parser.parseType(Precedence.KEY_VALUE)\n            };\n        }\n    });\n\n    const arrowFunctionParslet = composeParslet({\n        name: 'arrowFunctionParslet',\n        precedence: Precedence.ARROW,\n        accept: type => type === '=>',\n        parseInfix: (parser, left) => {\n            parser.consume('=>');\n            return {\n                type: 'JsdocTypeFunction',\n                parameters: getParameters(left).map(assertPlainKeyValueOrNameResult),\n                arrow: true,\n                constructor: false,\n                parenthesis: true,\n                returnType: parser.parseType(Precedence.OBJECT)\n            };\n        }\n    });\n\n    const intersectionParslet = composeParslet({\n        name: 'intersectionParslet',\n        accept: type => type === '&',\n        precedence: Precedence.INTERSECTION,\n        parseInfix: (parser, left) => {\n            parser.consume('&');\n            const elements = [];\n            do {\n                elements.push(parser.parseType(Precedence.INTERSECTION));\n            } while (parser.consume('&'));\n            return {\n                type: 'JsdocTypeIntersection',\n                elements: [assertRootResult(left), ...elements]\n            };\n        }\n    });\n\n    const predicateParslet = composeParslet({\n        name: 'predicateParslet',\n        precedence: Precedence.INFIX,\n        accept: type => type === 'is',\n        parseInfix: (parser, left) => {\n            if (left.type !== 'JsdocTypeName') {\n                throw new UnexpectedTypeError(left, 'A typescript predicate always has to have a name on the left side.');\n            }\n            parser.consume('is');\n            return {\n                type: 'JsdocTypePredicate',\n                left,\n                right: assertRootResult(parser.parseIntermediateType(Precedence.INFIX))\n            };\n        }\n    });\n\n    const objectSquaredPropertyParslet = composeParslet({\n        name: 'objectSquareBracketPropertyParslet',\n        accept: type => type === '[',\n        parsePrefix: parser => {\n            if (parser.baseParser === undefined) {\n                throw new Error('Only allowed inside object grammar');\n            }\n            parser.consume('[');\n            const key = parser.lexer.current.text;\n            parser.consume('Identifier');\n            let result;\n            if (parser.consume(':')) {\n                const parentParser = parser.baseParser;\n                parentParser.acceptLexerState(parser);\n                result = {\n                    type: 'JsdocTypeIndexSignature',\n                    key,\n                    right: parentParser.parseType(Precedence.INDEX_BRACKETS)\n                };\n                parser.acceptLexerState(parentParser);\n            }\n            else if (parser.consume('in')) {\n                const parentParser = parser.baseParser;\n                parentParser.acceptLexerState(parser);\n                result = {\n                    type: 'JsdocTypeMappedType',\n                    key,\n                    right: parentParser.parseType(Precedence.ARRAY_BRACKETS)\n                };\n                parser.acceptLexerState(parentParser);\n            }\n            else {\n                throw new Error('Missing \\':\\' or \\'in\\' inside square bracketed property.');\n            }\n            if (!parser.consume(']')) {\n                throw new Error('Unterminated square brackets');\n            }\n            return result;\n        }\n    });\n\n    const objectFieldGrammar = [\n        readonlyPropertyParslet,\n        createNameParslet({\n            allowedAdditionalTokens: ['module', 'event', 'keyof', 'event', 'external', 'in']\n        }),\n        nullableParslet,\n        optionalParslet,\n        stringValueParslet,\n        numberParslet,\n        createObjectFieldParslet({\n            allowSquaredProperties: true,\n            allowKeyTypes: false,\n            allowOptional: true,\n            allowReadonly: true\n        }),\n        objectSquaredPropertyParslet\n    ];\n    const typescriptGrammar = [\n        ...baseGrammar,\n        createObjectParslet({\n            allowKeyTypes: false,\n            objectFieldGrammar\n        }),\n        typeOfParslet,\n        keyOfParslet,\n        importParslet,\n        stringValueParslet,\n        createFunctionParslet({\n            allowWithoutParenthesis: true,\n            allowNoReturnType: false,\n            allowNamedParameters: ['this', 'new', 'args'],\n            allowNewAsFunctionKeyword: true\n        }),\n        createTupleParslet({\n            allowQuestionMark: false\n        }),\n        createVariadicParslet({\n            allowEnclosingBrackets: false,\n            allowPostfix: false\n        }),\n        assertsParslet,\n        createNameParslet({\n            allowedAdditionalTokens: ['event', 'external', 'in']\n        }),\n        createSpecialNamePathParslet({\n            allowedTypes: ['module'],\n            pathGrammar\n        }),\n        arrayBracketsParslet,\n        arrowFunctionParslet,\n        createNamePathParslet({\n            allowSquareBracketsOnAnyType: true,\n            allowJsdocNamePaths: false,\n            pathGrammar\n        }),\n        intersectionParslet,\n        predicateParslet,\n        createKeyValueParslet({\n            allowVariadic: true,\n            allowOptional: true\n        })\n    ];\n\n    /**\n     * This function parses the given expression in the given mode and produces a {@link RootResult}.\n     * @param expression\n     * @param mode\n     */\n    function parse(expression, mode) {\n        switch (mode) {\n            case 'closure':\n                return (new Parser(closureGrammar, expression)).parse();\n            case 'jsdoc':\n                return (new Parser(jsdocGrammar, expression)).parse();\n            case 'typescript':\n                return (new Parser(typescriptGrammar, expression)).parse();\n        }\n    }\n    /**\n     * This function tries to parse the given expression in multiple modes and returns the first successful\n     * {@link RootResult}. By default it tries `'typescript'`, `'closure'` and `'jsdoc'` in this order. If\n     * no mode was successful it throws the error that was produced by the last parsing attempt.\n     * @param expression\n     * @param modes\n     */\n    function tryParse(expression, modes = ['typescript', 'closure', 'jsdoc']) {\n        let error;\n        for (const mode of modes) {\n            try {\n                return parse(expression, mode);\n            }\n            catch (e) {\n                error = e;\n            }\n        }\n        throw error;\n    }\n\n    function transform(rules, parseResult) {\n        const rule = rules[parseResult.type];\n        if (rule === undefined) {\n            throw new Error(`In this set of transform rules exists no rule for type ${parseResult.type}.`);\n        }\n        return rule(parseResult, aParseResult => transform(rules, aParseResult));\n    }\n    function notAvailableTransform(parseResult) {\n        throw new Error('This transform is not available. Are you trying the correct parsing mode?');\n    }\n    function extractSpecialParams(source) {\n        const result = {\n            params: []\n        };\n        for (const param of source.parameters) {\n            if (param.type === 'JsdocTypeKeyValue') {\n                if (param.key === 'this') {\n                    result.this = param.right;\n                }\n                else if (param.key === 'new') {\n                    result.new = param.right;\n                }\n                else {\n                    result.params.push(param);\n                }\n            }\n            else {\n                result.params.push(param);\n            }\n        }\n        return result;\n    }\n\n    function applyPosition(position, target, value) {\n        return position === 'prefix' ? value + target : target + value;\n    }\n    function quote(value, quote) {\n        switch (quote) {\n            case 'double':\n                return `\"${value}\"`;\n            case 'single':\n                return `'${value}'`;\n            case undefined:\n                return value;\n        }\n    }\n    function stringifyRules() {\n        return {\n            JsdocTypeParenthesis: (result, transform) => `(${result.element !== undefined ? transform(result.element) : ''})`,\n            JsdocTypeKeyof: (result, transform) => `keyof ${transform(result.element)}`,\n            JsdocTypeFunction: (result, transform) => {\n                if (!result.arrow) {\n                    let stringified = result.constructor ? 'new' : 'function';\n                    if (!result.parenthesis) {\n                        return stringified;\n                    }\n                    stringified += `(${result.parameters.map(transform).join(', ')})`;\n                    if (result.returnType !== undefined) {\n                        stringified += `: ${transform(result.returnType)}`;\n                    }\n                    return stringified;\n                }\n                else {\n                    if (result.returnType === undefined) {\n                        throw new Error('Arrow function needs a return type.');\n                    }\n                    let stringified = `(${result.parameters.map(transform).join(', ')}) => ${transform(result.returnType)}`;\n                    if (result.constructor) {\n                        stringified = 'new ' + stringified;\n                    }\n                    return stringified;\n                }\n            },\n            JsdocTypeName: result => result.value,\n            JsdocTypeTuple: (result, transform) => `[${result.elements.map(transform).join(', ')}]`,\n            JsdocTypeVariadic: (result, transform) => result.meta.position === undefined\n                ? '...'\n                : applyPosition(result.meta.position, transform(result.element), '...'),\n            JsdocTypeNamePath: (result, transform) => {\n                const left = transform(result.left);\n                const right = transform(result.right);\n                switch (result.pathType) {\n                    case 'inner':\n                        return `${left}~${right}`;\n                    case 'instance':\n                        return `${left}#${right}`;\n                    case 'property':\n                        return `${left}.${right}`;\n                    case 'property-brackets':\n                        return `${left}[${right}]`;\n                }\n            },\n            JsdocTypeStringValue: result => quote(result.value, result.meta.quote),\n            JsdocTypeAny: () => '*',\n            JsdocTypeGeneric: (result, transform) => {\n                if (result.meta.brackets === 'square') {\n                    const element = result.elements[0];\n                    const transformed = transform(element);\n                    if (element.type === 'JsdocTypeUnion' || element.type === 'JsdocTypeIntersection') {\n                        return `(${transformed})[]`;\n                    }\n                    else {\n                        return `${transformed}[]`;\n                    }\n                }\n                else {\n                    return `${transform(result.left)}${result.meta.dot ? '.' : ''}<${result.elements.map(transform).join(', ')}>`;\n                }\n            },\n            JsdocTypeImport: (result, transform) => `import(${transform(result.element)})`,\n            JsdocTypeObjectField: (result, transform) => {\n                let text = '';\n                if (result.readonly) {\n                    text += 'readonly ';\n                }\n                if (typeof result.key === 'string') {\n                    text += quote(result.key, result.meta.quote);\n                }\n                else {\n                    text += transform(result.key);\n                }\n                if (result.optional) {\n                    text += '?';\n                }\n                if (result.right === undefined) {\n                    return text;\n                }\n                else {\n                    return text + `: ${transform(result.right)}`;\n                }\n            },\n            JsdocTypeJsdocObjectField: (result, transform) => {\n                return `${transform(result.left)}: ${transform(result.right)}`;\n            },\n            JsdocTypeKeyValue: (result, transform) => {\n                let text = result.key;\n                if (result.optional) {\n                    text += '?';\n                }\n                if (result.variadic) {\n                    text = '...' + text;\n                }\n                if (result.right === undefined) {\n                    return text;\n                }\n                else {\n                    return text + `: ${transform(result.right)}`;\n                }\n            },\n            JsdocTypeSpecialNamePath: result => `${result.specialType}:${quote(result.value, result.meta.quote)}`,\n            JsdocTypeNotNullable: (result, transform) => applyPosition(result.meta.position, transform(result.element), '!'),\n            JsdocTypeNull: () => 'null',\n            JsdocTypeNullable: (result, transform) => applyPosition(result.meta.position, transform(result.element), '?'),\n            JsdocTypeNumber: result => result.value.toString(),\n            JsdocTypeObject: (result, transform) => `{${result.elements.map(transform).join((result.meta.separator === 'comma' ? ',' : ';') + ' ')}}`,\n            JsdocTypeOptional: (result, transform) => applyPosition(result.meta.position, transform(result.element), '='),\n            JsdocTypeSymbol: (result, transform) => `${result.value}(${result.element !== undefined ? transform(result.element) : ''})`,\n            JsdocTypeTypeof: (result, transform) => `typeof ${transform(result.element)}`,\n            JsdocTypeUndefined: () => 'undefined',\n            JsdocTypeUnion: (result, transform) => result.elements.map(transform).join(' | '),\n            JsdocTypeUnknown: () => '?',\n            JsdocTypeIntersection: (result, transform) => result.elements.map(transform).join(' & '),\n            JsdocTypeProperty: result => quote(result.value, result.meta.quote),\n            JsdocTypePredicate: (result, transform) => `${transform(result.left)} is ${transform(result.right)}`,\n            JsdocTypeIndexSignature: (result, transform) => `[${result.key}: ${transform(result.right)}]`,\n            JsdocTypeMappedType: (result, transform) => `[${result.key} in ${transform(result.right)}]`,\n            JsdocTypeAsserts: (result, transform) => `asserts ${transform(result.left)} is ${transform(result.right)}`\n        };\n    }\n    const storedStringifyRules = stringifyRules();\n    function stringify(result) {\n        return transform(storedStringifyRules, result);\n    }\n\n    const reservedWords = [\n        'null',\n        'true',\n        'false',\n        'break',\n        'case',\n        'catch',\n        'class',\n        'const',\n        'continue',\n        'debugger',\n        'default',\n        'delete',\n        'do',\n        'else',\n        'export',\n        'extends',\n        'finally',\n        'for',\n        'function',\n        'if',\n        'import',\n        'in',\n        'instanceof',\n        'new',\n        'return',\n        'super',\n        'switch',\n        'this',\n        'throw',\n        'try',\n        'typeof',\n        'var',\n        'void',\n        'while',\n        'with',\n        'yield'\n    ];\n    function makeName(value) {\n        const result = {\n            type: 'NameExpression',\n            name: value\n        };\n        if (reservedWords.includes(value)) {\n            result.reservedWord = true;\n        }\n        return result;\n    }\n    const catharsisTransformRules = {\n        JsdocTypeOptional: (result, transform) => {\n            const transformed = transform(result.element);\n            transformed.optional = true;\n            return transformed;\n        },\n        JsdocTypeNullable: (result, transform) => {\n            const transformed = transform(result.element);\n            transformed.nullable = true;\n            return transformed;\n        },\n        JsdocTypeNotNullable: (result, transform) => {\n            const transformed = transform(result.element);\n            transformed.nullable = false;\n            return transformed;\n        },\n        JsdocTypeVariadic: (result, transform) => {\n            if (result.element === undefined) {\n                throw new Error('dots without value are not allowed in catharsis mode');\n            }\n            const transformed = transform(result.element);\n            transformed.repeatable = true;\n            return transformed;\n        },\n        JsdocTypeAny: () => ({\n            type: 'AllLiteral'\n        }),\n        JsdocTypeNull: () => ({\n            type: 'NullLiteral'\n        }),\n        JsdocTypeStringValue: result => makeName(quote(result.value, result.meta.quote)),\n        JsdocTypeUndefined: () => ({\n            type: 'UndefinedLiteral'\n        }),\n        JsdocTypeUnknown: () => ({\n            type: 'UnknownLiteral'\n        }),\n        JsdocTypeFunction: (result, transform) => {\n            const params = extractSpecialParams(result);\n            const transformed = {\n                type: 'FunctionType',\n                params: params.params.map(transform)\n            };\n            if (params.this !== undefined) {\n                transformed.this = transform(params.this);\n            }\n            if (params.new !== undefined) {\n                transformed.new = transform(params.new);\n            }\n            if (result.returnType !== undefined) {\n                transformed.result = transform(result.returnType);\n            }\n            return transformed;\n        },\n        JsdocTypeGeneric: (result, transform) => ({\n            type: 'TypeApplication',\n            applications: result.elements.map(o => transform(o)),\n            expression: transform(result.left)\n        }),\n        JsdocTypeSpecialNamePath: result => makeName(result.specialType + ':' + quote(result.value, result.meta.quote)),\n        JsdocTypeName: result => {\n            if (result.value !== 'function') {\n                return makeName(result.value);\n            }\n            else {\n                return {\n                    type: 'FunctionType',\n                    params: []\n                };\n            }\n        },\n        JsdocTypeNumber: result => makeName(result.value.toString()),\n        JsdocTypeObject: (result, transform) => {\n            const transformed = {\n                type: 'RecordType',\n                fields: []\n            };\n            for (const field of result.elements) {\n                if (field.type !== 'JsdocTypeObjectField' && field.type !== 'JsdocTypeJsdocObjectField') {\n                    transformed.fields.push({\n                        type: 'FieldType',\n                        key: transform(field),\n                        value: undefined\n                    });\n                }\n                else {\n                    transformed.fields.push(transform(field));\n                }\n            }\n            return transformed;\n        },\n        JsdocTypeObjectField: (result, transform) => {\n            if (typeof result.key !== 'string') {\n                throw new Error('Index signatures and mapped types are not supported');\n            }\n            return {\n                type: 'FieldType',\n                key: makeName(quote(result.key, result.meta.quote)),\n                value: result.right === undefined ? undefined : transform(result.right)\n            };\n        },\n        JsdocTypeJsdocObjectField: (result, transform) => ({\n            type: 'FieldType',\n            key: transform(result.left),\n            value: transform(result.right)\n        }),\n        JsdocTypeUnion: (result, transform) => ({\n            type: 'TypeUnion',\n            elements: result.elements.map(e => transform(e))\n        }),\n        JsdocTypeKeyValue: (result, transform) => {\n            return {\n                type: 'FieldType',\n                key: makeName(result.key),\n                value: result.right === undefined ? undefined : transform(result.right)\n            };\n        },\n        JsdocTypeNamePath: (result, transform) => {\n            const leftResult = transform(result.left);\n            let rightValue;\n            if (result.right.type === 'JsdocTypeSpecialNamePath') {\n                rightValue = transform(result.right).name;\n            }\n            else {\n                rightValue = quote(result.right.value, result.right.meta.quote);\n            }\n            const joiner = result.pathType === 'inner' ? '~' : result.pathType === 'instance' ? '#' : '.';\n            return makeName(`${leftResult.name}${joiner}${rightValue}`);\n        },\n        JsdocTypeSymbol: result => {\n            let value = '';\n            let element = result.element;\n            let trailingDots = false;\n            if ((element === null || element === void 0 ? void 0 : element.type) === 'JsdocTypeVariadic') {\n                if (element.meta.position === 'prefix') {\n                    value = '...';\n                }\n                else {\n                    trailingDots = true;\n                }\n                element = element.element;\n            }\n            if ((element === null || element === void 0 ? void 0 : element.type) === 'JsdocTypeName') {\n                value += element.value;\n            }\n            else if ((element === null || element === void 0 ? void 0 : element.type) === 'JsdocTypeNumber') {\n                value += element.value.toString();\n            }\n            if (trailingDots) {\n                value += '...';\n            }\n            return makeName(`${result.value}(${value})`);\n        },\n        JsdocTypeParenthesis: (result, transform) => transform(assertRootResult(result.element)),\n        JsdocTypeMappedType: notAvailableTransform,\n        JsdocTypeIndexSignature: notAvailableTransform,\n        JsdocTypeImport: notAvailableTransform,\n        JsdocTypeKeyof: notAvailableTransform,\n        JsdocTypeTuple: notAvailableTransform,\n        JsdocTypeTypeof: notAvailableTransform,\n        JsdocTypeIntersection: notAvailableTransform,\n        JsdocTypeProperty: notAvailableTransform,\n        JsdocTypePredicate: notAvailableTransform,\n        JsdocTypeAsserts: notAvailableTransform\n    };\n    function catharsisTransform(result) {\n        return transform(catharsisTransformRules, result);\n    }\n\n    function getQuoteStyle(quote) {\n        switch (quote) {\n            case undefined:\n                return 'none';\n            case 'single':\n                return 'single';\n            case 'double':\n                return 'double';\n        }\n    }\n    function getMemberType(type) {\n        switch (type) {\n            case 'inner':\n                return 'INNER_MEMBER';\n            case 'instance':\n                return 'INSTANCE_MEMBER';\n            case 'property':\n                return 'MEMBER';\n            case 'property-brackets':\n                return 'MEMBER';\n        }\n    }\n    function nestResults(type, results) {\n        if (results.length === 2) {\n            return {\n                type,\n                left: results[0],\n                right: results[1]\n            };\n        }\n        else {\n            return {\n                type,\n                left: results[0],\n                right: nestResults(type, results.slice(1))\n            };\n        }\n    }\n    const jtpRules = {\n        JsdocTypeOptional: (result, transform) => ({\n            type: 'OPTIONAL',\n            value: transform(result.element),\n            meta: {\n                syntax: result.meta.position === 'prefix' ? 'PREFIX_EQUAL_SIGN' : 'SUFFIX_EQUALS_SIGN'\n            }\n        }),\n        JsdocTypeNullable: (result, transform) => ({\n            type: 'NULLABLE',\n            value: transform(result.element),\n            meta: {\n                syntax: result.meta.position === 'prefix' ? 'PREFIX_QUESTION_MARK' : 'SUFFIX_QUESTION_MARK'\n            }\n        }),\n        JsdocTypeNotNullable: (result, transform) => ({\n            type: 'NOT_NULLABLE',\n            value: transform(result.element),\n            meta: {\n                syntax: result.meta.position === 'prefix' ? 'PREFIX_BANG' : 'SUFFIX_BANG'\n            }\n        }),\n        JsdocTypeVariadic: (result, transform) => {\n            const transformed = {\n                type: 'VARIADIC',\n                meta: {\n                    syntax: result.meta.position === 'prefix'\n                        ? 'PREFIX_DOTS'\n                        : result.meta.position === 'suffix' ? 'SUFFIX_DOTS' : 'ONLY_DOTS'\n                }\n            };\n            if (result.element !== undefined) {\n                transformed.value = transform(result.element);\n            }\n            return transformed;\n        },\n        JsdocTypeName: result => ({\n            type: 'NAME',\n            name: result.value\n        }),\n        JsdocTypeTypeof: (result, transform) => ({\n            type: 'TYPE_QUERY',\n            name: transform(result.element)\n        }),\n        JsdocTypeTuple: (result, transform) => ({\n            type: 'TUPLE',\n            entries: result.elements.map(transform)\n        }),\n        JsdocTypeKeyof: (result, transform) => ({\n            type: 'KEY_QUERY',\n            value: transform(result.element)\n        }),\n        JsdocTypeImport: result => ({\n            type: 'IMPORT',\n            path: {\n                type: 'STRING_VALUE',\n                quoteStyle: getQuoteStyle(result.element.meta.quote),\n                string: result.element.value\n            }\n        }),\n        JsdocTypeUndefined: () => ({\n            type: 'NAME',\n            name: 'undefined'\n        }),\n        JsdocTypeAny: () => ({\n            type: 'ANY'\n        }),\n        JsdocTypeFunction: (result, transform) => {\n            const specialParams = extractSpecialParams(result);\n            const transformed = {\n                type: result.arrow ? 'ARROW' : 'FUNCTION',\n                params: specialParams.params.map(param => {\n                    if (param.type === 'JsdocTypeKeyValue') {\n                        if (param.right === undefined) {\n                            throw new Error('Function parameter without \\':\\' is not expected to be \\'KEY_VALUE\\'');\n                        }\n                        return {\n                            type: 'NAMED_PARAMETER',\n                            name: param.key,\n                            typeName: transform(param.right)\n                        };\n                    }\n                    else {\n                        return transform(param);\n                    }\n                }),\n                new: null,\n                returns: null\n            };\n            if (specialParams.this !== undefined) {\n                transformed.this = transform(specialParams.this);\n            }\n            else if (!result.arrow) {\n                transformed.this = null;\n            }\n            if (specialParams.new !== undefined) {\n                transformed.new = transform(specialParams.new);\n            }\n            if (result.returnType !== undefined) {\n                transformed.returns = transform(result.returnType);\n            }\n            return transformed;\n        },\n        JsdocTypeGeneric: (result, transform) => {\n            const transformed = {\n                type: 'GENERIC',\n                subject: transform(result.left),\n                objects: result.elements.map(transform),\n                meta: {\n                    syntax: result.meta.brackets === 'square' ? 'SQUARE_BRACKET' : result.meta.dot ? 'ANGLE_BRACKET_WITH_DOT' : 'ANGLE_BRACKET'\n                }\n            };\n            if (result.meta.brackets === 'square' && result.elements[0].type === 'JsdocTypeFunction' && !result.elements[0].parenthesis) {\n                transformed.objects[0] = {\n                    type: 'NAME',\n                    name: 'function'\n                };\n            }\n            return transformed;\n        },\n        JsdocTypeObjectField: (result, transform) => {\n            if (typeof result.key !== 'string') {\n                throw new Error('Index signatures and mapped types are not supported');\n            }\n            if (result.right === undefined) {\n                return {\n                    type: 'RECORD_ENTRY',\n                    key: result.key,\n                    quoteStyle: getQuoteStyle(result.meta.quote),\n                    value: null,\n                    readonly: false\n                };\n            }\n            let right = transform(result.right);\n            if (result.optional) {\n                right = {\n                    type: 'OPTIONAL',\n                    value: right,\n                    meta: {\n                        syntax: 'SUFFIX_KEY_QUESTION_MARK'\n                    }\n                };\n            }\n            return {\n                type: 'RECORD_ENTRY',\n                key: result.key.toString(),\n                quoteStyle: getQuoteStyle(result.meta.quote),\n                value: right,\n                readonly: false\n            };\n        },\n        JsdocTypeJsdocObjectField: () => {\n            throw new Error('Keys may not be typed in jsdoctypeparser.');\n        },\n        JsdocTypeKeyValue: (result, transform) => {\n            if (result.right === undefined) {\n                return {\n                    type: 'RECORD_ENTRY',\n                    key: result.key,\n                    quoteStyle: 'none',\n                    value: null,\n                    readonly: false\n                };\n            }\n            let right = transform(result.right);\n            if (result.optional) {\n                right = {\n                    type: 'OPTIONAL',\n                    value: right,\n                    meta: {\n                        syntax: 'SUFFIX_KEY_QUESTION_MARK'\n                    }\n                };\n            }\n            return {\n                type: 'RECORD_ENTRY',\n                key: result.key,\n                quoteStyle: 'none',\n                value: right,\n                readonly: false\n            };\n        },\n        JsdocTypeObject: (result, transform) => {\n            const entries = [];\n            for (const field of result.elements) {\n                if (field.type === 'JsdocTypeObjectField' || field.type === 'JsdocTypeJsdocObjectField') {\n                    entries.push(transform(field));\n                }\n            }\n            return {\n                type: 'RECORD',\n                entries\n            };\n        },\n        JsdocTypeSpecialNamePath: result => {\n            if (result.specialType !== 'module') {\n                throw new Error(`jsdoctypeparser does not support type ${result.specialType} at this point.`);\n            }\n            return {\n                type: 'MODULE',\n                value: {\n                    type: 'FILE_PATH',\n                    quoteStyle: getQuoteStyle(result.meta.quote),\n                    path: result.value\n                }\n            };\n        },\n        JsdocTypeNamePath: (result, transform) => {\n            let hasEventPrefix = false;\n            let name;\n            let quoteStyle;\n            if (result.right.type === 'JsdocTypeSpecialNamePath' && result.right.specialType === 'event') {\n                hasEventPrefix = true;\n                name = result.right.value;\n                quoteStyle = getQuoteStyle(result.right.meta.quote);\n            }\n            else {\n                name = result.right.value;\n                quoteStyle = getQuoteStyle(result.right.meta.quote);\n            }\n            const transformed = {\n                type: getMemberType(result.pathType),\n                owner: transform(result.left),\n                name,\n                quoteStyle,\n                hasEventPrefix\n            };\n            if (transformed.owner.type === 'MODULE') {\n                const tModule = transformed.owner;\n                transformed.owner = transformed.owner.value;\n                tModule.value = transformed;\n                return tModule;\n            }\n            else {\n                return transformed;\n            }\n        },\n        JsdocTypeUnion: (result, transform) => nestResults('UNION', result.elements.map(transform)),\n        JsdocTypeParenthesis: (result, transform) => ({\n            type: 'PARENTHESIS',\n            value: transform(assertRootResult(result.element))\n        }),\n        JsdocTypeNull: () => ({\n            type: 'NAME',\n            name: 'null'\n        }),\n        JsdocTypeUnknown: () => ({\n            type: 'UNKNOWN'\n        }),\n        JsdocTypeStringValue: result => ({\n            type: 'STRING_VALUE',\n            quoteStyle: getQuoteStyle(result.meta.quote),\n            string: result.value\n        }),\n        JsdocTypeIntersection: (result, transform) => nestResults('INTERSECTION', result.elements.map(transform)),\n        JsdocTypeNumber: result => ({\n            type: 'NUMBER_VALUE',\n            number: result.value.toString()\n        }),\n        JsdocTypeSymbol: notAvailableTransform,\n        JsdocTypeProperty: notAvailableTransform,\n        JsdocTypePredicate: notAvailableTransform,\n        JsdocTypeMappedType: notAvailableTransform,\n        JsdocTypeIndexSignature: notAvailableTransform,\n        JsdocTypeAsserts: notAvailableTransform\n    };\n    function jtpTransform(result) {\n        return transform(jtpRules, result);\n    }\n\n    function identityTransformRules() {\n        return {\n            JsdocTypeIntersection: (result, transform) => ({\n                type: 'JsdocTypeIntersection',\n                elements: result.elements.map(transform)\n            }),\n            JsdocTypeGeneric: (result, transform) => ({\n                type: 'JsdocTypeGeneric',\n                left: transform(result.left),\n                elements: result.elements.map(transform),\n                meta: {\n                    dot: result.meta.dot,\n                    brackets: result.meta.brackets\n                }\n            }),\n            JsdocTypeNullable: result => result,\n            JsdocTypeUnion: (result, transform) => ({\n                type: 'JsdocTypeUnion',\n                elements: result.elements.map(transform)\n            }),\n            JsdocTypeUnknown: result => result,\n            JsdocTypeUndefined: result => result,\n            JsdocTypeTypeof: (result, transform) => ({\n                type: 'JsdocTypeTypeof',\n                element: transform(result.element)\n            }),\n            JsdocTypeSymbol: (result, transform) => {\n                const transformed = {\n                    type: 'JsdocTypeSymbol',\n                    value: result.value\n                };\n                if (result.element !== undefined) {\n                    transformed.element = transform(result.element);\n                }\n                return transformed;\n            },\n            JsdocTypeOptional: (result, transform) => ({\n                type: 'JsdocTypeOptional',\n                element: transform(result.element),\n                meta: {\n                    position: result.meta.position\n                }\n            }),\n            JsdocTypeObject: (result, transform) => ({\n                type: 'JsdocTypeObject',\n                meta: {\n                    separator: 'comma'\n                },\n                elements: result.elements.map(transform)\n            }),\n            JsdocTypeNumber: result => result,\n            JsdocTypeNull: result => result,\n            JsdocTypeNotNullable: (result, transform) => ({\n                type: 'JsdocTypeNotNullable',\n                element: transform(result.element),\n                meta: {\n                    position: result.meta.position\n                }\n            }),\n            JsdocTypeSpecialNamePath: result => result,\n            JsdocTypeObjectField: (result, transform) => ({\n                type: 'JsdocTypeObjectField',\n                key: result.key,\n                right: result.right === undefined ? undefined : transform(result.right),\n                optional: result.optional,\n                readonly: result.readonly,\n                meta: result.meta\n            }),\n            JsdocTypeJsdocObjectField: (result, transform) => ({\n                type: 'JsdocTypeJsdocObjectField',\n                left: transform(result.left),\n                right: transform(result.right)\n            }),\n            JsdocTypeKeyValue: (result, transform) => {\n                return {\n                    type: 'JsdocTypeKeyValue',\n                    key: result.key,\n                    right: result.right === undefined ? undefined : transform(result.right),\n                    optional: result.optional,\n                    variadic: result.variadic\n                };\n            },\n            JsdocTypeImport: (result, transform) => ({\n                type: 'JsdocTypeImport',\n                element: transform(result.element)\n            }),\n            JsdocTypeAny: result => result,\n            JsdocTypeStringValue: result => result,\n            JsdocTypeNamePath: result => result,\n            JsdocTypeVariadic: (result, transform) => {\n                const transformed = {\n                    type: 'JsdocTypeVariadic',\n                    meta: {\n                        position: result.meta.position,\n                        squareBrackets: result.meta.squareBrackets\n                    }\n                };\n                if (result.element !== undefined) {\n                    transformed.element = transform(result.element);\n                }\n                return transformed;\n            },\n            JsdocTypeTuple: (result, transform) => ({\n                type: 'JsdocTypeTuple',\n                elements: result.elements.map(transform)\n            }),\n            JsdocTypeName: result => result,\n            JsdocTypeFunction: (result, transform) => {\n                const transformed = {\n                    type: 'JsdocTypeFunction',\n                    arrow: result.arrow,\n                    parameters: result.parameters.map(transform),\n                    constructor: result.constructor,\n                    parenthesis: result.parenthesis\n                };\n                if (result.returnType !== undefined) {\n                    transformed.returnType = transform(result.returnType);\n                }\n                return transformed;\n            },\n            JsdocTypeKeyof: (result, transform) => ({\n                type: 'JsdocTypeKeyof',\n                element: transform(result.element)\n            }),\n            JsdocTypeParenthesis: (result, transform) => ({\n                type: 'JsdocTypeParenthesis',\n                element: transform(result.element)\n            }),\n            JsdocTypeProperty: result => result,\n            JsdocTypePredicate: (result, transform) => ({\n                type: 'JsdocTypePredicate',\n                left: transform(result.left),\n                right: transform(result.right)\n            }),\n            JsdocTypeIndexSignature: (result, transform) => ({\n                type: 'JsdocTypeIndexSignature',\n                key: result.key,\n                right: transform(result.right)\n            }),\n            JsdocTypeMappedType: (result, transform) => ({\n                type: 'JsdocTypeMappedType',\n                key: result.key,\n                right: transform(result.right)\n            }),\n            JsdocTypeAsserts: (result, transform) => ({\n                type: 'JsdocTypeAsserts',\n                left: transform(result.left),\n                right: transform(result.right)\n            })\n        };\n    }\n\n    const visitorKeys = {\n        JsdocTypeAny: [],\n        JsdocTypeFunction: ['parameters', 'returnType'],\n        JsdocTypeGeneric: ['left', 'elements'],\n        JsdocTypeImport: [],\n        JsdocTypeIndexSignature: ['right'],\n        JsdocTypeIntersection: ['elements'],\n        JsdocTypeKeyof: ['element'],\n        JsdocTypeKeyValue: ['right'],\n        JsdocTypeMappedType: ['right'],\n        JsdocTypeName: [],\n        JsdocTypeNamePath: ['left', 'right'],\n        JsdocTypeNotNullable: ['element'],\n        JsdocTypeNull: [],\n        JsdocTypeNullable: ['element'],\n        JsdocTypeNumber: [],\n        JsdocTypeObject: ['elements'],\n        JsdocTypeObjectField: ['right'],\n        JsdocTypeJsdocObjectField: ['left', 'right'],\n        JsdocTypeOptional: ['element'],\n        JsdocTypeParenthesis: ['element'],\n        JsdocTypeSpecialNamePath: [],\n        JsdocTypeStringValue: [],\n        JsdocTypeSymbol: ['element'],\n        JsdocTypeTuple: ['elements'],\n        JsdocTypeTypeof: ['element'],\n        JsdocTypeUndefined: [],\n        JsdocTypeUnion: ['elements'],\n        JsdocTypeUnknown: [],\n        JsdocTypeVariadic: ['element'],\n        JsdocTypeProperty: [],\n        JsdocTypePredicate: ['left', 'right'],\n        JsdocTypeAsserts: ['left', 'right']\n    };\n\n    function _traverse(node, parentNode, property, onEnter, onLeave) {\n        onEnter === null || onEnter === void 0 ? void 0 : onEnter(node, parentNode, property);\n        const keysToVisit = visitorKeys[node.type];\n        for (const key of keysToVisit) {\n            const value = node[key];\n            if (value !== undefined) {\n                if (Array.isArray(value)) {\n                    for (const element of value) {\n                        _traverse(element, node, key, onEnter, onLeave);\n                    }\n                }\n                else {\n                    _traverse(value, node, key, onEnter, onLeave);\n                }\n            }\n        }\n        onLeave === null || onLeave === void 0 ? void 0 : onLeave(node, parentNode, property);\n    }\n    /**\n     * A function to traverse an AST. It traverses it depth first.\n     * @param node the node to start traversing at.\n     * @param onEnter node visitor function that will be called on entering the node. This corresponds to preorder traversing.\n     * @param onLeave node visitor function that will be called on leaving the node. This corresponds to postorder traversing.\n     */\n    function traverse(node, onEnter, onLeave) {\n        _traverse(node, undefined, undefined, onEnter, onLeave);\n    }\n\n    exports.catharsisTransform = catharsisTransform;\n    exports.identityTransformRules = identityTransformRules;\n    exports.jtpTransform = jtpTransform;\n    exports.parse = parse;\n    exports.stringify = stringify;\n    exports.stringifyRules = stringifyRules;\n    exports.transform = transform;\n    exports.traverse = traverse;\n    exports.tryParse = tryParse;\n    exports.visitorKeys = visitorKeys;\n\n}));\n","// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n"],"names":[],"sourceRoot":""}